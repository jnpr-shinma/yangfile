/* 
 * @(#)MmeProfileTrafficShaping.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.feature.trafficShaping;

import Element;

import Epc;

import JNCException;

import Leaf;

import YangEnumeration;

import YangUInt8;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/feature/trafficShaping/mme-profile-traffic-shaping"
 * <p>
 * See line 316 in
 * featuresConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeProfileTrafficShaping extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeProfileTrafficShaping object.
     */
    public MmeProfileTrafficShaping() {
        super(Epc.NAMESPACE, "mme-profile-traffic-shaping");
    }

    /**
     * Constructor for an initialized MmeProfileTrafficShaping object,
     * 
     * @param priorityFieldValue Key argument of child.
     * @param trafficClassValue Key argument of child.
     */
    public MmeProfileTrafficShaping(YangUInt8 priorityFieldValue, YangEnumeration trafficClassValue)
            throws JNCException {
        super(Epc.NAMESPACE, "mme-profile-traffic-shaping");
        Leaf priorityField = new Leaf(Epc.NAMESPACE, "priority-field");
        priorityField.setValue(priorityFieldValue);
        insertChild(priorityField, childrenNames());
        Leaf trafficClass = new Leaf(Epc.NAMESPACE, "traffic-class");
        trafficClass.setValue(trafficClassValue);
        insertChild(trafficClass, childrenNames());
    }

    /**
     * Constructor for an initialized MmeProfileTrafficShaping object,
     * with String keys.
     * @param priorityFieldValue Key argument of child.
     * @param trafficClassValue Key argument of child.
     */
    public MmeProfileTrafficShaping(String priorityFieldValue, String trafficClassValue)
            throws JNCException {
        super(Epc.NAMESPACE, "mme-profile-traffic-shaping");
        Leaf priorityField = new Leaf(Epc.NAMESPACE, "priority-field");
        priorityField.setValue(new YangUInt8(priorityFieldValue));
        insertChild(priorityField, childrenNames());
        Leaf trafficClass = new Leaf(Epc.NAMESPACE, "traffic-class");
        trafficClass.setValue(new YangEnumeration(trafficClassValue, new String [] {"conversational", "streaming", "interactive-thp1", "interactive-thp2", "interactive-thp3", "background", }));
        insertChild(trafficClass, childrenNames());
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeProfileTrafficShaping clone() {
        MmeProfileTrafficShaping copy;
        try {
            copy = new MmeProfileTrafficShaping(getPriorityFieldValue().toString(), getTrafficClassValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (MmeProfileTrafficShaping)cloneContent(copy);
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeProfileTrafficShaping cloneShallow() {
        MmeProfileTrafficShaping copy;
        try {
            copy = new MmeProfileTrafficShaping(getPriorityFieldValue().toString(), getTrafficClassValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (MmeProfileTrafficShaping)cloneShallowContent(copy);
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return new String[] {
            "priority-field",
            "traffic-class",
        };
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "priority-field",
            "traffic-class",
            "data-dscp-mark",
            "preemption-capability",
            "preemption-vulnerable",
            "queuing-allowed",
        };
    }

    /* Access methods for leaf child: "priority-field". */

    /**
     * Gets the value for child leaf "priority-field".
     * @return The value of the leaf.
     */
    public YangUInt8 getPriorityFieldValue() throws JNCException {
        return (YangUInt8)getValue("priority-field");
    }

    /**
     * Sets the value for child leaf "priority-field",
     * using instance of generated typedef class.
     * @param priorityFieldValue The value to set.
     * @param priorityFieldValue used during instantiation.
     */
    public void setPriorityFieldValue(YangUInt8 priorityFieldValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "priority-field",
            priorityFieldValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "priority-field",
     * using Java primitive values.
     * @param priorityFieldValue used during instantiation.
     */
    public void setPriorityFieldValue(short priorityFieldValue)
            throws JNCException {
        setPriorityFieldValue(new YangUInt8(priorityFieldValue));
    }

    /**
     * Sets the value for child leaf "priority-field",
     * using a String value.
     * @param priorityFieldValue used during instantiation.
     */
    public void setPriorityFieldValue(String priorityFieldValue)
            throws JNCException {
        setPriorityFieldValue(new YangUInt8(priorityFieldValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "priority-field" leaf will not have a value.
     */
    public void addPriorityField() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "priority-field",
            null,
            childrenNames());
    }

    /* Access methods for leaf child: "traffic-class". */

    /**
     * Gets the value for child leaf "traffic-class".
     * @return The value of the leaf.
     */
    public YangEnumeration getTrafficClassValue() throws JNCException {
        return (YangEnumeration)getValue("traffic-class");
    }

    /**
     * Sets the value for child leaf "traffic-class",
     * using instance of generated typedef class.
     * @param trafficClassValue The value to set.
     * @param trafficClassValue used during instantiation.
     */
    public void setTrafficClassValue(YangEnumeration trafficClassValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "traffic-class",
            trafficClassValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "traffic-class",
     * using a String value.
     * @param trafficClassValue used during instantiation.
     */
    public void setTrafficClassValue(String trafficClassValue)
            throws JNCException {
        setTrafficClassValue(new YangEnumeration(trafficClassValue, new String[] {
             "conversational",
             "streaming",
             "interactive-thp1",
             "interactive-thp2",
             "interactive-thp3",
             "background",
        }));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "traffic-class" leaf will not have a value.
     */
    public void addTrafficClass() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "traffic-class",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "data-dscp-mark". */

    /**
     * Gets the value for child leaf "data-dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDataDscpMarkValue() throws JNCException {
        YangString dataDscpMark = (YangString)getValue("data-dscp-mark");
        if (dataDscpMark == null) {
            dataDscpMark = new YangString("de");  // default
        }
        return dataDscpMark;
    }

    /**
     * Sets the value for child leaf "data-dscp-mark",
     * using instance of generated typedef class.
     * @param dataDscpMarkValue The value to set.
     * @param dataDscpMarkValue used during instantiation.
     */
    public void setDataDscpMarkValue(YangString dataDscpMarkValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "data-dscp-mark",
            dataDscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "data-dscp-mark",
     * using a String value.
     * @param dataDscpMarkValue used during instantiation.
     */
    public void setDataDscpMarkValue(String dataDscpMarkValue)
            throws JNCException {
        setDataDscpMarkValue(new YangString(dataDscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "data-dscp-mark".
     */
    public void unsetDataDscpMarkValue() throws JNCException {
        delete("data-dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "data-dscp-mark" leaf will not have a value.
     */
    public void addDataDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "data-dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "data-dscp-mark" with operation "replace".
     */
    public void markDataDscpMarkReplace() throws JNCException {
        markLeafReplace("dataDscpMark");
    }

    /**
     * Marks the leaf "data-dscp-mark" with operation "merge".
     */
    public void markDataDscpMarkMerge() throws JNCException {
        markLeafMerge("dataDscpMark");
    }

    /**
     * Marks the leaf "data-dscp-mark" with operation "create".
     */
    public void markDataDscpMarkCreate() throws JNCException {
        markLeafCreate("dataDscpMark");
    }

    /**
     * Marks the leaf "data-dscp-mark" with operation "delete".
     */
    public void markDataDscpMarkDelete() throws JNCException {
        markLeafDelete("dataDscpMark");
    }

    /* Access methods for optional leaf child: "preemption-capability". */

    /**
     * Gets the value for child leaf "preemption-capability".
     * @return The value of the leaf.
     */
    public YangEnumeration getPreemptionCapabilityValue() throws JNCException {
        YangEnumeration preemptionCapability = (YangEnumeration)getValue("preemption-capability");
        if (preemptionCapability == null) {
            preemptionCapability = new YangEnumeration("auto-configure", new String[] {  // default
                "disabled",
                "enabled",
                "auto-configure",
            });
        }
        return preemptionCapability;
    }

    /**
     * Sets the value for child leaf "preemption-capability",
     * using instance of generated typedef class.
     * @param preemptionCapabilityValue The value to set.
     * @param preemptionCapabilityValue used during instantiation.
     */
    public void setPreemptionCapabilityValue(YangEnumeration preemptionCapabilityValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "preemption-capability",
            preemptionCapabilityValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "preemption-capability",
     * using a String value.
     * @param preemptionCapabilityValue used during instantiation.
     */
    public void setPreemptionCapabilityValue(String preemptionCapabilityValue)
            throws JNCException {
        setPreemptionCapabilityValue(new YangEnumeration(preemptionCapabilityValue, new String[] {
             "disabled",
             "enabled",
             "auto-configure",
        }));
    }

    /**
     * Unsets the value for child leaf "preemption-capability".
     */
    public void unsetPreemptionCapabilityValue() throws JNCException {
        delete("preemption-capability");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "preemption-capability" leaf will not have a value.
     */
    public void addPreemptionCapability() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "preemption-capability",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "preemption-capability" with operation "replace".
     */
    public void markPreemptionCapabilityReplace() throws JNCException {
        markLeafReplace("preemptionCapability");
    }

    /**
     * Marks the leaf "preemption-capability" with operation "merge".
     */
    public void markPreemptionCapabilityMerge() throws JNCException {
        markLeafMerge("preemptionCapability");
    }

    /**
     * Marks the leaf "preemption-capability" with operation "create".
     */
    public void markPreemptionCapabilityCreate() throws JNCException {
        markLeafCreate("preemptionCapability");
    }

    /**
     * Marks the leaf "preemption-capability" with operation "delete".
     */
    public void markPreemptionCapabilityDelete() throws JNCException {
        markLeafDelete("preemptionCapability");
    }

    /* Access methods for optional leaf child: "preemption-vulnerable". */

    /**
     * Gets the value for child leaf "preemption-vulnerable".
     * @return The value of the leaf.
     */
    public YangEnumeration getPreemptionVulnerableValue() throws JNCException {
        YangEnumeration preemptionVulnerable = (YangEnumeration)getValue("preemption-vulnerable");
        if (preemptionVulnerable == null) {
            preemptionVulnerable = new YangEnumeration("auto-configure", new String[] {  // default
                "disabled",
                "enabled",
                "auto-configure",
            });
        }
        return preemptionVulnerable;
    }

    /**
     * Sets the value for child leaf "preemption-vulnerable",
     * using instance of generated typedef class.
     * @param preemptionVulnerableValue The value to set.
     * @param preemptionVulnerableValue used during instantiation.
     */
    public void setPreemptionVulnerableValue(YangEnumeration preemptionVulnerableValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "preemption-vulnerable",
            preemptionVulnerableValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "preemption-vulnerable",
     * using a String value.
     * @param preemptionVulnerableValue used during instantiation.
     */
    public void setPreemptionVulnerableValue(String preemptionVulnerableValue)
            throws JNCException {
        setPreemptionVulnerableValue(new YangEnumeration(preemptionVulnerableValue, new String[] {
             "disabled",
             "enabled",
             "auto-configure",
        }));
    }

    /**
     * Unsets the value for child leaf "preemption-vulnerable".
     */
    public void unsetPreemptionVulnerableValue() throws JNCException {
        delete("preemption-vulnerable");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "preemption-vulnerable" leaf will not have a value.
     */
    public void addPreemptionVulnerable() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "preemption-vulnerable",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "preemption-vulnerable" with operation "replace".
     */
    public void markPreemptionVulnerableReplace() throws JNCException {
        markLeafReplace("preemptionVulnerable");
    }

    /**
     * Marks the leaf "preemption-vulnerable" with operation "merge".
     */
    public void markPreemptionVulnerableMerge() throws JNCException {
        markLeafMerge("preemptionVulnerable");
    }

    /**
     * Marks the leaf "preemption-vulnerable" with operation "create".
     */
    public void markPreemptionVulnerableCreate() throws JNCException {
        markLeafCreate("preemptionVulnerable");
    }

    /**
     * Marks the leaf "preemption-vulnerable" with operation "delete".
     */
    public void markPreemptionVulnerableDelete() throws JNCException {
        markLeafDelete("preemptionVulnerable");
    }

    /* Access methods for optional leaf child: "queuing-allowed". */

    /**
     * Gets the value for child leaf "queuing-allowed".
     * @return The value of the leaf.
     */
    public YangEnumeration getQueuingAllowedValue() throws JNCException {
        YangEnumeration queuingAllowed = (YangEnumeration)getValue("queuing-allowed");
        if (queuingAllowed == null) {
            queuingAllowed = new YangEnumeration("auto-configure", new String[] {  // default
                "disabled",
                "enabled",
                "auto-configure",
            });
        }
        return queuingAllowed;
    }

    /**
     * Sets the value for child leaf "queuing-allowed",
     * using instance of generated typedef class.
     * @param queuingAllowedValue The value to set.
     * @param queuingAllowedValue used during instantiation.
     */
    public void setQueuingAllowedValue(YangEnumeration queuingAllowedValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "queuing-allowed",
            queuingAllowedValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "queuing-allowed",
     * using a String value.
     * @param queuingAllowedValue used during instantiation.
     */
    public void setQueuingAllowedValue(String queuingAllowedValue)
            throws JNCException {
        setQueuingAllowedValue(new YangEnumeration(queuingAllowedValue, new String[] {
             "disabled",
             "enabled",
             "auto-configure",
        }));
    }

    /**
     * Unsets the value for child leaf "queuing-allowed".
     */
    public void unsetQueuingAllowedValue() throws JNCException {
        delete("queuing-allowed");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "queuing-allowed" leaf will not have a value.
     */
    public void addQueuingAllowed() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "queuing-allowed",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "queuing-allowed" with operation "replace".
     */
    public void markQueuingAllowedReplace() throws JNCException {
        markLeafReplace("queuingAllowed");
    }

    /**
     * Marks the leaf "queuing-allowed" with operation "merge".
     */
    public void markQueuingAllowedMerge() throws JNCException {
        markLeafMerge("queuingAllowed");
    }

    /**
     * Marks the leaf "queuing-allowed" with operation "create".
     */
    public void markQueuingAllowedCreate() throws JNCException {
        markLeafCreate("queuingAllowed");
    }

    /**
     * Marks the leaf "queuing-allowed" with operation "delete".
     */
    public void markQueuingAllowedDelete() throws JNCException {
        markLeafDelete("queuingAllowed");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
