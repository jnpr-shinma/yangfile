/* 
 * @(#)OffloadOper.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.subscriber;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/subscriber/offload-oper"
 * <p>
 * See line 1611 in
 * scCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class OffloadOper extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty OffloadOper object.
     */
    public OffloadOper() {
        super(Epc.NAMESPACE, "offload-oper");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public OffloadOper clone() {
        return (OffloadOper)cloneContent(new OffloadOper());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public OffloadOper cloneShallow() {
        return (OffloadOper)cloneShallowContent(new OffloadOper());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "service",
            "location",
            "connected-mode-action",
            "idle-mode-action",
            "finish-in",
            "hold-duration",
            "current-active-subscribers",
            "current-idle-subscribers",
            "finish-in-remaining",
            "hold-duration-remaining",
            "offload-type",
            "target-mme-ip-address",
            "target-sgsn-ip-address",
            "ue-qty",
            "ue-state",
        };
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "location". */

    /**
     * Gets the value for child leaf "location".
     * @return The value of the leaf.
     */
    public YangString getLocationValue() throws JNCException {
        return (YangString)getValue("location");
    }

    /**
     * Sets the value for child leaf "location",
     * using instance of generated typedef class.
     * @param locationValue The value to set.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(YangString locationValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            locationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location",
     * using a String value.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(String locationValue) throws JNCException {
        setLocationValue(new YangString(locationValue));
    }

    /**
     * Unsets the value for child leaf "location".
     */
    public void unsetLocationValue() throws JNCException {
        delete("location");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location" leaf will not have a value.
     */
    public void addLocation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location" with operation "replace".
     */
    public void markLocationReplace() throws JNCException {
        markLeafReplace("location");
    }

    /**
     * Marks the leaf "location" with operation "merge".
     */
    public void markLocationMerge() throws JNCException {
        markLeafMerge("location");
    }

    /**
     * Marks the leaf "location" with operation "create".
     */
    public void markLocationCreate() throws JNCException {
        markLeafCreate("location");
    }

    /**
     * Marks the leaf "location" with operation "delete".
     */
    public void markLocationDelete() throws JNCException {
        markLeafDelete("location");
    }

    /* Access methods for optional leaf child: "connected-mode-action". */

    /**
     * Gets the value for child leaf "connected-mode-action".
     * @return The value of the leaf.
     */
    public YangString getConnectedModeActionValue() throws JNCException {
        return (YangString)getValue("connected-mode-action");
    }

    /**
     * Sets the value for child leaf "connected-mode-action",
     * using instance of generated typedef class.
     * @param connectedModeActionValue The value to set.
     * @param connectedModeActionValue used during instantiation.
     */
    public void setConnectedModeActionValue(YangString connectedModeActionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "connected-mode-action",
            connectedModeActionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "connected-mode-action",
     * using a String value.
     * @param connectedModeActionValue used during instantiation.
     */
    public void setConnectedModeActionValue(String connectedModeActionValue)
            throws JNCException {
        setConnectedModeActionValue(new YangString(connectedModeActionValue));
    }

    /**
     * Unsets the value for child leaf "connected-mode-action".
     */
    public void unsetConnectedModeActionValue() throws JNCException {
        delete("connected-mode-action");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "connected-mode-action" leaf will not have a value.
     */
    public void addConnectedModeAction() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "connected-mode-action",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "connected-mode-action" with operation "replace".
     */
    public void markConnectedModeActionReplace() throws JNCException {
        markLeafReplace("connectedModeAction");
    }

    /**
     * Marks the leaf "connected-mode-action" with operation "merge".
     */
    public void markConnectedModeActionMerge() throws JNCException {
        markLeafMerge("connectedModeAction");
    }

    /**
     * Marks the leaf "connected-mode-action" with operation "create".
     */
    public void markConnectedModeActionCreate() throws JNCException {
        markLeafCreate("connectedModeAction");
    }

    /**
     * Marks the leaf "connected-mode-action" with operation "delete".
     */
    public void markConnectedModeActionDelete() throws JNCException {
        markLeafDelete("connectedModeAction");
    }

    /* Access methods for optional leaf child: "idle-mode-action". */

    /**
     * Gets the value for child leaf "idle-mode-action".
     * @return The value of the leaf.
     */
    public YangString getIdleModeActionValue() throws JNCException {
        return (YangString)getValue("idle-mode-action");
    }

    /**
     * Sets the value for child leaf "idle-mode-action",
     * using instance of generated typedef class.
     * @param idleModeActionValue The value to set.
     * @param idleModeActionValue used during instantiation.
     */
    public void setIdleModeActionValue(YangString idleModeActionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "idle-mode-action",
            idleModeActionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "idle-mode-action",
     * using a String value.
     * @param idleModeActionValue used during instantiation.
     */
    public void setIdleModeActionValue(String idleModeActionValue)
            throws JNCException {
        setIdleModeActionValue(new YangString(idleModeActionValue));
    }

    /**
     * Unsets the value for child leaf "idle-mode-action".
     */
    public void unsetIdleModeActionValue() throws JNCException {
        delete("idle-mode-action");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "idle-mode-action" leaf will not have a value.
     */
    public void addIdleModeAction() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "idle-mode-action",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "idle-mode-action" with operation "replace".
     */
    public void markIdleModeActionReplace() throws JNCException {
        markLeafReplace("idleModeAction");
    }

    /**
     * Marks the leaf "idle-mode-action" with operation "merge".
     */
    public void markIdleModeActionMerge() throws JNCException {
        markLeafMerge("idleModeAction");
    }

    /**
     * Marks the leaf "idle-mode-action" with operation "create".
     */
    public void markIdleModeActionCreate() throws JNCException {
        markLeafCreate("idleModeAction");
    }

    /**
     * Marks the leaf "idle-mode-action" with operation "delete".
     */
    public void markIdleModeActionDelete() throws JNCException {
        markLeafDelete("idleModeAction");
    }

    /* Access methods for optional leaf child: "finish-in". */

    /**
     * Gets the value for child leaf "finish-in".
     * @return The value of the leaf.
     */
    public YangUInt32 getFinishInValue() throws JNCException {
        return (YangUInt32)getValue("finish-in");
    }

    /**
     * Sets the value for child leaf "finish-in",
     * using instance of generated typedef class.
     * @param finishInValue The value to set.
     * @param finishInValue used during instantiation.
     */
    public void setFinishInValue(YangUInt32 finishInValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "finish-in",
            finishInValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "finish-in",
     * using Java primitive values.
     * @param finishInValue used during instantiation.
     */
    public void setFinishInValue(long finishInValue) throws JNCException {
        setFinishInValue(new YangUInt32(finishInValue));
    }

    /**
     * Sets the value for child leaf "finish-in",
     * using a String value.
     * @param finishInValue used during instantiation.
     */
    public void setFinishInValue(String finishInValue) throws JNCException {
        setFinishInValue(new YangUInt32(finishInValue));
    }

    /**
     * Unsets the value for child leaf "finish-in".
     */
    public void unsetFinishInValue() throws JNCException {
        delete("finish-in");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "finish-in" leaf will not have a value.
     */
    public void addFinishIn() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "finish-in",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "finish-in" with operation "replace".
     */
    public void markFinishInReplace() throws JNCException {
        markLeafReplace("finishIn");
    }

    /**
     * Marks the leaf "finish-in" with operation "merge".
     */
    public void markFinishInMerge() throws JNCException {
        markLeafMerge("finishIn");
    }

    /**
     * Marks the leaf "finish-in" with operation "create".
     */
    public void markFinishInCreate() throws JNCException {
        markLeafCreate("finishIn");
    }

    /**
     * Marks the leaf "finish-in" with operation "delete".
     */
    public void markFinishInDelete() throws JNCException {
        markLeafDelete("finishIn");
    }

    /* Access methods for optional leaf child: "hold-duration". */

    /**
     * Gets the value for child leaf "hold-duration".
     * @return The value of the leaf.
     */
    public YangUInt32 getHoldDurationValue() throws JNCException {
        return (YangUInt32)getValue("hold-duration");
    }

    /**
     * Sets the value for child leaf "hold-duration",
     * using instance of generated typedef class.
     * @param holdDurationValue The value to set.
     * @param holdDurationValue used during instantiation.
     */
    public void setHoldDurationValue(YangUInt32 holdDurationValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hold-duration",
            holdDurationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "hold-duration",
     * using Java primitive values.
     * @param holdDurationValue used during instantiation.
     */
    public void setHoldDurationValue(long holdDurationValue)
            throws JNCException {
        setHoldDurationValue(new YangUInt32(holdDurationValue));
    }

    /**
     * Sets the value for child leaf "hold-duration",
     * using a String value.
     * @param holdDurationValue used during instantiation.
     */
    public void setHoldDurationValue(String holdDurationValue)
            throws JNCException {
        setHoldDurationValue(new YangUInt32(holdDurationValue));
    }

    /**
     * Unsets the value for child leaf "hold-duration".
     */
    public void unsetHoldDurationValue() throws JNCException {
        delete("hold-duration");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "hold-duration" leaf will not have a value.
     */
    public void addHoldDuration() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hold-duration",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "hold-duration" with operation "replace".
     */
    public void markHoldDurationReplace() throws JNCException {
        markLeafReplace("holdDuration");
    }

    /**
     * Marks the leaf "hold-duration" with operation "merge".
     */
    public void markHoldDurationMerge() throws JNCException {
        markLeafMerge("holdDuration");
    }

    /**
     * Marks the leaf "hold-duration" with operation "create".
     */
    public void markHoldDurationCreate() throws JNCException {
        markLeafCreate("holdDuration");
    }

    /**
     * Marks the leaf "hold-duration" with operation "delete".
     */
    public void markHoldDurationDelete() throws JNCException {
        markLeafDelete("holdDuration");
    }

    /* Access methods for optional leaf child: "current-active-subscribers". */

    /**
     * Gets the value for child leaf "current-active-subscribers".
     * @return The value of the leaf.
     */
    public YangUInt32 getCurrentActiveSubscribersValue() throws JNCException {
        return (YangUInt32)getValue("current-active-subscribers");
    }

    /**
     * Sets the value for child leaf "current-active-subscribers",
     * using instance of generated typedef class.
     * @param currentActiveSubscribersValue The value to set.
     * @param currentActiveSubscribersValue used during instantiation.
     */
    public void setCurrentActiveSubscribersValue(YangUInt32 currentActiveSubscribersValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-active-subscribers",
            currentActiveSubscribersValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-active-subscribers",
     * using Java primitive values.
     * @param currentActiveSubscribersValue used during instantiation.
     */
    public void setCurrentActiveSubscribersValue(long currentActiveSubscribersValue)
            throws JNCException {
        setCurrentActiveSubscribersValue(new YangUInt32(currentActiveSubscribersValue));
    }

    /**
     * Sets the value for child leaf "current-active-subscribers",
     * using a String value.
     * @param currentActiveSubscribersValue used during instantiation.
     */
    public void setCurrentActiveSubscribersValue(String currentActiveSubscribersValue)
            throws JNCException {
        setCurrentActiveSubscribersValue(new YangUInt32(currentActiveSubscribersValue));
    }

    /**
     * Unsets the value for child leaf "current-active-subscribers".
     */
    public void unsetCurrentActiveSubscribersValue() throws JNCException {
        delete("current-active-subscribers");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-active-subscribers" leaf will not have a value.
     */
    public void addCurrentActiveSubscribers() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-active-subscribers",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-active-subscribers" with operation "replace".
     */
    public void markCurrentActiveSubscribersReplace() throws JNCException {
        markLeafReplace("currentActiveSubscribers");
    }

    /**
     * Marks the leaf "current-active-subscribers" with operation "merge".
     */
    public void markCurrentActiveSubscribersMerge() throws JNCException {
        markLeafMerge("currentActiveSubscribers");
    }

    /**
     * Marks the leaf "current-active-subscribers" with operation "create".
     */
    public void markCurrentActiveSubscribersCreate() throws JNCException {
        markLeafCreate("currentActiveSubscribers");
    }

    /**
     * Marks the leaf "current-active-subscribers" with operation "delete".
     */
    public void markCurrentActiveSubscribersDelete() throws JNCException {
        markLeafDelete("currentActiveSubscribers");
    }

    /* Access methods for optional leaf child: "current-idle-subscribers". */

    /**
     * Gets the value for child leaf "current-idle-subscribers".
     * @return The value of the leaf.
     */
    public YangUInt32 getCurrentIdleSubscribersValue() throws JNCException {
        return (YangUInt32)getValue("current-idle-subscribers");
    }

    /**
     * Sets the value for child leaf "current-idle-subscribers",
     * using instance of generated typedef class.
     * @param currentIdleSubscribersValue The value to set.
     * @param currentIdleSubscribersValue used during instantiation.
     */
    public void setCurrentIdleSubscribersValue(YangUInt32 currentIdleSubscribersValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-idle-subscribers",
            currentIdleSubscribersValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-idle-subscribers",
     * using Java primitive values.
     * @param currentIdleSubscribersValue used during instantiation.
     */
    public void setCurrentIdleSubscribersValue(long currentIdleSubscribersValue)
            throws JNCException {
        setCurrentIdleSubscribersValue(new YangUInt32(currentIdleSubscribersValue));
    }

    /**
     * Sets the value for child leaf "current-idle-subscribers",
     * using a String value.
     * @param currentIdleSubscribersValue used during instantiation.
     */
    public void setCurrentIdleSubscribersValue(String currentIdleSubscribersValue)
            throws JNCException {
        setCurrentIdleSubscribersValue(new YangUInt32(currentIdleSubscribersValue));
    }

    /**
     * Unsets the value for child leaf "current-idle-subscribers".
     */
    public void unsetCurrentIdleSubscribersValue() throws JNCException {
        delete("current-idle-subscribers");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-idle-subscribers" leaf will not have a value.
     */
    public void addCurrentIdleSubscribers() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-idle-subscribers",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-idle-subscribers" with operation "replace".
     */
    public void markCurrentIdleSubscribersReplace() throws JNCException {
        markLeafReplace("currentIdleSubscribers");
    }

    /**
     * Marks the leaf "current-idle-subscribers" with operation "merge".
     */
    public void markCurrentIdleSubscribersMerge() throws JNCException {
        markLeafMerge("currentIdleSubscribers");
    }

    /**
     * Marks the leaf "current-idle-subscribers" with operation "create".
     */
    public void markCurrentIdleSubscribersCreate() throws JNCException {
        markLeafCreate("currentIdleSubscribers");
    }

    /**
     * Marks the leaf "current-idle-subscribers" with operation "delete".
     */
    public void markCurrentIdleSubscribersDelete() throws JNCException {
        markLeafDelete("currentIdleSubscribers");
    }

    /* Access methods for optional leaf child: "finish-in-remaining". */

    /**
     * Gets the value for child leaf "finish-in-remaining".
     * @return The value of the leaf.
     */
    public YangUInt32 getFinishInRemainingValue() throws JNCException {
        return (YangUInt32)getValue("finish-in-remaining");
    }

    /**
     * Sets the value for child leaf "finish-in-remaining",
     * using instance of generated typedef class.
     * @param finishInRemainingValue The value to set.
     * @param finishInRemainingValue used during instantiation.
     */
    public void setFinishInRemainingValue(YangUInt32 finishInRemainingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "finish-in-remaining",
            finishInRemainingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "finish-in-remaining",
     * using Java primitive values.
     * @param finishInRemainingValue used during instantiation.
     */
    public void setFinishInRemainingValue(long finishInRemainingValue)
            throws JNCException {
        setFinishInRemainingValue(new YangUInt32(finishInRemainingValue));
    }

    /**
     * Sets the value for child leaf "finish-in-remaining",
     * using a String value.
     * @param finishInRemainingValue used during instantiation.
     */
    public void setFinishInRemainingValue(String finishInRemainingValue)
            throws JNCException {
        setFinishInRemainingValue(new YangUInt32(finishInRemainingValue));
    }

    /**
     * Unsets the value for child leaf "finish-in-remaining".
     */
    public void unsetFinishInRemainingValue() throws JNCException {
        delete("finish-in-remaining");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "finish-in-remaining" leaf will not have a value.
     */
    public void addFinishInRemaining() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "finish-in-remaining",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "finish-in-remaining" with operation "replace".
     */
    public void markFinishInRemainingReplace() throws JNCException {
        markLeafReplace("finishInRemaining");
    }

    /**
     * Marks the leaf "finish-in-remaining" with operation "merge".
     */
    public void markFinishInRemainingMerge() throws JNCException {
        markLeafMerge("finishInRemaining");
    }

    /**
     * Marks the leaf "finish-in-remaining" with operation "create".
     */
    public void markFinishInRemainingCreate() throws JNCException {
        markLeafCreate("finishInRemaining");
    }

    /**
     * Marks the leaf "finish-in-remaining" with operation "delete".
     */
    public void markFinishInRemainingDelete() throws JNCException {
        markLeafDelete("finishInRemaining");
    }

    /* Access methods for optional leaf child: "hold-duration-remaining". */

    /**
     * Gets the value for child leaf "hold-duration-remaining".
     * @return The value of the leaf.
     */
    public YangUInt32 getHoldDurationRemainingValue() throws JNCException {
        return (YangUInt32)getValue("hold-duration-remaining");
    }

    /**
     * Sets the value for child leaf "hold-duration-remaining",
     * using instance of generated typedef class.
     * @param holdDurationRemainingValue The value to set.
     * @param holdDurationRemainingValue used during instantiation.
     */
    public void setHoldDurationRemainingValue(YangUInt32 holdDurationRemainingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hold-duration-remaining",
            holdDurationRemainingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "hold-duration-remaining",
     * using Java primitive values.
     * @param holdDurationRemainingValue used during instantiation.
     */
    public void setHoldDurationRemainingValue(long holdDurationRemainingValue)
            throws JNCException {
        setHoldDurationRemainingValue(new YangUInt32(holdDurationRemainingValue));
    }

    /**
     * Sets the value for child leaf "hold-duration-remaining",
     * using a String value.
     * @param holdDurationRemainingValue used during instantiation.
     */
    public void setHoldDurationRemainingValue(String holdDurationRemainingValue)
            throws JNCException {
        setHoldDurationRemainingValue(new YangUInt32(holdDurationRemainingValue));
    }

    /**
     * Unsets the value for child leaf "hold-duration-remaining".
     */
    public void unsetHoldDurationRemainingValue() throws JNCException {
        delete("hold-duration-remaining");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "hold-duration-remaining" leaf will not have a value.
     */
    public void addHoldDurationRemaining() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hold-duration-remaining",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "hold-duration-remaining" with operation "replace".
     */
    public void markHoldDurationRemainingReplace() throws JNCException {
        markLeafReplace("holdDurationRemaining");
    }

    /**
     * Marks the leaf "hold-duration-remaining" with operation "merge".
     */
    public void markHoldDurationRemainingMerge() throws JNCException {
        markLeafMerge("holdDurationRemaining");
    }

    /**
     * Marks the leaf "hold-duration-remaining" with operation "create".
     */
    public void markHoldDurationRemainingCreate() throws JNCException {
        markLeafCreate("holdDurationRemaining");
    }

    /**
     * Marks the leaf "hold-duration-remaining" with operation "delete".
     */
    public void markHoldDurationRemainingDelete() throws JNCException {
        markLeafDelete("holdDurationRemaining");
    }

    /* Access methods for optional leaf child: "offload-type". */

    /**
     * Gets the value for child leaf "offload-type".
     * @return The value of the leaf.
     */
    public YangString getOffloadTypeValue() throws JNCException {
        return (YangString)getValue("offload-type");
    }

    /**
     * Sets the value for child leaf "offload-type",
     * using instance of generated typedef class.
     * @param offloadTypeValue The value to set.
     * @param offloadTypeValue used during instantiation.
     */
    public void setOffloadTypeValue(YangString offloadTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "offload-type",
            offloadTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "offload-type",
     * using a String value.
     * @param offloadTypeValue used during instantiation.
     */
    public void setOffloadTypeValue(String offloadTypeValue)
            throws JNCException {
        setOffloadTypeValue(new YangString(offloadTypeValue));
    }

    /**
     * Unsets the value for child leaf "offload-type".
     */
    public void unsetOffloadTypeValue() throws JNCException {
        delete("offload-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "offload-type" leaf will not have a value.
     */
    public void addOffloadType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "offload-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "offload-type" with operation "replace".
     */
    public void markOffloadTypeReplace() throws JNCException {
        markLeafReplace("offloadType");
    }

    /**
     * Marks the leaf "offload-type" with operation "merge".
     */
    public void markOffloadTypeMerge() throws JNCException {
        markLeafMerge("offloadType");
    }

    /**
     * Marks the leaf "offload-type" with operation "create".
     */
    public void markOffloadTypeCreate() throws JNCException {
        markLeafCreate("offloadType");
    }

    /**
     * Marks the leaf "offload-type" with operation "delete".
     */
    public void markOffloadTypeDelete() throws JNCException {
        markLeafDelete("offloadType");
    }

    /* Access methods for optional leaf child: "target-mme-ip-address". */

    /**
     * Gets the value for child leaf "target-mme-ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getTargetMmeIpAddressValue() throws JNCException {
        return (IpAddress)getValue("target-mme-ip-address");
    }

    /**
     * Sets the value for child leaf "target-mme-ip-address",
     * using a JNC type value.
     * @param targetMmeIpAddressValue The value to set.
     * @param targetMmeIpAddressValue used during instantiation.
     */
    public void setTargetMmeIpAddressValue(IpAddress targetMmeIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "target-mme-ip-address",
            targetMmeIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "target-mme-ip-address",
     * using a String value.
     * @param targetMmeIpAddressValue used during instantiation.
     */
    public void setTargetMmeIpAddressValue(String targetMmeIpAddressValue)
            throws JNCException {
        setTargetMmeIpAddressValue(new IpAddress(targetMmeIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "target-mme-ip-address".
     */
    public void unsetTargetMmeIpAddressValue() throws JNCException {
        delete("target-mme-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "target-mme-ip-address" leaf will not have a value.
     */
    public void addTargetMmeIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "target-mme-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "target-mme-ip-address" with operation "replace".
     */
    public void markTargetMmeIpAddressReplace() throws JNCException {
        markLeafReplace("targetMmeIpAddress");
    }

    /**
     * Marks the leaf "target-mme-ip-address" with operation "merge".
     */
    public void markTargetMmeIpAddressMerge() throws JNCException {
        markLeafMerge("targetMmeIpAddress");
    }

    /**
     * Marks the leaf "target-mme-ip-address" with operation "create".
     */
    public void markTargetMmeIpAddressCreate() throws JNCException {
        markLeafCreate("targetMmeIpAddress");
    }

    /**
     * Marks the leaf "target-mme-ip-address" with operation "delete".
     */
    public void markTargetMmeIpAddressDelete() throws JNCException {
        markLeafDelete("targetMmeIpAddress");
    }

    /* Access methods for optional leaf child: "target-sgsn-ip-address". */

    /**
     * Gets the value for child leaf "target-sgsn-ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getTargetSgsnIpAddressValue() throws JNCException {
        return (IpAddress)getValue("target-sgsn-ip-address");
    }

    /**
     * Sets the value for child leaf "target-sgsn-ip-address",
     * using a JNC type value.
     * @param targetSgsnIpAddressValue The value to set.
     * @param targetSgsnIpAddressValue used during instantiation.
     */
    public void setTargetSgsnIpAddressValue(IpAddress targetSgsnIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "target-sgsn-ip-address",
            targetSgsnIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "target-sgsn-ip-address",
     * using a String value.
     * @param targetSgsnIpAddressValue used during instantiation.
     */
    public void setTargetSgsnIpAddressValue(String targetSgsnIpAddressValue)
            throws JNCException {
        setTargetSgsnIpAddressValue(new IpAddress(targetSgsnIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "target-sgsn-ip-address".
     */
    public void unsetTargetSgsnIpAddressValue() throws JNCException {
        delete("target-sgsn-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "target-sgsn-ip-address" leaf will not have a value.
     */
    public void addTargetSgsnIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "target-sgsn-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "target-sgsn-ip-address" with operation "replace".
     */
    public void markTargetSgsnIpAddressReplace() throws JNCException {
        markLeafReplace("targetSgsnIpAddress");
    }

    /**
     * Marks the leaf "target-sgsn-ip-address" with operation "merge".
     */
    public void markTargetSgsnIpAddressMerge() throws JNCException {
        markLeafMerge("targetSgsnIpAddress");
    }

    /**
     * Marks the leaf "target-sgsn-ip-address" with operation "create".
     */
    public void markTargetSgsnIpAddressCreate() throws JNCException {
        markLeafCreate("targetSgsnIpAddress");
    }

    /**
     * Marks the leaf "target-sgsn-ip-address" with operation "delete".
     */
    public void markTargetSgsnIpAddressDelete() throws JNCException {
        markLeafDelete("targetSgsnIpAddress");
    }

    /* Access methods for optional leaf child: "ue-qty". */

    /**
     * Gets the value for child leaf "ue-qty".
     * @return The value of the leaf.
     */
    public YangUInt32 getUeQtyValue() throws JNCException {
        return (YangUInt32)getValue("ue-qty");
    }

    /**
     * Sets the value for child leaf "ue-qty",
     * using instance of generated typedef class.
     * @param ueQtyValue The value to set.
     * @param ueQtyValue used during instantiation.
     */
    public void setUeQtyValue(YangUInt32 ueQtyValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-qty",
            ueQtyValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ue-qty",
     * using Java primitive values.
     * @param ueQtyValue used during instantiation.
     */
    public void setUeQtyValue(long ueQtyValue) throws JNCException {
        setUeQtyValue(new YangUInt32(ueQtyValue));
    }

    /**
     * Sets the value for child leaf "ue-qty",
     * using a String value.
     * @param ueQtyValue used during instantiation.
     */
    public void setUeQtyValue(String ueQtyValue) throws JNCException {
        setUeQtyValue(new YangUInt32(ueQtyValue));
    }

    /**
     * Unsets the value for child leaf "ue-qty".
     */
    public void unsetUeQtyValue() throws JNCException {
        delete("ue-qty");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ue-qty" leaf will not have a value.
     */
    public void addUeQty() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-qty",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ue-qty" with operation "replace".
     */
    public void markUeQtyReplace() throws JNCException {
        markLeafReplace("ueQty");
    }

    /**
     * Marks the leaf "ue-qty" with operation "merge".
     */
    public void markUeQtyMerge() throws JNCException {
        markLeafMerge("ueQty");
    }

    /**
     * Marks the leaf "ue-qty" with operation "create".
     */
    public void markUeQtyCreate() throws JNCException {
        markLeafCreate("ueQty");
    }

    /**
     * Marks the leaf "ue-qty" with operation "delete".
     */
    public void markUeQtyDelete() throws JNCException {
        markLeafDelete("ueQty");
    }

    /* Access methods for optional leaf child: "ue-state". */

    /**
     * Gets the value for child leaf "ue-state".
     * @return The value of the leaf.
     */
    public YangString getUeStateValue() throws JNCException {
        return (YangString)getValue("ue-state");
    }

    /**
     * Sets the value for child leaf "ue-state",
     * using instance of generated typedef class.
     * @param ueStateValue The value to set.
     * @param ueStateValue used during instantiation.
     */
    public void setUeStateValue(YangString ueStateValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-state",
            ueStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ue-state",
     * using a String value.
     * @param ueStateValue used during instantiation.
     */
    public void setUeStateValue(String ueStateValue) throws JNCException {
        setUeStateValue(new YangString(ueStateValue));
    }

    /**
     * Unsets the value for child leaf "ue-state".
     */
    public void unsetUeStateValue() throws JNCException {
        delete("ue-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ue-state" leaf will not have a value.
     */
    public void addUeState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ue-state" with operation "replace".
     */
    public void markUeStateReplace() throws JNCException {
        markLeafReplace("ueState");
    }

    /**
     * Marks the leaf "ue-state" with operation "merge".
     */
    public void markUeStateMerge() throws JNCException {
        markLeafMerge("ueState");
    }

    /**
     * Marks the leaf "ue-state" with operation "create".
     */
    public void markUeStateCreate() throws JNCException {
        markLeafCreate("ueState");
    }

    /**
     * Marks the leaf "ue-state" with operation "delete".
     */
    public void markUeStateDelete() throws JNCException {
        markLeafDelete("ueState");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
