/* 
 * @(#)Imsi.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.subscriber.mobileContext;
import .hctaEpc.ImeiT;
import .hctaEpc.ImeisvT;
import .hctaEpc.ImsiT;
import .hctaEpc.MsisdnT;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt32;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/subscriber/mobileContext/imsi"
 * <p>
 * See line 1160 in
 * scCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class Imsi extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty Imsi object.
     */
    public Imsi() {
        super(Epc.NAMESPACE, "imsi");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public Imsi clone() {
        return (Imsi)cloneContent(new Imsi());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public Imsi cloneShallow() {
        return (Imsi)cloneShallowContent(new Imsi());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "imsi",
            "msisdn",
            "imei",
            "imeisv",
            "system-type",
            "mm-state",
            "attach-duration",
            "service",
            "unit-id",
            "location",
            "sc-instance",
            "sc-pid",
            "enodeb-name",
            "enodeb-plmn-id",
            "enodeb-id",
            "enodeb-type",
            "enodeb-ip",
            "cell-id",
            "cell-entry-time",
            "nse-id",
            "sd-instance",
            "rnc-id",
            "drx",
            "ciphering-status",
            "ms-network-capability",
            "guti",
            "old-guti",
            "last-known-tai",
            "last-known-eutran-cell-id",
            "nas-algorithms",
            "ue-network-capability",
            "tai-list",
            "csfb-status",
            "ptmsi",
            "rai",
            "paging-proceed-flag",
            "service-area-code",
            "mc-tlli",
            "ready-timer",
            "subscriber-type",
            "ms-classmark2",
            "ms-classmark3",
            "supported-codec",
            "csg-id",
            "cell-access-mode",
            "csg-membership-status",
            "geographical-coordinates",
        };
    }

    /* Access methods for leaf child: "imsi". */

    /**
     * Gets the value for child leaf "imsi".
     * @return The value of the leaf.
     */
    public ImsiT getImsiValue() throws JNCException {
        return (ImsiT)getValue("imsi");
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a JNC type value.
     * @param imsiValue The value to set.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(ImsiT imsiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            imsiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a String value.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(String imsiValue) throws JNCException {
        setImsiValue(new ImsiT(imsiValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imsi" leaf will not have a value.
     */
    public void addImsi() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "msisdn". */

    /**
     * Gets the value for child leaf "msisdn".
     * @return The value of the leaf.
     */
    public MsisdnT getMsisdnValue() throws JNCException {
        return (MsisdnT)getValue("msisdn");
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a JNC type value.
     * @param msisdnValue The value to set.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(MsisdnT msisdnValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            msisdnValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a String value.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(String msisdnValue) throws JNCException {
        setMsisdnValue(new MsisdnT(msisdnValue));
    }

    /**
     * Unsets the value for child leaf "msisdn".
     */
    public void unsetMsisdnValue() throws JNCException {
        delete("msisdn");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "msisdn" leaf will not have a value.
     */
    public void addMsisdn() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "msisdn" with operation "replace".
     */
    public void markMsisdnReplace() throws JNCException {
        markLeafReplace("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "merge".
     */
    public void markMsisdnMerge() throws JNCException {
        markLeafMerge("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "create".
     */
    public void markMsisdnCreate() throws JNCException {
        markLeafCreate("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "delete".
     */
    public void markMsisdnDelete() throws JNCException {
        markLeafDelete("msisdn");
    }

    /* Access methods for optional leaf child: "imei". */

    /**
     * Gets the value for child leaf "imei".
     * @return The value of the leaf.
     */
    public ImeiT getImeiValue() throws JNCException {
        return (ImeiT)getValue("imei");
    }

    /**
     * Sets the value for child leaf "imei",
     * using a JNC type value.
     * @param imeiValue The value to set.
     * @param imeiValue used during instantiation.
     */
    public void setImeiValue(ImeiT imeiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imei",
            imeiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imei",
     * using a String value.
     * @param imeiValue used during instantiation.
     */
    public void setImeiValue(String imeiValue) throws JNCException {
        setImeiValue(new ImeiT(imeiValue));
    }

    /**
     * Unsets the value for child leaf "imei".
     */
    public void unsetImeiValue() throws JNCException {
        delete("imei");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imei" leaf will not have a value.
     */
    public void addImei() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imei",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "imei" with operation "replace".
     */
    public void markImeiReplace() throws JNCException {
        markLeafReplace("imei");
    }

    /**
     * Marks the leaf "imei" with operation "merge".
     */
    public void markImeiMerge() throws JNCException {
        markLeafMerge("imei");
    }

    /**
     * Marks the leaf "imei" with operation "create".
     */
    public void markImeiCreate() throws JNCException {
        markLeafCreate("imei");
    }

    /**
     * Marks the leaf "imei" with operation "delete".
     */
    public void markImeiDelete() throws JNCException {
        markLeafDelete("imei");
    }

    /* Access methods for optional leaf child: "imeisv". */

    /**
     * Gets the value for child leaf "imeisv".
     * @return The value of the leaf.
     */
    public ImeisvT getImeisvValue() throws JNCException {
        return (ImeisvT)getValue("imeisv");
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a JNC type value.
     * @param imeisvValue The value to set.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(ImeisvT imeisvValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            imeisvValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a String value.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(String imeisvValue) throws JNCException {
        setImeisvValue(new ImeisvT(imeisvValue));
    }

    /**
     * Unsets the value for child leaf "imeisv".
     */
    public void unsetImeisvValue() throws JNCException {
        delete("imeisv");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imeisv" leaf will not have a value.
     */
    public void addImeisv() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "imeisv" with operation "replace".
     */
    public void markImeisvReplace() throws JNCException {
        markLeafReplace("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "merge".
     */
    public void markImeisvMerge() throws JNCException {
        markLeafMerge("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "create".
     */
    public void markImeisvCreate() throws JNCException {
        markLeafCreate("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "delete".
     */
    public void markImeisvDelete() throws JNCException {
        markLeafDelete("imeisv");
    }

    /* Access methods for optional leaf child: "system-type". */

    /**
     * Gets the value for child leaf "system-type".
     * @return The value of the leaf.
     */
    public YangString getSystemTypeValue() throws JNCException {
        return (YangString)getValue("system-type");
    }

    /**
     * Sets the value for child leaf "system-type",
     * using instance of generated typedef class.
     * @param systemTypeValue The value to set.
     * @param systemTypeValue used during instantiation.
     */
    public void setSystemTypeValue(YangString systemTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "system-type",
            systemTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "system-type",
     * using a String value.
     * @param systemTypeValue used during instantiation.
     */
    public void setSystemTypeValue(String systemTypeValue) throws JNCException {
        setSystemTypeValue(new YangString(systemTypeValue));
    }

    /**
     * Unsets the value for child leaf "system-type".
     */
    public void unsetSystemTypeValue() throws JNCException {
        delete("system-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "system-type" leaf will not have a value.
     */
    public void addSystemType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "system-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "system-type" with operation "replace".
     */
    public void markSystemTypeReplace() throws JNCException {
        markLeafReplace("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "merge".
     */
    public void markSystemTypeMerge() throws JNCException {
        markLeafMerge("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "create".
     */
    public void markSystemTypeCreate() throws JNCException {
        markLeafCreate("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "delete".
     */
    public void markSystemTypeDelete() throws JNCException {
        markLeafDelete("systemType");
    }

    /* Access methods for optional leaf child: "mm-state". */

    /**
     * Gets the value for child leaf "mm-state".
     * @return The value of the leaf.
     */
    public YangString getMmStateValue() throws JNCException {
        return (YangString)getValue("mm-state");
    }

    /**
     * Sets the value for child leaf "mm-state",
     * using instance of generated typedef class.
     * @param mmStateValue The value to set.
     * @param mmStateValue used during instantiation.
     */
    public void setMmStateValue(YangString mmStateValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-state",
            mmStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mm-state",
     * using a String value.
     * @param mmStateValue used during instantiation.
     */
    public void setMmStateValue(String mmStateValue) throws JNCException {
        setMmStateValue(new YangString(mmStateValue));
    }

    /**
     * Unsets the value for child leaf "mm-state".
     */
    public void unsetMmStateValue() throws JNCException {
        delete("mm-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mm-state" leaf will not have a value.
     */
    public void addMmState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mm-state" with operation "replace".
     */
    public void markMmStateReplace() throws JNCException {
        markLeafReplace("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "merge".
     */
    public void markMmStateMerge() throws JNCException {
        markLeafMerge("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "create".
     */
    public void markMmStateCreate() throws JNCException {
        markLeafCreate("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "delete".
     */
    public void markMmStateDelete() throws JNCException {
        markLeafDelete("mmState");
    }

    /* Access methods for optional leaf child: "attach-duration". */

    /**
     * Gets the value for child leaf "attach-duration".
     * @return The value of the leaf.
     */
    public YangUInt32 getAttachDurationValue() throws JNCException {
        return (YangUInt32)getValue("attach-duration");
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using instance of generated typedef class.
     * @param attachDurationValue The value to set.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(YangUInt32 attachDurationValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "attach-duration",
            attachDurationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using Java primitive values.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(long attachDurationValue)
            throws JNCException {
        setAttachDurationValue(new YangUInt32(attachDurationValue));
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using a String value.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(String attachDurationValue)
            throws JNCException {
        setAttachDurationValue(new YangUInt32(attachDurationValue));
    }

    /**
     * Unsets the value for child leaf "attach-duration".
     */
    public void unsetAttachDurationValue() throws JNCException {
        delete("attach-duration");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "attach-duration" leaf will not have a value.
     */
    public void addAttachDuration() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "attach-duration",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "attach-duration" with operation "replace".
     */
    public void markAttachDurationReplace() throws JNCException {
        markLeafReplace("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "merge".
     */
    public void markAttachDurationMerge() throws JNCException {
        markLeafMerge("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "create".
     */
    public void markAttachDurationCreate() throws JNCException {
        markLeafCreate("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "delete".
     */
    public void markAttachDurationDelete() throws JNCException {
        markLeafDelete("attachDuration");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "unit-id". */

    /**
     * Gets the value for child leaf "unit-id".
     * @return The value of the leaf.
     */
    public YangUInt8 getUnitIdValue() throws JNCException {
        return (YangUInt8)getValue("unit-id");
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using instance of generated typedef class.
     * @param unitIdValue The value to set.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(YangUInt8 unitIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unit-id",
            unitIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using Java primitive values.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(short unitIdValue) throws JNCException {
        setUnitIdValue(new YangUInt8(unitIdValue));
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using a String value.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(String unitIdValue) throws JNCException {
        setUnitIdValue(new YangUInt8(unitIdValue));
    }

    /**
     * Unsets the value for child leaf "unit-id".
     */
    public void unsetUnitIdValue() throws JNCException {
        delete("unit-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "unit-id" leaf will not have a value.
     */
    public void addUnitId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unit-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "unit-id" with operation "replace".
     */
    public void markUnitIdReplace() throws JNCException {
        markLeafReplace("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "merge".
     */
    public void markUnitIdMerge() throws JNCException {
        markLeafMerge("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "create".
     */
    public void markUnitIdCreate() throws JNCException {
        markLeafCreate("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "delete".
     */
    public void markUnitIdDelete() throws JNCException {
        markLeafDelete("unitId");
    }

    /* Access methods for optional leaf child: "location". */

    /**
     * Gets the value for child leaf "location".
     * @return The value of the leaf.
     */
    public YangString getLocationValue() throws JNCException {
        return (YangString)getValue("location");
    }

    /**
     * Sets the value for child leaf "location",
     * using instance of generated typedef class.
     * @param locationValue The value to set.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(YangString locationValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            locationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location",
     * using a String value.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(String locationValue) throws JNCException {
        setLocationValue(new YangString(locationValue));
    }

    /**
     * Unsets the value for child leaf "location".
     */
    public void unsetLocationValue() throws JNCException {
        delete("location");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location" leaf will not have a value.
     */
    public void addLocation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location" with operation "replace".
     */
    public void markLocationReplace() throws JNCException {
        markLeafReplace("location");
    }

    /**
     * Marks the leaf "location" with operation "merge".
     */
    public void markLocationMerge() throws JNCException {
        markLeafMerge("location");
    }

    /**
     * Marks the leaf "location" with operation "create".
     */
    public void markLocationCreate() throws JNCException {
        markLeafCreate("location");
    }

    /**
     * Marks the leaf "location" with operation "delete".
     */
    public void markLocationDelete() throws JNCException {
        markLeafDelete("location");
    }

    /* Access methods for optional leaf child: "sc-instance". */

    /**
     * Gets the value for child leaf "sc-instance".
     * @return The value of the leaf.
     */
    public YangUInt16 getScInstanceValue() throws JNCException {
        return (YangUInt16)getValue("sc-instance");
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using instance of generated typedef class.
     * @param scInstanceValue The value to set.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(YangUInt16 scInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-instance",
            scInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using Java primitive values.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(int scInstanceValue) throws JNCException {
        setScInstanceValue(new YangUInt16(scInstanceValue));
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using a String value.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(String scInstanceValue) throws JNCException {
        setScInstanceValue(new YangUInt16(scInstanceValue));
    }

    /**
     * Unsets the value for child leaf "sc-instance".
     */
    public void unsetScInstanceValue() throws JNCException {
        delete("sc-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sc-instance" leaf will not have a value.
     */
    public void addScInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sc-instance" with operation "replace".
     */
    public void markScInstanceReplace() throws JNCException {
        markLeafReplace("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "merge".
     */
    public void markScInstanceMerge() throws JNCException {
        markLeafMerge("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "create".
     */
    public void markScInstanceCreate() throws JNCException {
        markLeafCreate("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "delete".
     */
    public void markScInstanceDelete() throws JNCException {
        markLeafDelete("scInstance");
    }

    /* Access methods for optional leaf child: "sc-pid". */

    /**
     * Gets the value for child leaf "sc-pid".
     * @return The value of the leaf.
     */
    public YangUInt32 getScPidValue() throws JNCException {
        return (YangUInt32)getValue("sc-pid");
    }

    /**
     * Sets the value for child leaf "sc-pid",
     * using instance of generated typedef class.
     * @param scPidValue The value to set.
     * @param scPidValue used during instantiation.
     */
    public void setScPidValue(YangUInt32 scPidValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-pid",
            scPidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sc-pid",
     * using Java primitive values.
     * @param scPidValue used during instantiation.
     */
    public void setScPidValue(long scPidValue) throws JNCException {
        setScPidValue(new YangUInt32(scPidValue));
    }

    /**
     * Sets the value for child leaf "sc-pid",
     * using a String value.
     * @param scPidValue used during instantiation.
     */
    public void setScPidValue(String scPidValue) throws JNCException {
        setScPidValue(new YangUInt32(scPidValue));
    }

    /**
     * Unsets the value for child leaf "sc-pid".
     */
    public void unsetScPidValue() throws JNCException {
        delete("sc-pid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sc-pid" leaf will not have a value.
     */
    public void addScPid() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-pid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sc-pid" with operation "replace".
     */
    public void markScPidReplace() throws JNCException {
        markLeafReplace("scPid");
    }

    /**
     * Marks the leaf "sc-pid" with operation "merge".
     */
    public void markScPidMerge() throws JNCException {
        markLeafMerge("scPid");
    }

    /**
     * Marks the leaf "sc-pid" with operation "create".
     */
    public void markScPidCreate() throws JNCException {
        markLeafCreate("scPid");
    }

    /**
     * Marks the leaf "sc-pid" with operation "delete".
     */
    public void markScPidDelete() throws JNCException {
        markLeafDelete("scPid");
    }

    /* Access methods for optional leaf child: "enodeb-name". */

    /**
     * Gets the value for child leaf "enodeb-name".
     * @return The value of the leaf.
     */
    public YangString getEnodebNameValue() throws JNCException {
        return (YangString)getValue("enodeb-name");
    }

    /**
     * Sets the value for child leaf "enodeb-name",
     * using instance of generated typedef class.
     * @param enodebNameValue The value to set.
     * @param enodebNameValue used during instantiation.
     */
    public void setEnodebNameValue(YangString enodebNameValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-name",
            enodebNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-name",
     * using a String value.
     * @param enodebNameValue used during instantiation.
     */
    public void setEnodebNameValue(String enodebNameValue) throws JNCException {
        setEnodebNameValue(new YangString(enodebNameValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-name".
     */
    public void unsetEnodebNameValue() throws JNCException {
        delete("enodeb-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-name" leaf will not have a value.
     */
    public void addEnodebName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-name" with operation "replace".
     */
    public void markEnodebNameReplace() throws JNCException {
        markLeafReplace("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "merge".
     */
    public void markEnodebNameMerge() throws JNCException {
        markLeafMerge("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "create".
     */
    public void markEnodebNameCreate() throws JNCException {
        markLeafCreate("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "delete".
     */
    public void markEnodebNameDelete() throws JNCException {
        markLeafDelete("enodebName");
    }

    /* Access methods for optional leaf child: "enodeb-plmn-id". */

    /**
     * Gets the value for child leaf "enodeb-plmn-id".
     * @return The value of the leaf.
     */
    public YangString getEnodebPlmnIdValue() throws JNCException {
        return (YangString)getValue("enodeb-plmn-id");
    }

    /**
     * Sets the value for child leaf "enodeb-plmn-id",
     * using instance of generated typedef class.
     * @param enodebPlmnIdValue The value to set.
     * @param enodebPlmnIdValue used during instantiation.
     */
    public void setEnodebPlmnIdValue(YangString enodebPlmnIdValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-plmn-id",
            enodebPlmnIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-plmn-id",
     * using a String value.
     * @param enodebPlmnIdValue used during instantiation.
     */
    public void setEnodebPlmnIdValue(String enodebPlmnIdValue)
            throws JNCException {
        setEnodebPlmnIdValue(new YangString(enodebPlmnIdValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-plmn-id".
     */
    public void unsetEnodebPlmnIdValue() throws JNCException {
        delete("enodeb-plmn-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-plmn-id" leaf will not have a value.
     */
    public void addEnodebPlmnId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-plmn-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-plmn-id" with operation "replace".
     */
    public void markEnodebPlmnIdReplace() throws JNCException {
        markLeafReplace("enodebPlmnId");
    }

    /**
     * Marks the leaf "enodeb-plmn-id" with operation "merge".
     */
    public void markEnodebPlmnIdMerge() throws JNCException {
        markLeafMerge("enodebPlmnId");
    }

    /**
     * Marks the leaf "enodeb-plmn-id" with operation "create".
     */
    public void markEnodebPlmnIdCreate() throws JNCException {
        markLeafCreate("enodebPlmnId");
    }

    /**
     * Marks the leaf "enodeb-plmn-id" with operation "delete".
     */
    public void markEnodebPlmnIdDelete() throws JNCException {
        markLeafDelete("enodebPlmnId");
    }

    /* Access methods for optional leaf child: "enodeb-id". */

    /**
     * Gets the value for child leaf "enodeb-id".
     * @return The value of the leaf.
     */
    public YangUInt32 getEnodebIdValue() throws JNCException {
        return (YangUInt32)getValue("enodeb-id");
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using instance of generated typedef class.
     * @param enodebIdValue The value to set.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(YangUInt32 enodebIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-id",
            enodebIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using Java primitive values.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(long enodebIdValue) throws JNCException {
        setEnodebIdValue(new YangUInt32(enodebIdValue));
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using a String value.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(String enodebIdValue) throws JNCException {
        setEnodebIdValue(new YangUInt32(enodebIdValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-id".
     */
    public void unsetEnodebIdValue() throws JNCException {
        delete("enodeb-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-id" leaf will not have a value.
     */
    public void addEnodebId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-id" with operation "replace".
     */
    public void markEnodebIdReplace() throws JNCException {
        markLeafReplace("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "merge".
     */
    public void markEnodebIdMerge() throws JNCException {
        markLeafMerge("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "create".
     */
    public void markEnodebIdCreate() throws JNCException {
        markLeafCreate("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "delete".
     */
    public void markEnodebIdDelete() throws JNCException {
        markLeafDelete("enodebId");
    }

    /* Access methods for optional leaf child: "enodeb-type". */

    /**
     * Gets the value for child leaf "enodeb-type".
     * @return The value of the leaf.
     */
    public YangString getEnodebTypeValue() throws JNCException {
        return (YangString)getValue("enodeb-type");
    }

    /**
     * Sets the value for child leaf "enodeb-type",
     * using instance of generated typedef class.
     * @param enodebTypeValue The value to set.
     * @param enodebTypeValue used during instantiation.
     */
    public void setEnodebTypeValue(YangString enodebTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-type",
            enodebTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-type",
     * using a String value.
     * @param enodebTypeValue used during instantiation.
     */
    public void setEnodebTypeValue(String enodebTypeValue) throws JNCException {
        setEnodebTypeValue(new YangString(enodebTypeValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-type".
     */
    public void unsetEnodebTypeValue() throws JNCException {
        delete("enodeb-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-type" leaf will not have a value.
     */
    public void addEnodebType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-type" with operation "replace".
     */
    public void markEnodebTypeReplace() throws JNCException {
        markLeafReplace("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "merge".
     */
    public void markEnodebTypeMerge() throws JNCException {
        markLeafMerge("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "create".
     */
    public void markEnodebTypeCreate() throws JNCException {
        markLeafCreate("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "delete".
     */
    public void markEnodebTypeDelete() throws JNCException {
        markLeafDelete("enodebType");
    }

    /* Access methods for optional leaf child: "enodeb-ip". */

    /**
     * Gets the value for child leaf "enodeb-ip".
     * @return The value of the leaf.
     */
    public IpAddress getEnodebIpValue() throws JNCException {
        return (IpAddress)getValue("enodeb-ip");
    }

    /**
     * Sets the value for child leaf "enodeb-ip",
     * using a JNC type value.
     * @param enodebIpValue The value to set.
     * @param enodebIpValue used during instantiation.
     */
    public void setEnodebIpValue(IpAddress enodebIpValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-ip",
            enodebIpValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-ip",
     * using a String value.
     * @param enodebIpValue used during instantiation.
     */
    public void setEnodebIpValue(String enodebIpValue) throws JNCException {
        setEnodebIpValue(new IpAddress(enodebIpValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-ip".
     */
    public void unsetEnodebIpValue() throws JNCException {
        delete("enodeb-ip");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-ip" leaf will not have a value.
     */
    public void addEnodebIp() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-ip",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-ip" with operation "replace".
     */
    public void markEnodebIpReplace() throws JNCException {
        markLeafReplace("enodebIp");
    }

    /**
     * Marks the leaf "enodeb-ip" with operation "merge".
     */
    public void markEnodebIpMerge() throws JNCException {
        markLeafMerge("enodebIp");
    }

    /**
     * Marks the leaf "enodeb-ip" with operation "create".
     */
    public void markEnodebIpCreate() throws JNCException {
        markLeafCreate("enodebIp");
    }

    /**
     * Marks the leaf "enodeb-ip" with operation "delete".
     */
    public void markEnodebIpDelete() throws JNCException {
        markLeafDelete("enodebIp");
    }

    /* Access methods for optional leaf child: "cell-id". */

    /**
     * Gets the value for child leaf "cell-id".
     * @return The value of the leaf.
     */
    public YangString getCellIdValue() throws JNCException {
        return (YangString)getValue("cell-id");
    }

    /**
     * Sets the value for child leaf "cell-id",
     * using instance of generated typedef class.
     * @param cellIdValue The value to set.
     * @param cellIdValue used during instantiation.
     */
    public void setCellIdValue(YangString cellIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-id",
            cellIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cell-id",
     * using a String value.
     * @param cellIdValue used during instantiation.
     */
    public void setCellIdValue(String cellIdValue) throws JNCException {
        setCellIdValue(new YangString(cellIdValue));
    }

    /**
     * Unsets the value for child leaf "cell-id".
     */
    public void unsetCellIdValue() throws JNCException {
        delete("cell-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cell-id" leaf will not have a value.
     */
    public void addCellId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cell-id" with operation "replace".
     */
    public void markCellIdReplace() throws JNCException {
        markLeafReplace("cellId");
    }

    /**
     * Marks the leaf "cell-id" with operation "merge".
     */
    public void markCellIdMerge() throws JNCException {
        markLeafMerge("cellId");
    }

    /**
     * Marks the leaf "cell-id" with operation "create".
     */
    public void markCellIdCreate() throws JNCException {
        markLeafCreate("cellId");
    }

    /**
     * Marks the leaf "cell-id" with operation "delete".
     */
    public void markCellIdDelete() throws JNCException {
        markLeafDelete("cellId");
    }

    /* Access methods for optional leaf child: "cell-entry-time". */

    /**
     * Gets the value for child leaf "cell-entry-time".
     * @return The value of the leaf.
     */
    public YangString getCellEntryTimeValue() throws JNCException {
        return (YangString)getValue("cell-entry-time");
    }

    /**
     * Sets the value for child leaf "cell-entry-time",
     * using instance of generated typedef class.
     * @param cellEntryTimeValue The value to set.
     * @param cellEntryTimeValue used during instantiation.
     */
    public void setCellEntryTimeValue(YangString cellEntryTimeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-entry-time",
            cellEntryTimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cell-entry-time",
     * using a String value.
     * @param cellEntryTimeValue used during instantiation.
     */
    public void setCellEntryTimeValue(String cellEntryTimeValue)
            throws JNCException {
        setCellEntryTimeValue(new YangString(cellEntryTimeValue));
    }

    /**
     * Unsets the value for child leaf "cell-entry-time".
     */
    public void unsetCellEntryTimeValue() throws JNCException {
        delete("cell-entry-time");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cell-entry-time" leaf will not have a value.
     */
    public void addCellEntryTime() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-entry-time",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cell-entry-time" with operation "replace".
     */
    public void markCellEntryTimeReplace() throws JNCException {
        markLeafReplace("cellEntryTime");
    }

    /**
     * Marks the leaf "cell-entry-time" with operation "merge".
     */
    public void markCellEntryTimeMerge() throws JNCException {
        markLeafMerge("cellEntryTime");
    }

    /**
     * Marks the leaf "cell-entry-time" with operation "create".
     */
    public void markCellEntryTimeCreate() throws JNCException {
        markLeafCreate("cellEntryTime");
    }

    /**
     * Marks the leaf "cell-entry-time" with operation "delete".
     */
    public void markCellEntryTimeDelete() throws JNCException {
        markLeafDelete("cellEntryTime");
    }

    /* Access methods for optional leaf child: "nse-id". */

    /**
     * Gets the value for child leaf "nse-id".
     * @return The value of the leaf.
     */
    public YangUInt16 getNseIdValue() throws JNCException {
        return (YangUInt16)getValue("nse-id");
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using instance of generated typedef class.
     * @param nseIdValue The value to set.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(YangUInt16 nseIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nse-id",
            nseIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using Java primitive values.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(int nseIdValue) throws JNCException {
        setNseIdValue(new YangUInt16(nseIdValue));
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using a String value.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(String nseIdValue) throws JNCException {
        setNseIdValue(new YangUInt16(nseIdValue));
    }

    /**
     * Unsets the value for child leaf "nse-id".
     */
    public void unsetNseIdValue() throws JNCException {
        delete("nse-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nse-id" leaf will not have a value.
     */
    public void addNseId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nse-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nse-id" with operation "replace".
     */
    public void markNseIdReplace() throws JNCException {
        markLeafReplace("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "merge".
     */
    public void markNseIdMerge() throws JNCException {
        markLeafMerge("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "create".
     */
    public void markNseIdCreate() throws JNCException {
        markLeafCreate("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "delete".
     */
    public void markNseIdDelete() throws JNCException {
        markLeafDelete("nseId");
    }

    /* Access methods for optional leaf child: "sd-instance". */

    /**
     * Gets the value for child leaf "sd-instance".
     * @return The value of the leaf.
     */
    public YangUInt16 getSdInstanceValue() throws JNCException {
        return (YangUInt16)getValue("sd-instance");
    }

    /**
     * Sets the value for child leaf "sd-instance",
     * using instance of generated typedef class.
     * @param sdInstanceValue The value to set.
     * @param sdInstanceValue used during instantiation.
     */
    public void setSdInstanceValue(YangUInt16 sdInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sd-instance",
            sdInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sd-instance",
     * using Java primitive values.
     * @param sdInstanceValue used during instantiation.
     */
    public void setSdInstanceValue(int sdInstanceValue) throws JNCException {
        setSdInstanceValue(new YangUInt16(sdInstanceValue));
    }

    /**
     * Sets the value for child leaf "sd-instance",
     * using a String value.
     * @param sdInstanceValue used during instantiation.
     */
    public void setSdInstanceValue(String sdInstanceValue) throws JNCException {
        setSdInstanceValue(new YangUInt16(sdInstanceValue));
    }

    /**
     * Unsets the value for child leaf "sd-instance".
     */
    public void unsetSdInstanceValue() throws JNCException {
        delete("sd-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sd-instance" leaf will not have a value.
     */
    public void addSdInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sd-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sd-instance" with operation "replace".
     */
    public void markSdInstanceReplace() throws JNCException {
        markLeafReplace("sdInstance");
    }

    /**
     * Marks the leaf "sd-instance" with operation "merge".
     */
    public void markSdInstanceMerge() throws JNCException {
        markLeafMerge("sdInstance");
    }

    /**
     * Marks the leaf "sd-instance" with operation "create".
     */
    public void markSdInstanceCreate() throws JNCException {
        markLeafCreate("sdInstance");
    }

    /**
     * Marks the leaf "sd-instance" with operation "delete".
     */
    public void markSdInstanceDelete() throws JNCException {
        markLeafDelete("sdInstance");
    }

    /* Access methods for optional leaf child: "rnc-id". */

    /**
     * Gets the value for child leaf "rnc-id".
     * @return The value of the leaf.
     */
    public YangUInt16 getRncIdValue() throws JNCException {
        return (YangUInt16)getValue("rnc-id");
    }

    /**
     * Sets the value for child leaf "rnc-id",
     * using instance of generated typedef class.
     * @param rncIdValue The value to set.
     * @param rncIdValue used during instantiation.
     */
    public void setRncIdValue(YangUInt16 rncIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rnc-id",
            rncIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rnc-id",
     * using Java primitive values.
     * @param rncIdValue used during instantiation.
     */
    public void setRncIdValue(int rncIdValue) throws JNCException {
        setRncIdValue(new YangUInt16(rncIdValue));
    }

    /**
     * Sets the value for child leaf "rnc-id",
     * using a String value.
     * @param rncIdValue used during instantiation.
     */
    public void setRncIdValue(String rncIdValue) throws JNCException {
        setRncIdValue(new YangUInt16(rncIdValue));
    }

    /**
     * Unsets the value for child leaf "rnc-id".
     */
    public void unsetRncIdValue() throws JNCException {
        delete("rnc-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rnc-id" leaf will not have a value.
     */
    public void addRncId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rnc-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rnc-id" with operation "replace".
     */
    public void markRncIdReplace() throws JNCException {
        markLeafReplace("rncId");
    }

    /**
     * Marks the leaf "rnc-id" with operation "merge".
     */
    public void markRncIdMerge() throws JNCException {
        markLeafMerge("rncId");
    }

    /**
     * Marks the leaf "rnc-id" with operation "create".
     */
    public void markRncIdCreate() throws JNCException {
        markLeafCreate("rncId");
    }

    /**
     * Marks the leaf "rnc-id" with operation "delete".
     */
    public void markRncIdDelete() throws JNCException {
        markLeafDelete("rncId");
    }

    /* Access methods for optional leaf child: "drx". */

    /**
     * Gets the value for child leaf "drx".
     * @return The value of the leaf.
     */
    public YangString getDrxValue() throws JNCException {
        return (YangString)getValue("drx");
    }

    /**
     * Sets the value for child leaf "drx",
     * using instance of generated typedef class.
     * @param drxValue The value to set.
     * @param drxValue used during instantiation.
     */
    public void setDrxValue(YangString drxValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "drx",
            drxValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "drx",
     * using a String value.
     * @param drxValue used during instantiation.
     */
    public void setDrxValue(String drxValue) throws JNCException {
        setDrxValue(new YangString(drxValue));
    }

    /**
     * Unsets the value for child leaf "drx".
     */
    public void unsetDrxValue() throws JNCException {
        delete("drx");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "drx" leaf will not have a value.
     */
    public void addDrx() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "drx",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "drx" with operation "replace".
     */
    public void markDrxReplace() throws JNCException {
        markLeafReplace("drx");
    }

    /**
     * Marks the leaf "drx" with operation "merge".
     */
    public void markDrxMerge() throws JNCException {
        markLeafMerge("drx");
    }

    /**
     * Marks the leaf "drx" with operation "create".
     */
    public void markDrxCreate() throws JNCException {
        markLeafCreate("drx");
    }

    /**
     * Marks the leaf "drx" with operation "delete".
     */
    public void markDrxDelete() throws JNCException {
        markLeafDelete("drx");
    }

    /* Access methods for optional leaf child: "ciphering-status". */

    /**
     * Gets the value for child leaf "ciphering-status".
     * @return The value of the leaf.
     */
    public YangString getCipheringStatusValue() throws JNCException {
        return (YangString)getValue("ciphering-status");
    }

    /**
     * Sets the value for child leaf "ciphering-status",
     * using instance of generated typedef class.
     * @param cipheringStatusValue The value to set.
     * @param cipheringStatusValue used during instantiation.
     */
    public void setCipheringStatusValue(YangString cipheringStatusValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ciphering-status",
            cipheringStatusValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ciphering-status",
     * using a String value.
     * @param cipheringStatusValue used during instantiation.
     */
    public void setCipheringStatusValue(String cipheringStatusValue)
            throws JNCException {
        setCipheringStatusValue(new YangString(cipheringStatusValue));
    }

    /**
     * Unsets the value for child leaf "ciphering-status".
     */
    public void unsetCipheringStatusValue() throws JNCException {
        delete("ciphering-status");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ciphering-status" leaf will not have a value.
     */
    public void addCipheringStatus() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ciphering-status",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ciphering-status" with operation "replace".
     */
    public void markCipheringStatusReplace() throws JNCException {
        markLeafReplace("cipheringStatus");
    }

    /**
     * Marks the leaf "ciphering-status" with operation "merge".
     */
    public void markCipheringStatusMerge() throws JNCException {
        markLeafMerge("cipheringStatus");
    }

    /**
     * Marks the leaf "ciphering-status" with operation "create".
     */
    public void markCipheringStatusCreate() throws JNCException {
        markLeafCreate("cipheringStatus");
    }

    /**
     * Marks the leaf "ciphering-status" with operation "delete".
     */
    public void markCipheringStatusDelete() throws JNCException {
        markLeafDelete("cipheringStatus");
    }

    /* Access methods for optional leaf child: "ms-network-capability". */

    /**
     * Gets the value for child leaf "ms-network-capability".
     * @return The value of the leaf.
     */
    public YangString getMsNetworkCapabilityValue() throws JNCException {
        return (YangString)getValue("ms-network-capability");
    }

    /**
     * Sets the value for child leaf "ms-network-capability",
     * using instance of generated typedef class.
     * @param msNetworkCapabilityValue The value to set.
     * @param msNetworkCapabilityValue used during instantiation.
     */
    public void setMsNetworkCapabilityValue(YangString msNetworkCapabilityValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-network-capability",
            msNetworkCapabilityValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ms-network-capability",
     * using a String value.
     * @param msNetworkCapabilityValue used during instantiation.
     */
    public void setMsNetworkCapabilityValue(String msNetworkCapabilityValue)
            throws JNCException {
        setMsNetworkCapabilityValue(new YangString(msNetworkCapabilityValue));
    }

    /**
     * Unsets the value for child leaf "ms-network-capability".
     */
    public void unsetMsNetworkCapabilityValue() throws JNCException {
        delete("ms-network-capability");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ms-network-capability" leaf will not have a value.
     */
    public void addMsNetworkCapability() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-network-capability",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ms-network-capability" with operation "replace".
     */
    public void markMsNetworkCapabilityReplace() throws JNCException {
        markLeafReplace("msNetworkCapability");
    }

    /**
     * Marks the leaf "ms-network-capability" with operation "merge".
     */
    public void markMsNetworkCapabilityMerge() throws JNCException {
        markLeafMerge("msNetworkCapability");
    }

    /**
     * Marks the leaf "ms-network-capability" with operation "create".
     */
    public void markMsNetworkCapabilityCreate() throws JNCException {
        markLeafCreate("msNetworkCapability");
    }

    /**
     * Marks the leaf "ms-network-capability" with operation "delete".
     */
    public void markMsNetworkCapabilityDelete() throws JNCException {
        markLeafDelete("msNetworkCapability");
    }

    /* Access methods for optional leaf child: "guti". */

    /**
     * Gets the value for child leaf "guti".
     * @return The value of the leaf.
     */
    public YangString getGutiValue() throws JNCException {
        return (YangString)getValue("guti");
    }

    /**
     * Sets the value for child leaf "guti",
     * using instance of generated typedef class.
     * @param gutiValue The value to set.
     * @param gutiValue used during instantiation.
     */
    public void setGutiValue(YangString gutiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "guti",
            gutiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "guti",
     * using a String value.
     * @param gutiValue used during instantiation.
     */
    public void setGutiValue(String gutiValue) throws JNCException {
        setGutiValue(new YangString(gutiValue));
    }

    /**
     * Unsets the value for child leaf "guti".
     */
    public void unsetGutiValue() throws JNCException {
        delete("guti");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "guti" leaf will not have a value.
     */
    public void addGuti() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "guti",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "guti" with operation "replace".
     */
    public void markGutiReplace() throws JNCException {
        markLeafReplace("guti");
    }

    /**
     * Marks the leaf "guti" with operation "merge".
     */
    public void markGutiMerge() throws JNCException {
        markLeafMerge("guti");
    }

    /**
     * Marks the leaf "guti" with operation "create".
     */
    public void markGutiCreate() throws JNCException {
        markLeafCreate("guti");
    }

    /**
     * Marks the leaf "guti" with operation "delete".
     */
    public void markGutiDelete() throws JNCException {
        markLeafDelete("guti");
    }

    /* Access methods for optional leaf child: "old-guti". */

    /**
     * Gets the value for child leaf "old-guti".
     * @return The value of the leaf.
     */
    public YangString getOldGutiValue() throws JNCException {
        return (YangString)getValue("old-guti");
    }

    /**
     * Sets the value for child leaf "old-guti",
     * using instance of generated typedef class.
     * @param oldGutiValue The value to set.
     * @param oldGutiValue used during instantiation.
     */
    public void setOldGutiValue(YangString oldGutiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "old-guti",
            oldGutiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "old-guti",
     * using a String value.
     * @param oldGutiValue used during instantiation.
     */
    public void setOldGutiValue(String oldGutiValue) throws JNCException {
        setOldGutiValue(new YangString(oldGutiValue));
    }

    /**
     * Unsets the value for child leaf "old-guti".
     */
    public void unsetOldGutiValue() throws JNCException {
        delete("old-guti");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "old-guti" leaf will not have a value.
     */
    public void addOldGuti() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "old-guti",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "old-guti" with operation "replace".
     */
    public void markOldGutiReplace() throws JNCException {
        markLeafReplace("oldGuti");
    }

    /**
     * Marks the leaf "old-guti" with operation "merge".
     */
    public void markOldGutiMerge() throws JNCException {
        markLeafMerge("oldGuti");
    }

    /**
     * Marks the leaf "old-guti" with operation "create".
     */
    public void markOldGutiCreate() throws JNCException {
        markLeafCreate("oldGuti");
    }

    /**
     * Marks the leaf "old-guti" with operation "delete".
     */
    public void markOldGutiDelete() throws JNCException {
        markLeafDelete("oldGuti");
    }

    /* Access methods for optional leaf child: "last-known-tai". */

    /**
     * Gets the value for child leaf "last-known-tai".
     * @return The value of the leaf.
     */
    public YangString getLastKnownTaiValue() throws JNCException {
        return (YangString)getValue("last-known-tai");
    }

    /**
     * Sets the value for child leaf "last-known-tai",
     * using instance of generated typedef class.
     * @param lastKnownTaiValue The value to set.
     * @param lastKnownTaiValue used during instantiation.
     */
    public void setLastKnownTaiValue(YangString lastKnownTaiValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "last-known-tai",
            lastKnownTaiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "last-known-tai",
     * using a String value.
     * @param lastKnownTaiValue used during instantiation.
     */
    public void setLastKnownTaiValue(String lastKnownTaiValue)
            throws JNCException {
        setLastKnownTaiValue(new YangString(lastKnownTaiValue));
    }

    /**
     * Unsets the value for child leaf "last-known-tai".
     */
    public void unsetLastKnownTaiValue() throws JNCException {
        delete("last-known-tai");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "last-known-tai" leaf will not have a value.
     */
    public void addLastKnownTai() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "last-known-tai",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "last-known-tai" with operation "replace".
     */
    public void markLastKnownTaiReplace() throws JNCException {
        markLeafReplace("lastKnownTai");
    }

    /**
     * Marks the leaf "last-known-tai" with operation "merge".
     */
    public void markLastKnownTaiMerge() throws JNCException {
        markLeafMerge("lastKnownTai");
    }

    /**
     * Marks the leaf "last-known-tai" with operation "create".
     */
    public void markLastKnownTaiCreate() throws JNCException {
        markLeafCreate("lastKnownTai");
    }

    /**
     * Marks the leaf "last-known-tai" with operation "delete".
     */
    public void markLastKnownTaiDelete() throws JNCException {
        markLeafDelete("lastKnownTai");
    }

    /* Access methods for optional leaf child: "last-known-eutran-cell-id". */

    /**
     * Gets the value for child leaf "last-known-eutran-cell-id".
     * @return The value of the leaf.
     */
    public YangString getLastKnownEutranCellIdValue() throws JNCException {
        return (YangString)getValue("last-known-eutran-cell-id");
    }

    /**
     * Sets the value for child leaf "last-known-eutran-cell-id",
     * using instance of generated typedef class.
     * @param lastKnownEutranCellIdValue The value to set.
     * @param lastKnownEutranCellIdValue used during instantiation.
     */
    public void setLastKnownEutranCellIdValue(YangString lastKnownEutranCellIdValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "last-known-eutran-cell-id",
            lastKnownEutranCellIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "last-known-eutran-cell-id",
     * using a String value.
     * @param lastKnownEutranCellIdValue used during instantiation.
     */
    public void setLastKnownEutranCellIdValue(String lastKnownEutranCellIdValue)
            throws JNCException {
        setLastKnownEutranCellIdValue(new YangString(lastKnownEutranCellIdValue));
    }

    /**
     * Unsets the value for child leaf "last-known-eutran-cell-id".
     */
    public void unsetLastKnownEutranCellIdValue() throws JNCException {
        delete("last-known-eutran-cell-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "last-known-eutran-cell-id" leaf will not have a value.
     */
    public void addLastKnownEutranCellId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "last-known-eutran-cell-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "last-known-eutran-cell-id" with operation "replace".
     */
    public void markLastKnownEutranCellIdReplace() throws JNCException {
        markLeafReplace("lastKnownEutranCellId");
    }

    /**
     * Marks the leaf "last-known-eutran-cell-id" with operation "merge".
     */
    public void markLastKnownEutranCellIdMerge() throws JNCException {
        markLeafMerge("lastKnownEutranCellId");
    }

    /**
     * Marks the leaf "last-known-eutran-cell-id" with operation "create".
     */
    public void markLastKnownEutranCellIdCreate() throws JNCException {
        markLeafCreate("lastKnownEutranCellId");
    }

    /**
     * Marks the leaf "last-known-eutran-cell-id" with operation "delete".
     */
    public void markLastKnownEutranCellIdDelete() throws JNCException {
        markLeafDelete("lastKnownEutranCellId");
    }

    /* Access methods for optional leaf child: "nas-algorithms". */

    /**
     * Gets the value for child leaf "nas-algorithms".
     * @return The value of the leaf.
     */
    public YangString getNasAlgorithmsValue() throws JNCException {
        return (YangString)getValue("nas-algorithms");
    }

    /**
     * Sets the value for child leaf "nas-algorithms",
     * using instance of generated typedef class.
     * @param nasAlgorithmsValue The value to set.
     * @param nasAlgorithmsValue used during instantiation.
     */
    public void setNasAlgorithmsValue(YangString nasAlgorithmsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nas-algorithms",
            nasAlgorithmsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nas-algorithms",
     * using a String value.
     * @param nasAlgorithmsValue used during instantiation.
     */
    public void setNasAlgorithmsValue(String nasAlgorithmsValue)
            throws JNCException {
        setNasAlgorithmsValue(new YangString(nasAlgorithmsValue));
    }

    /**
     * Unsets the value for child leaf "nas-algorithms".
     */
    public void unsetNasAlgorithmsValue() throws JNCException {
        delete("nas-algorithms");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nas-algorithms" leaf will not have a value.
     */
    public void addNasAlgorithms() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nas-algorithms",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nas-algorithms" with operation "replace".
     */
    public void markNasAlgorithmsReplace() throws JNCException {
        markLeafReplace("nasAlgorithms");
    }

    /**
     * Marks the leaf "nas-algorithms" with operation "merge".
     */
    public void markNasAlgorithmsMerge() throws JNCException {
        markLeafMerge("nasAlgorithms");
    }

    /**
     * Marks the leaf "nas-algorithms" with operation "create".
     */
    public void markNasAlgorithmsCreate() throws JNCException {
        markLeafCreate("nasAlgorithms");
    }

    /**
     * Marks the leaf "nas-algorithms" with operation "delete".
     */
    public void markNasAlgorithmsDelete() throws JNCException {
        markLeafDelete("nasAlgorithms");
    }

    /* Access methods for optional leaf child: "ue-network-capability". */

    /**
     * Gets the value for child leaf "ue-network-capability".
     * @return The value of the leaf.
     */
    public YangString getUeNetworkCapabilityValue() throws JNCException {
        return (YangString)getValue("ue-network-capability");
    }

    /**
     * Sets the value for child leaf "ue-network-capability",
     * using instance of generated typedef class.
     * @param ueNetworkCapabilityValue The value to set.
     * @param ueNetworkCapabilityValue used during instantiation.
     */
    public void setUeNetworkCapabilityValue(YangString ueNetworkCapabilityValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-network-capability",
            ueNetworkCapabilityValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ue-network-capability",
     * using a String value.
     * @param ueNetworkCapabilityValue used during instantiation.
     */
    public void setUeNetworkCapabilityValue(String ueNetworkCapabilityValue)
            throws JNCException {
        setUeNetworkCapabilityValue(new YangString(ueNetworkCapabilityValue));
    }

    /**
     * Unsets the value for child leaf "ue-network-capability".
     */
    public void unsetUeNetworkCapabilityValue() throws JNCException {
        delete("ue-network-capability");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ue-network-capability" leaf will not have a value.
     */
    public void addUeNetworkCapability() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-network-capability",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ue-network-capability" with operation "replace".
     */
    public void markUeNetworkCapabilityReplace() throws JNCException {
        markLeafReplace("ueNetworkCapability");
    }

    /**
     * Marks the leaf "ue-network-capability" with operation "merge".
     */
    public void markUeNetworkCapabilityMerge() throws JNCException {
        markLeafMerge("ueNetworkCapability");
    }

    /**
     * Marks the leaf "ue-network-capability" with operation "create".
     */
    public void markUeNetworkCapabilityCreate() throws JNCException {
        markLeafCreate("ueNetworkCapability");
    }

    /**
     * Marks the leaf "ue-network-capability" with operation "delete".
     */
    public void markUeNetworkCapabilityDelete() throws JNCException {
        markLeafDelete("ueNetworkCapability");
    }

    /* Access methods for optional leaf child: "tai-list". */

    /**
     * Gets the value for child leaf "tai-list".
     * @return The value of the leaf.
     */
    public YangString getTaiListValue() throws JNCException {
        return (YangString)getValue("tai-list");
    }

    /**
     * Sets the value for child leaf "tai-list",
     * using instance of generated typedef class.
     * @param taiListValue The value to set.
     * @param taiListValue used during instantiation.
     */
    public void setTaiListValue(YangString taiListValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "tai-list",
            taiListValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "tai-list",
     * using a String value.
     * @param taiListValue used during instantiation.
     */
    public void setTaiListValue(String taiListValue) throws JNCException {
        setTaiListValue(new YangString(taiListValue));
    }

    /**
     * Unsets the value for child leaf "tai-list".
     */
    public void unsetTaiListValue() throws JNCException {
        delete("tai-list");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "tai-list" leaf will not have a value.
     */
    public void addTaiList() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "tai-list",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "tai-list" with operation "replace".
     */
    public void markTaiListReplace() throws JNCException {
        markLeafReplace("taiList");
    }

    /**
     * Marks the leaf "tai-list" with operation "merge".
     */
    public void markTaiListMerge() throws JNCException {
        markLeafMerge("taiList");
    }

    /**
     * Marks the leaf "tai-list" with operation "create".
     */
    public void markTaiListCreate() throws JNCException {
        markLeafCreate("taiList");
    }

    /**
     * Marks the leaf "tai-list" with operation "delete".
     */
    public void markTaiListDelete() throws JNCException {
        markLeafDelete("taiList");
    }

    /* Access methods for optional leaf child: "csfb-status". */

    /**
     * Gets the value for child leaf "csfb-status".
     * @return The value of the leaf.
     */
    public YangString getCsfbStatusValue() throws JNCException {
        return (YangString)getValue("csfb-status");
    }

    /**
     * Sets the value for child leaf "csfb-status",
     * using instance of generated typedef class.
     * @param csfbStatusValue The value to set.
     * @param csfbStatusValue used during instantiation.
     */
    public void setCsfbStatusValue(YangString csfbStatusValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csfb-status",
            csfbStatusValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csfb-status",
     * using a String value.
     * @param csfbStatusValue used during instantiation.
     */
    public void setCsfbStatusValue(String csfbStatusValue) throws JNCException {
        setCsfbStatusValue(new YangString(csfbStatusValue));
    }

    /**
     * Unsets the value for child leaf "csfb-status".
     */
    public void unsetCsfbStatusValue() throws JNCException {
        delete("csfb-status");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csfb-status" leaf will not have a value.
     */
    public void addCsfbStatus() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csfb-status",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csfb-status" with operation "replace".
     */
    public void markCsfbStatusReplace() throws JNCException {
        markLeafReplace("csfbStatus");
    }

    /**
     * Marks the leaf "csfb-status" with operation "merge".
     */
    public void markCsfbStatusMerge() throws JNCException {
        markLeafMerge("csfbStatus");
    }

    /**
     * Marks the leaf "csfb-status" with operation "create".
     */
    public void markCsfbStatusCreate() throws JNCException {
        markLeafCreate("csfbStatus");
    }

    /**
     * Marks the leaf "csfb-status" with operation "delete".
     */
    public void markCsfbStatusDelete() throws JNCException {
        markLeafDelete("csfbStatus");
    }

    /* Access methods for optional leaf child: "ptmsi". */

    /**
     * Gets the value for child leaf "ptmsi".
     * @return The value of the leaf.
     */
    public YangString getPtmsiValue() throws JNCException {
        return (YangString)getValue("ptmsi");
    }

    /**
     * Sets the value for child leaf "ptmsi",
     * using instance of generated typedef class.
     * @param ptmsiValue The value to set.
     * @param ptmsiValue used during instantiation.
     */
    public void setPtmsiValue(YangString ptmsiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ptmsi",
            ptmsiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ptmsi",
     * using a String value.
     * @param ptmsiValue used during instantiation.
     */
    public void setPtmsiValue(String ptmsiValue) throws JNCException {
        setPtmsiValue(new YangString(ptmsiValue));
    }

    /**
     * Unsets the value for child leaf "ptmsi".
     */
    public void unsetPtmsiValue() throws JNCException {
        delete("ptmsi");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ptmsi" leaf will not have a value.
     */
    public void addPtmsi() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ptmsi",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ptmsi" with operation "replace".
     */
    public void markPtmsiReplace() throws JNCException {
        markLeafReplace("ptmsi");
    }

    /**
     * Marks the leaf "ptmsi" with operation "merge".
     */
    public void markPtmsiMerge() throws JNCException {
        markLeafMerge("ptmsi");
    }

    /**
     * Marks the leaf "ptmsi" with operation "create".
     */
    public void markPtmsiCreate() throws JNCException {
        markLeafCreate("ptmsi");
    }

    /**
     * Marks the leaf "ptmsi" with operation "delete".
     */
    public void markPtmsiDelete() throws JNCException {
        markLeafDelete("ptmsi");
    }

    /* Access methods for optional leaf child: "rai". */

    /**
     * Gets the value for child leaf "rai".
     * @return The value of the leaf.
     */
    public YangString getRaiValue() throws JNCException {
        return (YangString)getValue("rai");
    }

    /**
     * Sets the value for child leaf "rai",
     * using instance of generated typedef class.
     * @param raiValue The value to set.
     * @param raiValue used during instantiation.
     */
    public void setRaiValue(YangString raiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rai",
            raiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rai",
     * using a String value.
     * @param raiValue used during instantiation.
     */
    public void setRaiValue(String raiValue) throws JNCException {
        setRaiValue(new YangString(raiValue));
    }

    /**
     * Unsets the value for child leaf "rai".
     */
    public void unsetRaiValue() throws JNCException {
        delete("rai");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rai" leaf will not have a value.
     */
    public void addRai() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rai",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rai" with operation "replace".
     */
    public void markRaiReplace() throws JNCException {
        markLeafReplace("rai");
    }

    /**
     * Marks the leaf "rai" with operation "merge".
     */
    public void markRaiMerge() throws JNCException {
        markLeafMerge("rai");
    }

    /**
     * Marks the leaf "rai" with operation "create".
     */
    public void markRaiCreate() throws JNCException {
        markLeafCreate("rai");
    }

    /**
     * Marks the leaf "rai" with operation "delete".
     */
    public void markRaiDelete() throws JNCException {
        markLeafDelete("rai");
    }

    /* Access methods for optional leaf child: "paging-proceed-flag". */

    /**
     * Gets the value for child leaf "paging-proceed-flag".
     * @return The value of the leaf.
     */
    public YangString getPagingProceedFlagValue() throws JNCException {
        return (YangString)getValue("paging-proceed-flag");
    }

    /**
     * Sets the value for child leaf "paging-proceed-flag",
     * using instance of generated typedef class.
     * @param pagingProceedFlagValue The value to set.
     * @param pagingProceedFlagValue used during instantiation.
     */
    public void setPagingProceedFlagValue(YangString pagingProceedFlagValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "paging-proceed-flag",
            pagingProceedFlagValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "paging-proceed-flag",
     * using a String value.
     * @param pagingProceedFlagValue used during instantiation.
     */
    public void setPagingProceedFlagValue(String pagingProceedFlagValue)
            throws JNCException {
        setPagingProceedFlagValue(new YangString(pagingProceedFlagValue));
    }

    /**
     * Unsets the value for child leaf "paging-proceed-flag".
     */
    public void unsetPagingProceedFlagValue() throws JNCException {
        delete("paging-proceed-flag");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "paging-proceed-flag" leaf will not have a value.
     */
    public void addPagingProceedFlag() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "paging-proceed-flag",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "paging-proceed-flag" with operation "replace".
     */
    public void markPagingProceedFlagReplace() throws JNCException {
        markLeafReplace("pagingProceedFlag");
    }

    /**
     * Marks the leaf "paging-proceed-flag" with operation "merge".
     */
    public void markPagingProceedFlagMerge() throws JNCException {
        markLeafMerge("pagingProceedFlag");
    }

    /**
     * Marks the leaf "paging-proceed-flag" with operation "create".
     */
    public void markPagingProceedFlagCreate() throws JNCException {
        markLeafCreate("pagingProceedFlag");
    }

    /**
     * Marks the leaf "paging-proceed-flag" with operation "delete".
     */
    public void markPagingProceedFlagDelete() throws JNCException {
        markLeafDelete("pagingProceedFlag");
    }

    /* Access methods for optional leaf child: "service-area-code". */

    /**
     * Gets the value for child leaf "service-area-code".
     * @return The value of the leaf.
     */
    public YangString getServiceAreaCodeValue() throws JNCException {
        return (YangString)getValue("service-area-code");
    }

    /**
     * Sets the value for child leaf "service-area-code",
     * using instance of generated typedef class.
     * @param serviceAreaCodeValue The value to set.
     * @param serviceAreaCodeValue used during instantiation.
     */
    public void setServiceAreaCodeValue(YangString serviceAreaCodeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service-area-code",
            serviceAreaCodeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service-area-code",
     * using a String value.
     * @param serviceAreaCodeValue used during instantiation.
     */
    public void setServiceAreaCodeValue(String serviceAreaCodeValue)
            throws JNCException {
        setServiceAreaCodeValue(new YangString(serviceAreaCodeValue));
    }

    /**
     * Unsets the value for child leaf "service-area-code".
     */
    public void unsetServiceAreaCodeValue() throws JNCException {
        delete("service-area-code");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service-area-code" leaf will not have a value.
     */
    public void addServiceAreaCode() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service-area-code",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service-area-code" with operation "replace".
     */
    public void markServiceAreaCodeReplace() throws JNCException {
        markLeafReplace("serviceAreaCode");
    }

    /**
     * Marks the leaf "service-area-code" with operation "merge".
     */
    public void markServiceAreaCodeMerge() throws JNCException {
        markLeafMerge("serviceAreaCode");
    }

    /**
     * Marks the leaf "service-area-code" with operation "create".
     */
    public void markServiceAreaCodeCreate() throws JNCException {
        markLeafCreate("serviceAreaCode");
    }

    /**
     * Marks the leaf "service-area-code" with operation "delete".
     */
    public void markServiceAreaCodeDelete() throws JNCException {
        markLeafDelete("serviceAreaCode");
    }

    /* Access methods for optional leaf child: "mc-tlli". */

    /**
     * Gets the value for child leaf "mc-tlli".
     * @return The value of the leaf.
     */
    public YangString getMcTlliValue() throws JNCException {
        return (YangString)getValue("mc-tlli");
    }

    /**
     * Sets the value for child leaf "mc-tlli",
     * using instance of generated typedef class.
     * @param mcTlliValue The value to set.
     * @param mcTlliValue used during instantiation.
     */
    public void setMcTlliValue(YangString mcTlliValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mc-tlli",
            mcTlliValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mc-tlli",
     * using a String value.
     * @param mcTlliValue used during instantiation.
     */
    public void setMcTlliValue(String mcTlliValue) throws JNCException {
        setMcTlliValue(new YangString(mcTlliValue));
    }

    /**
     * Unsets the value for child leaf "mc-tlli".
     */
    public void unsetMcTlliValue() throws JNCException {
        delete("mc-tlli");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mc-tlli" leaf will not have a value.
     */
    public void addMcTlli() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mc-tlli",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mc-tlli" with operation "replace".
     */
    public void markMcTlliReplace() throws JNCException {
        markLeafReplace("mcTlli");
    }

    /**
     * Marks the leaf "mc-tlli" with operation "merge".
     */
    public void markMcTlliMerge() throws JNCException {
        markLeafMerge("mcTlli");
    }

    /**
     * Marks the leaf "mc-tlli" with operation "create".
     */
    public void markMcTlliCreate() throws JNCException {
        markLeafCreate("mcTlli");
    }

    /**
     * Marks the leaf "mc-tlli" with operation "delete".
     */
    public void markMcTlliDelete() throws JNCException {
        markLeafDelete("mcTlli");
    }

    /* Access methods for optional leaf child: "ready-timer". */

    /**
     * Gets the value for child leaf "ready-timer".
     * @return The value of the leaf.
     */
    public YangUInt32 getReadyTimerValue() throws JNCException {
        return (YangUInt32)getValue("ready-timer");
    }

    /**
     * Sets the value for child leaf "ready-timer",
     * using instance of generated typedef class.
     * @param readyTimerValue The value to set.
     * @param readyTimerValue used during instantiation.
     */
    public void setReadyTimerValue(YangUInt32 readyTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ready-timer",
            readyTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ready-timer",
     * using Java primitive values.
     * @param readyTimerValue used during instantiation.
     */
    public void setReadyTimerValue(long readyTimerValue) throws JNCException {
        setReadyTimerValue(new YangUInt32(readyTimerValue));
    }

    /**
     * Sets the value for child leaf "ready-timer",
     * using a String value.
     * @param readyTimerValue used during instantiation.
     */
    public void setReadyTimerValue(String readyTimerValue) throws JNCException {
        setReadyTimerValue(new YangUInt32(readyTimerValue));
    }

    /**
     * Unsets the value for child leaf "ready-timer".
     */
    public void unsetReadyTimerValue() throws JNCException {
        delete("ready-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ready-timer" leaf will not have a value.
     */
    public void addReadyTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ready-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ready-timer" with operation "replace".
     */
    public void markReadyTimerReplace() throws JNCException {
        markLeafReplace("readyTimer");
    }

    /**
     * Marks the leaf "ready-timer" with operation "merge".
     */
    public void markReadyTimerMerge() throws JNCException {
        markLeafMerge("readyTimer");
    }

    /**
     * Marks the leaf "ready-timer" with operation "create".
     */
    public void markReadyTimerCreate() throws JNCException {
        markLeafCreate("readyTimer");
    }

    /**
     * Marks the leaf "ready-timer" with operation "delete".
     */
    public void markReadyTimerDelete() throws JNCException {
        markLeafDelete("readyTimer");
    }

    /* Access methods for optional leaf child: "subscriber-type". */

    /**
     * Gets the value for child leaf "subscriber-type".
     * @return The value of the leaf.
     */
    public YangString getSubscriberTypeValue() throws JNCException {
        return (YangString)getValue("subscriber-type");
    }

    /**
     * Sets the value for child leaf "subscriber-type",
     * using instance of generated typedef class.
     * @param subscriberTypeValue The value to set.
     * @param subscriberTypeValue used during instantiation.
     */
    public void setSubscriberTypeValue(YangString subscriberTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "subscriber-type",
            subscriberTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "subscriber-type",
     * using a String value.
     * @param subscriberTypeValue used during instantiation.
     */
    public void setSubscriberTypeValue(String subscriberTypeValue)
            throws JNCException {
        setSubscriberTypeValue(new YangString(subscriberTypeValue));
    }

    /**
     * Unsets the value for child leaf "subscriber-type".
     */
    public void unsetSubscriberTypeValue() throws JNCException {
        delete("subscriber-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "subscriber-type" leaf will not have a value.
     */
    public void addSubscriberType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "subscriber-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "subscriber-type" with operation "replace".
     */
    public void markSubscriberTypeReplace() throws JNCException {
        markLeafReplace("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "merge".
     */
    public void markSubscriberTypeMerge() throws JNCException {
        markLeafMerge("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "create".
     */
    public void markSubscriberTypeCreate() throws JNCException {
        markLeafCreate("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "delete".
     */
    public void markSubscriberTypeDelete() throws JNCException {
        markLeafDelete("subscriberType");
    }

    /* Access methods for optional leaf child: "ms-classmark2". */

    /**
     * Gets the value for child leaf "ms-classmark2".
     * @return The value of the leaf.
     */
    public YangString getMsClassmark2Value() throws JNCException {
        return (YangString)getValue("ms-classmark2");
    }

    /**
     * Sets the value for child leaf "ms-classmark2",
     * using instance of generated typedef class.
     * @param msClassmark2Value The value to set.
     * @param msClassmark2Value used during instantiation.
     */
    public void setMsClassmark2Value(YangString msClassmark2Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-classmark2",
            msClassmark2Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ms-classmark2",
     * using a String value.
     * @param msClassmark2Value used during instantiation.
     */
    public void setMsClassmark2Value(String msClassmark2Value)
            throws JNCException {
        setMsClassmark2Value(new YangString(msClassmark2Value));
    }

    /**
     * Unsets the value for child leaf "ms-classmark2".
     */
    public void unsetMsClassmark2Value() throws JNCException {
        delete("ms-classmark2");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ms-classmark2" leaf will not have a value.
     */
    public void addMsClassmark2() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-classmark2",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ms-classmark2" with operation "replace".
     */
    public void markMsClassmark2Replace() throws JNCException {
        markLeafReplace("msClassmark2");
    }

    /**
     * Marks the leaf "ms-classmark2" with operation "merge".
     */
    public void markMsClassmark2Merge() throws JNCException {
        markLeafMerge("msClassmark2");
    }

    /**
     * Marks the leaf "ms-classmark2" with operation "create".
     */
    public void markMsClassmark2Create() throws JNCException {
        markLeafCreate("msClassmark2");
    }

    /**
     * Marks the leaf "ms-classmark2" with operation "delete".
     */
    public void markMsClassmark2Delete() throws JNCException {
        markLeafDelete("msClassmark2");
    }

    /* Access methods for optional leaf child: "ms-classmark3". */

    /**
     * Gets the value for child leaf "ms-classmark3".
     * @return The value of the leaf.
     */
    public YangString getMsClassmark3Value() throws JNCException {
        return (YangString)getValue("ms-classmark3");
    }

    /**
     * Sets the value for child leaf "ms-classmark3",
     * using instance of generated typedef class.
     * @param msClassmark3Value The value to set.
     * @param msClassmark3Value used during instantiation.
     */
    public void setMsClassmark3Value(YangString msClassmark3Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-classmark3",
            msClassmark3Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ms-classmark3",
     * using a String value.
     * @param msClassmark3Value used during instantiation.
     */
    public void setMsClassmark3Value(String msClassmark3Value)
            throws JNCException {
        setMsClassmark3Value(new YangString(msClassmark3Value));
    }

    /**
     * Unsets the value for child leaf "ms-classmark3".
     */
    public void unsetMsClassmark3Value() throws JNCException {
        delete("ms-classmark3");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ms-classmark3" leaf will not have a value.
     */
    public void addMsClassmark3() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-classmark3",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ms-classmark3" with operation "replace".
     */
    public void markMsClassmark3Replace() throws JNCException {
        markLeafReplace("msClassmark3");
    }

    /**
     * Marks the leaf "ms-classmark3" with operation "merge".
     */
    public void markMsClassmark3Merge() throws JNCException {
        markLeafMerge("msClassmark3");
    }

    /**
     * Marks the leaf "ms-classmark3" with operation "create".
     */
    public void markMsClassmark3Create() throws JNCException {
        markLeafCreate("msClassmark3");
    }

    /**
     * Marks the leaf "ms-classmark3" with operation "delete".
     */
    public void markMsClassmark3Delete() throws JNCException {
        markLeafDelete("msClassmark3");
    }

    /* Access methods for optional leaf child: "supported-codec". */

    /**
     * Gets the value for child leaf "supported-codec".
     * @return The value of the leaf.
     */
    public YangString getSupportedCodecValue() throws JNCException {
        return (YangString)getValue("supported-codec");
    }

    /**
     * Sets the value for child leaf "supported-codec",
     * using instance of generated typedef class.
     * @param supportedCodecValue The value to set.
     * @param supportedCodecValue used during instantiation.
     */
    public void setSupportedCodecValue(YangString supportedCodecValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "supported-codec",
            supportedCodecValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "supported-codec",
     * using a String value.
     * @param supportedCodecValue used during instantiation.
     */
    public void setSupportedCodecValue(String supportedCodecValue)
            throws JNCException {
        setSupportedCodecValue(new YangString(supportedCodecValue));
    }

    /**
     * Unsets the value for child leaf "supported-codec".
     */
    public void unsetSupportedCodecValue() throws JNCException {
        delete("supported-codec");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "supported-codec" leaf will not have a value.
     */
    public void addSupportedCodec() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "supported-codec",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "supported-codec" with operation "replace".
     */
    public void markSupportedCodecReplace() throws JNCException {
        markLeafReplace("supportedCodec");
    }

    /**
     * Marks the leaf "supported-codec" with operation "merge".
     */
    public void markSupportedCodecMerge() throws JNCException {
        markLeafMerge("supportedCodec");
    }

    /**
     * Marks the leaf "supported-codec" with operation "create".
     */
    public void markSupportedCodecCreate() throws JNCException {
        markLeafCreate("supportedCodec");
    }

    /**
     * Marks the leaf "supported-codec" with operation "delete".
     */
    public void markSupportedCodecDelete() throws JNCException {
        markLeafDelete("supportedCodec");
    }

    /* Access methods for optional leaf child: "csg-id". */

    /**
     * Gets the value for child leaf "csg-id".
     * @return The value of the leaf.
     */
    public YangUInt32 getCsgIdValue() throws JNCException {
        return (YangUInt32)getValue("csg-id");
    }

    /**
     * Sets the value for child leaf "csg-id",
     * using instance of generated typedef class.
     * @param csgIdValue The value to set.
     * @param csgIdValue used during instantiation.
     */
    public void setCsgIdValue(YangUInt32 csgIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-id",
            csgIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csg-id",
     * using Java primitive values.
     * @param csgIdValue used during instantiation.
     */
    public void setCsgIdValue(long csgIdValue) throws JNCException {
        setCsgIdValue(new YangUInt32(csgIdValue));
    }

    /**
     * Sets the value for child leaf "csg-id",
     * using a String value.
     * @param csgIdValue used during instantiation.
     */
    public void setCsgIdValue(String csgIdValue) throws JNCException {
        setCsgIdValue(new YangUInt32(csgIdValue));
    }

    /**
     * Unsets the value for child leaf "csg-id".
     */
    public void unsetCsgIdValue() throws JNCException {
        delete("csg-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csg-id" leaf will not have a value.
     */
    public void addCsgId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csg-id" with operation "replace".
     */
    public void markCsgIdReplace() throws JNCException {
        markLeafReplace("csgId");
    }

    /**
     * Marks the leaf "csg-id" with operation "merge".
     */
    public void markCsgIdMerge() throws JNCException {
        markLeafMerge("csgId");
    }

    /**
     * Marks the leaf "csg-id" with operation "create".
     */
    public void markCsgIdCreate() throws JNCException {
        markLeafCreate("csgId");
    }

    /**
     * Marks the leaf "csg-id" with operation "delete".
     */
    public void markCsgIdDelete() throws JNCException {
        markLeafDelete("csgId");
    }

    /* Access methods for optional leaf child: "cell-access-mode". */

    /**
     * Gets the value for child leaf "cell-access-mode".
     * @return The value of the leaf.
     */
    public YangString getCellAccessModeValue() throws JNCException {
        return (YangString)getValue("cell-access-mode");
    }

    /**
     * Sets the value for child leaf "cell-access-mode",
     * using instance of generated typedef class.
     * @param cellAccessModeValue The value to set.
     * @param cellAccessModeValue used during instantiation.
     */
    public void setCellAccessModeValue(YangString cellAccessModeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-access-mode",
            cellAccessModeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cell-access-mode",
     * using a String value.
     * @param cellAccessModeValue used during instantiation.
     */
    public void setCellAccessModeValue(String cellAccessModeValue)
            throws JNCException {
        setCellAccessModeValue(new YangString(cellAccessModeValue));
    }

    /**
     * Unsets the value for child leaf "cell-access-mode".
     */
    public void unsetCellAccessModeValue() throws JNCException {
        delete("cell-access-mode");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cell-access-mode" leaf will not have a value.
     */
    public void addCellAccessMode() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-access-mode",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "replace".
     */
    public void markCellAccessModeReplace() throws JNCException {
        markLeafReplace("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "merge".
     */
    public void markCellAccessModeMerge() throws JNCException {
        markLeafMerge("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "create".
     */
    public void markCellAccessModeCreate() throws JNCException {
        markLeafCreate("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "delete".
     */
    public void markCellAccessModeDelete() throws JNCException {
        markLeafDelete("cellAccessMode");
    }

    /* Access methods for optional leaf child: "csg-membership-status". */

    /**
     * Gets the value for child leaf "csg-membership-status".
     * @return The value of the leaf.
     */
    public YangString getCsgMembershipStatusValue() throws JNCException {
        return (YangString)getValue("csg-membership-status");
    }

    /**
     * Sets the value for child leaf "csg-membership-status",
     * using instance of generated typedef class.
     * @param csgMembershipStatusValue The value to set.
     * @param csgMembershipStatusValue used during instantiation.
     */
    public void setCsgMembershipStatusValue(YangString csgMembershipStatusValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-membership-status",
            csgMembershipStatusValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csg-membership-status",
     * using a String value.
     * @param csgMembershipStatusValue used during instantiation.
     */
    public void setCsgMembershipStatusValue(String csgMembershipStatusValue)
            throws JNCException {
        setCsgMembershipStatusValue(new YangString(csgMembershipStatusValue));
    }

    /**
     * Unsets the value for child leaf "csg-membership-status".
     */
    public void unsetCsgMembershipStatusValue() throws JNCException {
        delete("csg-membership-status");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csg-membership-status" leaf will not have a value.
     */
    public void addCsgMembershipStatus() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-membership-status",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csg-membership-status" with operation "replace".
     */
    public void markCsgMembershipStatusReplace() throws JNCException {
        markLeafReplace("csgMembershipStatus");
    }

    /**
     * Marks the leaf "csg-membership-status" with operation "merge".
     */
    public void markCsgMembershipStatusMerge() throws JNCException {
        markLeafMerge("csgMembershipStatus");
    }

    /**
     * Marks the leaf "csg-membership-status" with operation "create".
     */
    public void markCsgMembershipStatusCreate() throws JNCException {
        markLeafCreate("csgMembershipStatus");
    }

    /**
     * Marks the leaf "csg-membership-status" with operation "delete".
     */
    public void markCsgMembershipStatusDelete() throws JNCException {
        markLeafDelete("csgMembershipStatus");
    }

    /* Access methods for optional leaf child: "geographical-coordinates". */

    /**
     * Gets the value for child leaf "geographical-coordinates".
     * @return The value of the leaf.
     */
    public YangString getGeographicalCoordinatesValue() throws JNCException {
        return (YangString)getValue("geographical-coordinates");
    }

    /**
     * Sets the value for child leaf "geographical-coordinates",
     * using instance of generated typedef class.
     * @param geographicalCoordinatesValue The value to set.
     * @param geographicalCoordinatesValue used during instantiation.
     */
    public void setGeographicalCoordinatesValue(YangString geographicalCoordinatesValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "geographical-coordinates",
            geographicalCoordinatesValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "geographical-coordinates",
     * using a String value.
     * @param geographicalCoordinatesValue used during instantiation.
     */
    public void setGeographicalCoordinatesValue(String geographicalCoordinatesValue)
            throws JNCException {
        setGeographicalCoordinatesValue(new YangString(geographicalCoordinatesValue));
    }

    /**
     * Unsets the value for child leaf "geographical-coordinates".
     */
    public void unsetGeographicalCoordinatesValue() throws JNCException {
        delete("geographical-coordinates");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "geographical-coordinates" leaf will not have a value.
     */
    public void addGeographicalCoordinates() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "geographical-coordinates",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "geographical-coordinates" with operation "replace".
     */
    public void markGeographicalCoordinatesReplace() throws JNCException {
        markLeafReplace("geographicalCoordinates");
    }

    /**
     * Marks the leaf "geographical-coordinates" with operation "merge".
     */
    public void markGeographicalCoordinatesMerge() throws JNCException {
        markLeafMerge("geographicalCoordinates");
    }

    /**
     * Marks the leaf "geographical-coordinates" with operation "create".
     */
    public void markGeographicalCoordinatesCreate() throws JNCException {
        markLeafCreate("geographicalCoordinates");
    }

    /**
     * Marks the leaf "geographical-coordinates" with operation "delete".
     */
    public void markGeographicalCoordinatesDelete() throws JNCException {
        markLeafDelete("geographicalCoordinates");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
