/* 
 * @(#)SubscriberInfoOper.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.subscriber;
import .hctaEpc.ImeisvT;
import .hctaEpc.ImsiT;
import .hctaEpc.MsisdnT;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt32;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/subscriber/subscriber-info-oper"
 * <p>
 * See line 70 in
 * scOperCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class SubscriberInfoOper extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty SubscriberInfoOper object.
     */
    public SubscriberInfoOper() {
        super(Epc.NAMESPACE, "subscriber-info-oper");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public SubscriberInfoOper clone() {
        return (SubscriberInfoOper)cloneContent(new SubscriberInfoOper());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public SubscriberInfoOper cloneShallow() {
        return (SubscriberInfoOper)cloneShallowContent(new SubscriberInfoOper());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "service",
            "imsi",
            "imeisv",
            "msisdn",
            "system-type",
            "access-node",
            "mm-state",
            "attach-duration",
            "subscriber-type",
            "sessions",
            "sc-id",
            "pid",
            "apns",
            "dts",
            "first-ip-address",
        };
    }

    /* Access methods for leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /* Access methods for leaf child: "imsi". */

    /**
     * Gets the value for child leaf "imsi".
     * @return The value of the leaf.
     */
    public ImsiT getImsiValue() throws JNCException {
        return (ImsiT)getValue("imsi");
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a JNC type value.
     * @param imsiValue The value to set.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(ImsiT imsiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            imsiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a String value.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(String imsiValue) throws JNCException {
        setImsiValue(new ImsiT(imsiValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imsi" leaf will not have a value.
     */
    public void addImsi() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "imeisv". */

    /**
     * Gets the value for child leaf "imeisv".
     * @return The value of the leaf.
     */
    public ImeisvT getImeisvValue() throws JNCException {
        return (ImeisvT)getValue("imeisv");
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a JNC type value.
     * @param imeisvValue The value to set.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(ImeisvT imeisvValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            imeisvValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a String value.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(String imeisvValue) throws JNCException {
        setImeisvValue(new ImeisvT(imeisvValue));
    }

    /**
     * Unsets the value for child leaf "imeisv".
     */
    public void unsetImeisvValue() throws JNCException {
        delete("imeisv");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imeisv" leaf will not have a value.
     */
    public void addImeisv() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "imeisv" with operation "replace".
     */
    public void markImeisvReplace() throws JNCException {
        markLeafReplace("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "merge".
     */
    public void markImeisvMerge() throws JNCException {
        markLeafMerge("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "create".
     */
    public void markImeisvCreate() throws JNCException {
        markLeafCreate("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "delete".
     */
    public void markImeisvDelete() throws JNCException {
        markLeafDelete("imeisv");
    }

    /* Access methods for optional leaf child: "msisdn". */

    /**
     * Gets the value for child leaf "msisdn".
     * @return The value of the leaf.
     */
    public MsisdnT getMsisdnValue() throws JNCException {
        return (MsisdnT)getValue("msisdn");
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a JNC type value.
     * @param msisdnValue The value to set.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(MsisdnT msisdnValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            msisdnValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a String value.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(String msisdnValue) throws JNCException {
        setMsisdnValue(new MsisdnT(msisdnValue));
    }

    /**
     * Unsets the value for child leaf "msisdn".
     */
    public void unsetMsisdnValue() throws JNCException {
        delete("msisdn");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "msisdn" leaf will not have a value.
     */
    public void addMsisdn() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "msisdn" with operation "replace".
     */
    public void markMsisdnReplace() throws JNCException {
        markLeafReplace("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "merge".
     */
    public void markMsisdnMerge() throws JNCException {
        markLeafMerge("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "create".
     */
    public void markMsisdnCreate() throws JNCException {
        markLeafCreate("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "delete".
     */
    public void markMsisdnDelete() throws JNCException {
        markLeafDelete("msisdn");
    }

    /* Access methods for optional leaf child: "system-type". */

    /**
     * Gets the value for child leaf "system-type".
     * @return The value of the leaf.
     */
    public YangString getSystemTypeValue() throws JNCException {
        return (YangString)getValue("system-type");
    }

    /**
     * Sets the value for child leaf "system-type",
     * using instance of generated typedef class.
     * @param systemTypeValue The value to set.
     * @param systemTypeValue used during instantiation.
     */
    public void setSystemTypeValue(YangString systemTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "system-type",
            systemTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "system-type",
     * using a String value.
     * @param systemTypeValue used during instantiation.
     */
    public void setSystemTypeValue(String systemTypeValue) throws JNCException {
        setSystemTypeValue(new YangString(systemTypeValue));
    }

    /**
     * Unsets the value for child leaf "system-type".
     */
    public void unsetSystemTypeValue() throws JNCException {
        delete("system-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "system-type" leaf will not have a value.
     */
    public void addSystemType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "system-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "system-type" with operation "replace".
     */
    public void markSystemTypeReplace() throws JNCException {
        markLeafReplace("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "merge".
     */
    public void markSystemTypeMerge() throws JNCException {
        markLeafMerge("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "create".
     */
    public void markSystemTypeCreate() throws JNCException {
        markLeafCreate("systemType");
    }

    /**
     * Marks the leaf "system-type" with operation "delete".
     */
    public void markSystemTypeDelete() throws JNCException {
        markLeafDelete("systemType");
    }

    /* Access methods for optional leaf child: "access-node". */

    /**
     * Gets the value for child leaf "access-node".
     * @return The value of the leaf.
     */
    public YangUInt32 getAccessNodeValue() throws JNCException {
        return (YangUInt32)getValue("access-node");
    }

    /**
     * Sets the value for child leaf "access-node",
     * using instance of generated typedef class.
     * @param accessNodeValue The value to set.
     * @param accessNodeValue used during instantiation.
     */
    public void setAccessNodeValue(YangUInt32 accessNodeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "access-node",
            accessNodeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "access-node",
     * using Java primitive values.
     * @param accessNodeValue used during instantiation.
     */
    public void setAccessNodeValue(long accessNodeValue) throws JNCException {
        setAccessNodeValue(new YangUInt32(accessNodeValue));
    }

    /**
     * Sets the value for child leaf "access-node",
     * using a String value.
     * @param accessNodeValue used during instantiation.
     */
    public void setAccessNodeValue(String accessNodeValue) throws JNCException {
        setAccessNodeValue(new YangUInt32(accessNodeValue));
    }

    /**
     * Unsets the value for child leaf "access-node".
     */
    public void unsetAccessNodeValue() throws JNCException {
        delete("access-node");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "access-node" leaf will not have a value.
     */
    public void addAccessNode() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "access-node",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "access-node" with operation "replace".
     */
    public void markAccessNodeReplace() throws JNCException {
        markLeafReplace("accessNode");
    }

    /**
     * Marks the leaf "access-node" with operation "merge".
     */
    public void markAccessNodeMerge() throws JNCException {
        markLeafMerge("accessNode");
    }

    /**
     * Marks the leaf "access-node" with operation "create".
     */
    public void markAccessNodeCreate() throws JNCException {
        markLeafCreate("accessNode");
    }

    /**
     * Marks the leaf "access-node" with operation "delete".
     */
    public void markAccessNodeDelete() throws JNCException {
        markLeafDelete("accessNode");
    }

    /* Access methods for optional leaf child: "mm-state". */

    /**
     * Gets the value for child leaf "mm-state".
     * @return The value of the leaf.
     */
    public YangString getMmStateValue() throws JNCException {
        return (YangString)getValue("mm-state");
    }

    /**
     * Sets the value for child leaf "mm-state",
     * using instance of generated typedef class.
     * @param mmStateValue The value to set.
     * @param mmStateValue used during instantiation.
     */
    public void setMmStateValue(YangString mmStateValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-state",
            mmStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mm-state",
     * using a String value.
     * @param mmStateValue used during instantiation.
     */
    public void setMmStateValue(String mmStateValue) throws JNCException {
        setMmStateValue(new YangString(mmStateValue));
    }

    /**
     * Unsets the value for child leaf "mm-state".
     */
    public void unsetMmStateValue() throws JNCException {
        delete("mm-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mm-state" leaf will not have a value.
     */
    public void addMmState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mm-state" with operation "replace".
     */
    public void markMmStateReplace() throws JNCException {
        markLeafReplace("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "merge".
     */
    public void markMmStateMerge() throws JNCException {
        markLeafMerge("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "create".
     */
    public void markMmStateCreate() throws JNCException {
        markLeafCreate("mmState");
    }

    /**
     * Marks the leaf "mm-state" with operation "delete".
     */
    public void markMmStateDelete() throws JNCException {
        markLeafDelete("mmState");
    }

    /* Access methods for optional leaf child: "attach-duration". */

    /**
     * Gets the value for child leaf "attach-duration".
     * @return The value of the leaf.
     */
    public YangUInt32 getAttachDurationValue() throws JNCException {
        return (YangUInt32)getValue("attach-duration");
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using instance of generated typedef class.
     * @param attachDurationValue The value to set.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(YangUInt32 attachDurationValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "attach-duration",
            attachDurationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using Java primitive values.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(long attachDurationValue)
            throws JNCException {
        setAttachDurationValue(new YangUInt32(attachDurationValue));
    }

    /**
     * Sets the value for child leaf "attach-duration",
     * using a String value.
     * @param attachDurationValue used during instantiation.
     */
    public void setAttachDurationValue(String attachDurationValue)
            throws JNCException {
        setAttachDurationValue(new YangUInt32(attachDurationValue));
    }

    /**
     * Unsets the value for child leaf "attach-duration".
     */
    public void unsetAttachDurationValue() throws JNCException {
        delete("attach-duration");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "attach-duration" leaf will not have a value.
     */
    public void addAttachDuration() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "attach-duration",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "attach-duration" with operation "replace".
     */
    public void markAttachDurationReplace() throws JNCException {
        markLeafReplace("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "merge".
     */
    public void markAttachDurationMerge() throws JNCException {
        markLeafMerge("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "create".
     */
    public void markAttachDurationCreate() throws JNCException {
        markLeafCreate("attachDuration");
    }

    /**
     * Marks the leaf "attach-duration" with operation "delete".
     */
    public void markAttachDurationDelete() throws JNCException {
        markLeafDelete("attachDuration");
    }

    /* Access methods for optional leaf child: "subscriber-type". */

    /**
     * Gets the value for child leaf "subscriber-type".
     * @return The value of the leaf.
     */
    public YangString getSubscriberTypeValue() throws JNCException {
        return (YangString)getValue("subscriber-type");
    }

    /**
     * Sets the value for child leaf "subscriber-type",
     * using instance of generated typedef class.
     * @param subscriberTypeValue The value to set.
     * @param subscriberTypeValue used during instantiation.
     */
    public void setSubscriberTypeValue(YangString subscriberTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "subscriber-type",
            subscriberTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "subscriber-type",
     * using a String value.
     * @param subscriberTypeValue used during instantiation.
     */
    public void setSubscriberTypeValue(String subscriberTypeValue)
            throws JNCException {
        setSubscriberTypeValue(new YangString(subscriberTypeValue));
    }

    /**
     * Unsets the value for child leaf "subscriber-type".
     */
    public void unsetSubscriberTypeValue() throws JNCException {
        delete("subscriber-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "subscriber-type" leaf will not have a value.
     */
    public void addSubscriberType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "subscriber-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "subscriber-type" with operation "replace".
     */
    public void markSubscriberTypeReplace() throws JNCException {
        markLeafReplace("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "merge".
     */
    public void markSubscriberTypeMerge() throws JNCException {
        markLeafMerge("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "create".
     */
    public void markSubscriberTypeCreate() throws JNCException {
        markLeafCreate("subscriberType");
    }

    /**
     * Marks the leaf "subscriber-type" with operation "delete".
     */
    public void markSubscriberTypeDelete() throws JNCException {
        markLeafDelete("subscriberType");
    }

    /* Access methods for optional leaf child: "sessions". */

    /**
     * Gets the value for child leaf "sessions".
     * @return The value of the leaf.
     */
    public YangUInt16 getSessionsValue() throws JNCException {
        return (YangUInt16)getValue("sessions");
    }

    /**
     * Sets the value for child leaf "sessions",
     * using instance of generated typedef class.
     * @param sessionsValue The value to set.
     * @param sessionsValue used during instantiation.
     */
    public void setSessionsValue(YangUInt16 sessionsValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sessions",
            sessionsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sessions",
     * using Java primitive values.
     * @param sessionsValue used during instantiation.
     */
    public void setSessionsValue(int sessionsValue) throws JNCException {
        setSessionsValue(new YangUInt16(sessionsValue));
    }

    /**
     * Sets the value for child leaf "sessions",
     * using a String value.
     * @param sessionsValue used during instantiation.
     */
    public void setSessionsValue(String sessionsValue) throws JNCException {
        setSessionsValue(new YangUInt16(sessionsValue));
    }

    /**
     * Unsets the value for child leaf "sessions".
     */
    public void unsetSessionsValue() throws JNCException {
        delete("sessions");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sessions" leaf will not have a value.
     */
    public void addSessions() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sessions",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sessions" with operation "replace".
     */
    public void markSessionsReplace() throws JNCException {
        markLeafReplace("sessions");
    }

    /**
     * Marks the leaf "sessions" with operation "merge".
     */
    public void markSessionsMerge() throws JNCException {
        markLeafMerge("sessions");
    }

    /**
     * Marks the leaf "sessions" with operation "create".
     */
    public void markSessionsCreate() throws JNCException {
        markLeafCreate("sessions");
    }

    /**
     * Marks the leaf "sessions" with operation "delete".
     */
    public void markSessionsDelete() throws JNCException {
        markLeafDelete("sessions");
    }

    /* Access methods for optional leaf child: "sc-id". */

    /**
     * Gets the value for child leaf "sc-id".
     * @return The value of the leaf.
     */
    public YangUInt32 getScIdValue() throws JNCException {
        return (YangUInt32)getValue("sc-id");
    }

    /**
     * Sets the value for child leaf "sc-id",
     * using instance of generated typedef class.
     * @param scIdValue The value to set.
     * @param scIdValue used during instantiation.
     */
    public void setScIdValue(YangUInt32 scIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-id",
            scIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sc-id",
     * using Java primitive values.
     * @param scIdValue used during instantiation.
     */
    public void setScIdValue(long scIdValue) throws JNCException {
        setScIdValue(new YangUInt32(scIdValue));
    }

    /**
     * Sets the value for child leaf "sc-id",
     * using a String value.
     * @param scIdValue used during instantiation.
     */
    public void setScIdValue(String scIdValue) throws JNCException {
        setScIdValue(new YangUInt32(scIdValue));
    }

    /**
     * Unsets the value for child leaf "sc-id".
     */
    public void unsetScIdValue() throws JNCException {
        delete("sc-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sc-id" leaf will not have a value.
     */
    public void addScId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sc-id" with operation "replace".
     */
    public void markScIdReplace() throws JNCException {
        markLeafReplace("scId");
    }

    /**
     * Marks the leaf "sc-id" with operation "merge".
     */
    public void markScIdMerge() throws JNCException {
        markLeafMerge("scId");
    }

    /**
     * Marks the leaf "sc-id" with operation "create".
     */
    public void markScIdCreate() throws JNCException {
        markLeafCreate("scId");
    }

    /**
     * Marks the leaf "sc-id" with operation "delete".
     */
    public void markScIdDelete() throws JNCException {
        markLeafDelete("scId");
    }

    /* Access methods for optional leaf child: "pid". */

    /**
     * Gets the value for child leaf "pid".
     * @return The value of the leaf.
     */
    public YangUInt32 getPidValue() throws JNCException {
        return (YangUInt32)getValue("pid");
    }

    /**
     * Sets the value for child leaf "pid",
     * using instance of generated typedef class.
     * @param pidValue The value to set.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(YangUInt32 pidValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pid",
            pidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "pid",
     * using Java primitive values.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(long pidValue) throws JNCException {
        setPidValue(new YangUInt32(pidValue));
    }

    /**
     * Sets the value for child leaf "pid",
     * using a String value.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(String pidValue) throws JNCException {
        setPidValue(new YangUInt32(pidValue));
    }

    /**
     * Unsets the value for child leaf "pid".
     */
    public void unsetPidValue() throws JNCException {
        delete("pid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "pid" leaf will not have a value.
     */
    public void addPid() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "pid" with operation "replace".
     */
    public void markPidReplace() throws JNCException {
        markLeafReplace("pid");
    }

    /**
     * Marks the leaf "pid" with operation "merge".
     */
    public void markPidMerge() throws JNCException {
        markLeafMerge("pid");
    }

    /**
     * Marks the leaf "pid" with operation "create".
     */
    public void markPidCreate() throws JNCException {
        markLeafCreate("pid");
    }

    /**
     * Marks the leaf "pid" with operation "delete".
     */
    public void markPidDelete() throws JNCException {
        markLeafDelete("pid");
    }

    /* Access methods for optional leaf child: "apns". */

    /**
     * Gets the value for child leaf "apns".
     * @return The value of the leaf.
     */
    public YangUInt16 getApnsValue() throws JNCException {
        return (YangUInt16)getValue("apns");
    }

    /**
     * Sets the value for child leaf "apns",
     * using instance of generated typedef class.
     * @param apnsValue The value to set.
     * @param apnsValue used during instantiation.
     */
    public void setApnsValue(YangUInt16 apnsValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "apns",
            apnsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "apns",
     * using Java primitive values.
     * @param apnsValue used during instantiation.
     */
    public void setApnsValue(int apnsValue) throws JNCException {
        setApnsValue(new YangUInt16(apnsValue));
    }

    /**
     * Sets the value for child leaf "apns",
     * using a String value.
     * @param apnsValue used during instantiation.
     */
    public void setApnsValue(String apnsValue) throws JNCException {
        setApnsValue(new YangUInt16(apnsValue));
    }

    /**
     * Unsets the value for child leaf "apns".
     */
    public void unsetApnsValue() throws JNCException {
        delete("apns");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "apns" leaf will not have a value.
     */
    public void addApns() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "apns",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "apns" with operation "replace".
     */
    public void markApnsReplace() throws JNCException {
        markLeafReplace("apns");
    }

    /**
     * Marks the leaf "apns" with operation "merge".
     */
    public void markApnsMerge() throws JNCException {
        markLeafMerge("apns");
    }

    /**
     * Marks the leaf "apns" with operation "create".
     */
    public void markApnsCreate() throws JNCException {
        markLeafCreate("apns");
    }

    /**
     * Marks the leaf "apns" with operation "delete".
     */
    public void markApnsDelete() throws JNCException {
        markLeafDelete("apns");
    }

    /* Access methods for optional leaf child: "dts". */

    /**
     * Gets the value for child leaf "dts".
     * @return The value of the leaf.
     */
    public YangUInt16 getDtsValue() throws JNCException {
        return (YangUInt16)getValue("dts");
    }

    /**
     * Sets the value for child leaf "dts",
     * using instance of generated typedef class.
     * @param dtsValue The value to set.
     * @param dtsValue used during instantiation.
     */
    public void setDtsValue(YangUInt16 dtsValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dts",
            dtsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dts",
     * using Java primitive values.
     * @param dtsValue used during instantiation.
     */
    public void setDtsValue(int dtsValue) throws JNCException {
        setDtsValue(new YangUInt16(dtsValue));
    }

    /**
     * Sets the value for child leaf "dts",
     * using a String value.
     * @param dtsValue used during instantiation.
     */
    public void setDtsValue(String dtsValue) throws JNCException {
        setDtsValue(new YangUInt16(dtsValue));
    }

    /**
     * Unsets the value for child leaf "dts".
     */
    public void unsetDtsValue() throws JNCException {
        delete("dts");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dts" leaf will not have a value.
     */
    public void addDts() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dts",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dts" with operation "replace".
     */
    public void markDtsReplace() throws JNCException {
        markLeafReplace("dts");
    }

    /**
     * Marks the leaf "dts" with operation "merge".
     */
    public void markDtsMerge() throws JNCException {
        markLeafMerge("dts");
    }

    /**
     * Marks the leaf "dts" with operation "create".
     */
    public void markDtsCreate() throws JNCException {
        markLeafCreate("dts");
    }

    /**
     * Marks the leaf "dts" with operation "delete".
     */
    public void markDtsDelete() throws JNCException {
        markLeafDelete("dts");
    }

    /* Access methods for optional leaf child: "first-ip-address". */

    /**
     * Gets the value for child leaf "first-ip-address".
     * @return The value of the leaf.
     */
    public YangString getFirstIpAddressValue() throws JNCException {
        return (YangString)getValue("first-ip-address");
    }

    /**
     * Sets the value for child leaf "first-ip-address",
     * using instance of generated typedef class.
     * @param firstIpAddressValue The value to set.
     * @param firstIpAddressValue used during instantiation.
     */
    public void setFirstIpAddressValue(YangString firstIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "first-ip-address",
            firstIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "first-ip-address",
     * using a String value.
     * @param firstIpAddressValue used during instantiation.
     */
    public void setFirstIpAddressValue(String firstIpAddressValue)
            throws JNCException {
        setFirstIpAddressValue(new YangString(firstIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "first-ip-address".
     */
    public void unsetFirstIpAddressValue() throws JNCException {
        delete("first-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "first-ip-address" leaf will not have a value.
     */
    public void addFirstIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "first-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "first-ip-address" with operation "replace".
     */
    public void markFirstIpAddressReplace() throws JNCException {
        markLeafReplace("firstIpAddress");
    }

    /**
     * Marks the leaf "first-ip-address" with operation "merge".
     */
    public void markFirstIpAddressMerge() throws JNCException {
        markLeafMerge("firstIpAddress");
    }

    /**
     * Marks the leaf "first-ip-address" with operation "create".
     */
    public void markFirstIpAddressCreate() throws JNCException {
        markLeafCreate("firstIpAddress");
    }

    /**
     * Marks the leaf "first-ip-address" with operation "delete".
     */
    public void markFirstIpAddressDelete() throws JNCException {
        markLeafDelete("firstIpAddress");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
