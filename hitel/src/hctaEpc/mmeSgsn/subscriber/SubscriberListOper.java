/* 
 * @(#)SubscriberListOper.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.subscriber;
import .hctaEpc.ImeisvT;
import .hctaEpc.ImsiT;
import .hctaEpc.MsisdnT;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/subscriber/subscriber-list-oper"
 * <p>
 * See line 1106 in
 * scCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class SubscriberListOper extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty SubscriberListOper object.
     */
    public SubscriberListOper() {
        super(Epc.NAMESPACE, "subscriber-list-oper");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public SubscriberListOper clone() {
        return (SubscriberListOper)cloneContent(new SubscriberListOper());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public SubscriberListOper cloneShallow() {
        return (SubscriberListOper)cloneShallowContent(new SubscriberListOper());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "imsi",
            "imeisv",
            "msisdn",
            "service",
            "sc-instance",
            "sc-component-id",
        };
    }

    /* Access methods for optional leaf child: "imsi". */

    /**
     * Gets the value for child leaf "imsi".
     * @return The value of the leaf.
     */
    public ImsiT getImsiValue() throws JNCException {
        return (ImsiT)getValue("imsi");
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a JNC type value.
     * @param imsiValue The value to set.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(ImsiT imsiValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            imsiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imsi",
     * using a String value.
     * @param imsiValue used during instantiation.
     */
    public void setImsiValue(String imsiValue) throws JNCException {
        setImsiValue(new ImsiT(imsiValue));
    }

    /**
     * Unsets the value for child leaf "imsi".
     */
    public void unsetImsiValue() throws JNCException {
        delete("imsi");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imsi" leaf will not have a value.
     */
    public void addImsi() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imsi",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "imsi" with operation "replace".
     */
    public void markImsiReplace() throws JNCException {
        markLeafReplace("imsi");
    }

    /**
     * Marks the leaf "imsi" with operation "merge".
     */
    public void markImsiMerge() throws JNCException {
        markLeafMerge("imsi");
    }

    /**
     * Marks the leaf "imsi" with operation "create".
     */
    public void markImsiCreate() throws JNCException {
        markLeafCreate("imsi");
    }

    /**
     * Marks the leaf "imsi" with operation "delete".
     */
    public void markImsiDelete() throws JNCException {
        markLeafDelete("imsi");
    }

    /* Access methods for optional leaf child: "imeisv". */

    /**
     * Gets the value for child leaf "imeisv".
     * @return The value of the leaf.
     */
    public ImeisvT getImeisvValue() throws JNCException {
        return (ImeisvT)getValue("imeisv");
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a JNC type value.
     * @param imeisvValue The value to set.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(ImeisvT imeisvValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            imeisvValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "imeisv",
     * using a String value.
     * @param imeisvValue used during instantiation.
     */
    public void setImeisvValue(String imeisvValue) throws JNCException {
        setImeisvValue(new ImeisvT(imeisvValue));
    }

    /**
     * Unsets the value for child leaf "imeisv".
     */
    public void unsetImeisvValue() throws JNCException {
        delete("imeisv");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "imeisv" leaf will not have a value.
     */
    public void addImeisv() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "imeisv",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "imeisv" with operation "replace".
     */
    public void markImeisvReplace() throws JNCException {
        markLeafReplace("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "merge".
     */
    public void markImeisvMerge() throws JNCException {
        markLeafMerge("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "create".
     */
    public void markImeisvCreate() throws JNCException {
        markLeafCreate("imeisv");
    }

    /**
     * Marks the leaf "imeisv" with operation "delete".
     */
    public void markImeisvDelete() throws JNCException {
        markLeafDelete("imeisv");
    }

    /* Access methods for optional leaf child: "msisdn". */

    /**
     * Gets the value for child leaf "msisdn".
     * @return The value of the leaf.
     */
    public MsisdnT getMsisdnValue() throws JNCException {
        return (MsisdnT)getValue("msisdn");
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a JNC type value.
     * @param msisdnValue The value to set.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(MsisdnT msisdnValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            msisdnValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "msisdn",
     * using a String value.
     * @param msisdnValue used during instantiation.
     */
    public void setMsisdnValue(String msisdnValue) throws JNCException {
        setMsisdnValue(new MsisdnT(msisdnValue));
    }

    /**
     * Unsets the value for child leaf "msisdn".
     */
    public void unsetMsisdnValue() throws JNCException {
        delete("msisdn");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "msisdn" leaf will not have a value.
     */
    public void addMsisdn() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msisdn",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "msisdn" with operation "replace".
     */
    public void markMsisdnReplace() throws JNCException {
        markLeafReplace("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "merge".
     */
    public void markMsisdnMerge() throws JNCException {
        markLeafMerge("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "create".
     */
    public void markMsisdnCreate() throws JNCException {
        markLeafCreate("msisdn");
    }

    /**
     * Marks the leaf "msisdn" with operation "delete".
     */
    public void markMsisdnDelete() throws JNCException {
        markLeafDelete("msisdn");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "sc-instance". */

    /**
     * Gets the value for child leaf "sc-instance".
     * @return The value of the leaf.
     */
    public YangUInt16 getScInstanceValue() throws JNCException {
        return (YangUInt16)getValue("sc-instance");
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using instance of generated typedef class.
     * @param scInstanceValue The value to set.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(YangUInt16 scInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-instance",
            scInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using Java primitive values.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(int scInstanceValue) throws JNCException {
        setScInstanceValue(new YangUInt16(scInstanceValue));
    }

    /**
     * Sets the value for child leaf "sc-instance",
     * using a String value.
     * @param scInstanceValue used during instantiation.
     */
    public void setScInstanceValue(String scInstanceValue) throws JNCException {
        setScInstanceValue(new YangUInt16(scInstanceValue));
    }

    /**
     * Unsets the value for child leaf "sc-instance".
     */
    public void unsetScInstanceValue() throws JNCException {
        delete("sc-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sc-instance" leaf will not have a value.
     */
    public void addScInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sc-instance" with operation "replace".
     */
    public void markScInstanceReplace() throws JNCException {
        markLeafReplace("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "merge".
     */
    public void markScInstanceMerge() throws JNCException {
        markLeafMerge("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "create".
     */
    public void markScInstanceCreate() throws JNCException {
        markLeafCreate("scInstance");
    }

    /**
     * Marks the leaf "sc-instance" with operation "delete".
     */
    public void markScInstanceDelete() throws JNCException {
        markLeafDelete("scInstance");
    }

    /* Access methods for optional leaf child: "sc-component-id". */

    /**
     * Gets the value for child leaf "sc-component-id".
     * @return The value of the leaf.
     */
    public YangUInt8 getScComponentIdValue() throws JNCException {
        return (YangUInt8)getValue("sc-component-id");
    }

    /**
     * Sets the value for child leaf "sc-component-id",
     * using instance of generated typedef class.
     * @param scComponentIdValue The value to set.
     * @param scComponentIdValue used during instantiation.
     */
    public void setScComponentIdValue(YangUInt8 scComponentIdValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-component-id",
            scComponentIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sc-component-id",
     * using Java primitive values.
     * @param scComponentIdValue used during instantiation.
     */
    public void setScComponentIdValue(short scComponentIdValue)
            throws JNCException {
        setScComponentIdValue(new YangUInt8(scComponentIdValue));
    }

    /**
     * Sets the value for child leaf "sc-component-id",
     * using a String value.
     * @param scComponentIdValue used during instantiation.
     */
    public void setScComponentIdValue(String scComponentIdValue)
            throws JNCException {
        setScComponentIdValue(new YangUInt8(scComponentIdValue));
    }

    /**
     * Unsets the value for child leaf "sc-component-id".
     */
    public void unsetScComponentIdValue() throws JNCException {
        delete("sc-component-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sc-component-id" leaf will not have a value.
     */
    public void addScComponentId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sc-component-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sc-component-id" with operation "replace".
     */
    public void markScComponentIdReplace() throws JNCException {
        markLeafReplace("scComponentId");
    }

    /**
     * Marks the leaf "sc-component-id" with operation "merge".
     */
    public void markScComponentIdMerge() throws JNCException {
        markLeafMerge("scComponentId");
    }

    /**
     * Marks the leaf "sc-component-id" with operation "create".
     */
    public void markScComponentIdCreate() throws JNCException {
        markLeafCreate("scComponentId");
    }

    /**
     * Marks the leaf "sc-component-id" with operation "delete".
     */
    public void markScComponentIdDelete() throws JNCException {
        markLeafDelete("scComponentId");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
