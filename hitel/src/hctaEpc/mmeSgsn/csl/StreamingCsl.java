/* 
 * @(#)StreamingCsl.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.csl;
import .ietfInetTypes.Ipv4Address;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/csl/streaming-csl"
 * <p>
 * See line 90 in
 * cslConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class StreamingCsl extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty StreamingCsl object.
     */
    public StreamingCsl() {
        super(Epc.NAMESPACE, "streaming-csl");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public StreamingCsl clone() {
        return (StreamingCsl)cloneContent(new StreamingCsl());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public StreamingCsl cloneShallow() {
        return (StreamingCsl)cloneShallowContent(new StreamingCsl());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "sctp-profile",
            "routing-instance",
            "local-ip-address",
            "remote-ip-address1",
            "remote-port1",
            "remote-ip-address2",
            "remote-port2",
            "dscp-mark",
            "streaming-fallback",
        };
    }

    /* Access methods for optional leaf child: "sctp-profile". */

    /**
     * Gets the value for child leaf "sctp-profile".
     * @return The value of the leaf.
     */
    public YangString getSctpProfileValue() throws JNCException {
        return (YangString)getValue("sctp-profile");
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using instance of generated typedef class.
     * @param sctpProfileValue The value to set.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(YangString sctpProfileValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            sctpProfileValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using a String value.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(String sctpProfileValue)
            throws JNCException {
        setSctpProfileValue(new YangString(sctpProfileValue));
    }

    /**
     * Unsets the value for child leaf "sctp-profile".
     */
    public void unsetSctpProfileValue() throws JNCException {
        delete("sctp-profile");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sctp-profile" leaf will not have a value.
     */
    public void addSctpProfile() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sctp-profile" with operation "replace".
     */
    public void markSctpProfileReplace() throws JNCException {
        markLeafReplace("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "merge".
     */
    public void markSctpProfileMerge() throws JNCException {
        markLeafMerge("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "create".
     */
    public void markSctpProfileCreate() throws JNCException {
        markLeafCreate("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "delete".
     */
    public void markSctpProfileDelete() throws JNCException {
        markLeafDelete("sctpProfile");
    }

    /* Access methods for optional leaf child: "routing-instance". */

    /**
     * Gets the value for child leaf "routing-instance".
     * @return The value of the leaf.
     */
    public YangString getRoutingInstanceValue() throws JNCException {
        return (YangString)getValue("routing-instance");
    }

    /**
     * Sets the value for child leaf "routing-instance",
     * using instance of generated typedef class.
     * @param routingInstanceValue The value to set.
     * @param routingInstanceValue used during instantiation.
     */
    public void setRoutingInstanceValue(YangString routingInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance",
            routingInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "routing-instance",
     * using a String value.
     * @param routingInstanceValue used during instantiation.
     */
    public void setRoutingInstanceValue(String routingInstanceValue)
            throws JNCException {
        setRoutingInstanceValue(new YangString(routingInstanceValue));
    }

    /**
     * Unsets the value for child leaf "routing-instance".
     */
    public void unsetRoutingInstanceValue() throws JNCException {
        delete("routing-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "routing-instance" leaf will not have a value.
     */
    public void addRoutingInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "routing-instance" with operation "replace".
     */
    public void markRoutingInstanceReplace() throws JNCException {
        markLeafReplace("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "merge".
     */
    public void markRoutingInstanceMerge() throws JNCException {
        markLeafMerge("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "create".
     */
    public void markRoutingInstanceCreate() throws JNCException {
        markLeafCreate("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "delete".
     */
    public void markRoutingInstanceDelete() throws JNCException {
        markLeafDelete("routingInstance");
    }

    /* Access methods for optional leaf child: "local-ip-address". */

    /**
     * Gets the value for child leaf "local-ip-address".
     * @return The value of the leaf.
     */
    public Ipv4Address getLocalIpAddressValue() throws JNCException {
        return (Ipv4Address)getValue("local-ip-address");
    }

    /**
     * Sets the value for child leaf "local-ip-address",
     * using a JNC type value.
     * @param localIpAddressValue The value to set.
     * @param localIpAddressValue used during instantiation.
     */
    public void setLocalIpAddressValue(Ipv4Address localIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "local-ip-address",
            localIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "local-ip-address",
     * using a String value.
     * @param localIpAddressValue used during instantiation.
     */
    public void setLocalIpAddressValue(String localIpAddressValue)
            throws JNCException {
        setLocalIpAddressValue(new Ipv4Address(localIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "local-ip-address".
     */
    public void unsetLocalIpAddressValue() throws JNCException {
        delete("local-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "local-ip-address" leaf will not have a value.
     */
    public void addLocalIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "local-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "local-ip-address" with operation "replace".
     */
    public void markLocalIpAddressReplace() throws JNCException {
        markLeafReplace("localIpAddress");
    }

    /**
     * Marks the leaf "local-ip-address" with operation "merge".
     */
    public void markLocalIpAddressMerge() throws JNCException {
        markLeafMerge("localIpAddress");
    }

    /**
     * Marks the leaf "local-ip-address" with operation "create".
     */
    public void markLocalIpAddressCreate() throws JNCException {
        markLeafCreate("localIpAddress");
    }

    /**
     * Marks the leaf "local-ip-address" with operation "delete".
     */
    public void markLocalIpAddressDelete() throws JNCException {
        markLeafDelete("localIpAddress");
    }

    /* Access methods for optional leaf child: "remote-ip-address1". */

    /**
     * Gets the value for child leaf "remote-ip-address1".
     * @return The value of the leaf.
     */
    public Ipv4Address getRemoteIpAddress1Value() throws JNCException {
        Ipv4Address remoteIpAddress1 = (Ipv4Address)getValue("remote-ip-address1");
        if (remoteIpAddress1 == null) {
            remoteIpAddress1 = new Ipv4Address("0.0.0.0");  // default
        }
        return remoteIpAddress1;
    }

    /**
     * Sets the value for child leaf "remote-ip-address1",
     * using a JNC type value.
     * @param remoteIpAddress1Value The value to set.
     * @param remoteIpAddress1Value used during instantiation.
     */
    public void setRemoteIpAddress1Value(Ipv4Address remoteIpAddress1Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-ip-address1",
            remoteIpAddress1Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "remote-ip-address1",
     * using a String value.
     * @param remoteIpAddress1Value used during instantiation.
     */
    public void setRemoteIpAddress1Value(String remoteIpAddress1Value)
            throws JNCException {
        setRemoteIpAddress1Value(new Ipv4Address(remoteIpAddress1Value));
    }

    /**
     * Unsets the value for child leaf "remote-ip-address1".
     */
    public void unsetRemoteIpAddress1Value() throws JNCException {
        delete("remote-ip-address1");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "remote-ip-address1" leaf will not have a value.
     */
    public void addRemoteIpAddress1() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-ip-address1",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "remote-ip-address1" with operation "replace".
     */
    public void markRemoteIpAddress1Replace() throws JNCException {
        markLeafReplace("remoteIpAddress1");
    }

    /**
     * Marks the leaf "remote-ip-address1" with operation "merge".
     */
    public void markRemoteIpAddress1Merge() throws JNCException {
        markLeafMerge("remoteIpAddress1");
    }

    /**
     * Marks the leaf "remote-ip-address1" with operation "create".
     */
    public void markRemoteIpAddress1Create() throws JNCException {
        markLeafCreate("remoteIpAddress1");
    }

    /**
     * Marks the leaf "remote-ip-address1" with operation "delete".
     */
    public void markRemoteIpAddress1Delete() throws JNCException {
        markLeafDelete("remoteIpAddress1");
    }

    /* Access methods for optional leaf child: "remote-port1". */

    /**
     * Gets the value for child leaf "remote-port1".
     * @return The value of the leaf.
     */
    public YangUInt16 getRemotePort1Value() throws JNCException {
        YangUInt16 remotePort1 = (YangUInt16)getValue("remote-port1");
        if (remotePort1 == null) {
            remotePort1 = new YangUInt16("0");  // default
        }
        return remotePort1;
    }

    /**
     * Sets the value for child leaf "remote-port1",
     * using instance of generated typedef class.
     * @param remotePort1Value The value to set.
     * @param remotePort1Value used during instantiation.
     */
    public void setRemotePort1Value(YangUInt16 remotePort1Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-port1",
            remotePort1Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "remote-port1",
     * using Java primitive values.
     * @param remotePort1Value used during instantiation.
     */
    public void setRemotePort1Value(int remotePort1Value) throws JNCException {
        setRemotePort1Value(new YangUInt16(remotePort1Value));
    }

    /**
     * Sets the value for child leaf "remote-port1",
     * using a String value.
     * @param remotePort1Value used during instantiation.
     */
    public void setRemotePort1Value(String remotePort1Value)
            throws JNCException {
        setRemotePort1Value(new YangUInt16(remotePort1Value));
    }

    /**
     * Unsets the value for child leaf "remote-port1".
     */
    public void unsetRemotePort1Value() throws JNCException {
        delete("remote-port1");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "remote-port1" leaf will not have a value.
     */
    public void addRemotePort1() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-port1",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "remote-port1" with operation "replace".
     */
    public void markRemotePort1Replace() throws JNCException {
        markLeafReplace("remotePort1");
    }

    /**
     * Marks the leaf "remote-port1" with operation "merge".
     */
    public void markRemotePort1Merge() throws JNCException {
        markLeafMerge("remotePort1");
    }

    /**
     * Marks the leaf "remote-port1" with operation "create".
     */
    public void markRemotePort1Create() throws JNCException {
        markLeafCreate("remotePort1");
    }

    /**
     * Marks the leaf "remote-port1" with operation "delete".
     */
    public void markRemotePort1Delete() throws JNCException {
        markLeafDelete("remotePort1");
    }

    /* Access methods for optional leaf child: "remote-ip-address2". */

    /**
     * Gets the value for child leaf "remote-ip-address2".
     * @return The value of the leaf.
     */
    public Ipv4Address getRemoteIpAddress2Value() throws JNCException {
        Ipv4Address remoteIpAddress2 = (Ipv4Address)getValue("remote-ip-address2");
        if (remoteIpAddress2 == null) {
            remoteIpAddress2 = new Ipv4Address("0.0.0.0");  // default
        }
        return remoteIpAddress2;
    }

    /**
     * Sets the value for child leaf "remote-ip-address2",
     * using a JNC type value.
     * @param remoteIpAddress2Value The value to set.
     * @param remoteIpAddress2Value used during instantiation.
     */
    public void setRemoteIpAddress2Value(Ipv4Address remoteIpAddress2Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-ip-address2",
            remoteIpAddress2Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "remote-ip-address2",
     * using a String value.
     * @param remoteIpAddress2Value used during instantiation.
     */
    public void setRemoteIpAddress2Value(String remoteIpAddress2Value)
            throws JNCException {
        setRemoteIpAddress2Value(new Ipv4Address(remoteIpAddress2Value));
    }

    /**
     * Unsets the value for child leaf "remote-ip-address2".
     */
    public void unsetRemoteIpAddress2Value() throws JNCException {
        delete("remote-ip-address2");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "remote-ip-address2" leaf will not have a value.
     */
    public void addRemoteIpAddress2() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-ip-address2",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "remote-ip-address2" with operation "replace".
     */
    public void markRemoteIpAddress2Replace() throws JNCException {
        markLeafReplace("remoteIpAddress2");
    }

    /**
     * Marks the leaf "remote-ip-address2" with operation "merge".
     */
    public void markRemoteIpAddress2Merge() throws JNCException {
        markLeafMerge("remoteIpAddress2");
    }

    /**
     * Marks the leaf "remote-ip-address2" with operation "create".
     */
    public void markRemoteIpAddress2Create() throws JNCException {
        markLeafCreate("remoteIpAddress2");
    }

    /**
     * Marks the leaf "remote-ip-address2" with operation "delete".
     */
    public void markRemoteIpAddress2Delete() throws JNCException {
        markLeafDelete("remoteIpAddress2");
    }

    /* Access methods for optional leaf child: "remote-port2". */

    /**
     * Gets the value for child leaf "remote-port2".
     * @return The value of the leaf.
     */
    public YangUInt16 getRemotePort2Value() throws JNCException {
        YangUInt16 remotePort2 = (YangUInt16)getValue("remote-port2");
        if (remotePort2 == null) {
            remotePort2 = new YangUInt16("0");  // default
        }
        return remotePort2;
    }

    /**
     * Sets the value for child leaf "remote-port2",
     * using instance of generated typedef class.
     * @param remotePort2Value The value to set.
     * @param remotePort2Value used during instantiation.
     */
    public void setRemotePort2Value(YangUInt16 remotePort2Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-port2",
            remotePort2Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "remote-port2",
     * using Java primitive values.
     * @param remotePort2Value used during instantiation.
     */
    public void setRemotePort2Value(int remotePort2Value) throws JNCException {
        setRemotePort2Value(new YangUInt16(remotePort2Value));
    }

    /**
     * Sets the value for child leaf "remote-port2",
     * using a String value.
     * @param remotePort2Value used during instantiation.
     */
    public void setRemotePort2Value(String remotePort2Value)
            throws JNCException {
        setRemotePort2Value(new YangUInt16(remotePort2Value));
    }

    /**
     * Unsets the value for child leaf "remote-port2".
     */
    public void unsetRemotePort2Value() throws JNCException {
        delete("remote-port2");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "remote-port2" leaf will not have a value.
     */
    public void addRemotePort2() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "remote-port2",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "remote-port2" with operation "replace".
     */
    public void markRemotePort2Replace() throws JNCException {
        markLeafReplace("remotePort2");
    }

    /**
     * Marks the leaf "remote-port2" with operation "merge".
     */
    public void markRemotePort2Merge() throws JNCException {
        markLeafMerge("remotePort2");
    }

    /**
     * Marks the leaf "remote-port2" with operation "create".
     */
    public void markRemotePort2Create() throws JNCException {
        markLeafCreate("remotePort2");
    }

    /**
     * Marks the leaf "remote-port2" with operation "delete".
     */
    public void markRemotePort2Delete() throws JNCException {
        markLeafDelete("remotePort2");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /* Access methods for optional leaf child: "streaming-fallback". */

    /**
     * Gets the value for child leaf "streaming-fallback".
     * @return The value of the leaf.
     */
    public YangEnumeration getStreamingFallbackValue() throws JNCException {
        YangEnumeration streamingFallback = (YangEnumeration)getValue("streaming-fallback");
        if (streamingFallback == null) {
            streamingFallback = new YangEnumeration("disable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return streamingFallback;
    }

    /**
     * Sets the value for child leaf "streaming-fallback",
     * using instance of generated typedef class.
     * @param streamingFallbackValue The value to set.
     * @param streamingFallbackValue used during instantiation.
     */
    public void setStreamingFallbackValue(YangEnumeration streamingFallbackValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "streaming-fallback",
            streamingFallbackValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "streaming-fallback",
     * using a String value.
     * @param streamingFallbackValue used during instantiation.
     */
    public void setStreamingFallbackValue(String streamingFallbackValue)
            throws JNCException {
        setStreamingFallbackValue(new YangEnumeration(streamingFallbackValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "streaming-fallback".
     */
    public void unsetStreamingFallbackValue() throws JNCException {
        delete("streaming-fallback");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "streaming-fallback" leaf will not have a value.
     */
    public void addStreamingFallback() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "streaming-fallback",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "streaming-fallback" with operation "replace".
     */
    public void markStreamingFallbackReplace() throws JNCException {
        markLeafReplace("streamingFallback");
    }

    /**
     * Marks the leaf "streaming-fallback" with operation "merge".
     */
    public void markStreamingFallbackMerge() throws JNCException {
        markLeafMerge("streamingFallback");
    }

    /**
     * Marks the leaf "streaming-fallback" with operation "create".
     */
    public void markStreamingFallbackCreate() throws JNCException {
        markLeafCreate("streamingFallback");
    }

    /**
     * Marks the leaf "streaming-fallback" with operation "delete".
     */
    public void markStreamingFallbackDelete() throws JNCException {
        markLeafDelete("streamingFallback");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
