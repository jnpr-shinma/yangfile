/* 
 * @(#)MmeDiameterProfile.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.diameter;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/diameter/mme-diameter-profile"
 * <p>
 * See line 108 in
 * dcConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeDiameterProfile extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeDiameterProfile object.
     */
    public MmeDiameterProfile() {
        super(Epc.NAMESPACE, "mme-diameter-profile");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeDiameterProfile clone() {
        return (MmeDiameterProfile)cloneContent(new MmeDiameterProfile());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeDiameterProfile cloneShallow() {
        return (MmeDiameterProfile)cloneShallowContent(new MmeDiameterProfile());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "sctp-profile",
            "mme-realm",
            "watchdog-timer",
            "reconnect-timer",
            "peer-state-timer",
            "dscp-mark",
            "peer-selection-alg",
        };
    }

    /* Access methods for optional leaf child: "sctp-profile". */

    /**
     * Gets the value for child leaf "sctp-profile".
     * @return The value of the leaf.
     */
    public YangString getSctpProfileValue() throws JNCException {
        return (YangString)getValue("sctp-profile");
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using instance of generated typedef class.
     * @param sctpProfileValue The value to set.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(YangString sctpProfileValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            sctpProfileValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using a String value.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(String sctpProfileValue)
            throws JNCException {
        setSctpProfileValue(new YangString(sctpProfileValue));
    }

    /**
     * Unsets the value for child leaf "sctp-profile".
     */
    public void unsetSctpProfileValue() throws JNCException {
        delete("sctp-profile");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sctp-profile" leaf will not have a value.
     */
    public void addSctpProfile() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sctp-profile" with operation "replace".
     */
    public void markSctpProfileReplace() throws JNCException {
        markLeafReplace("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "merge".
     */
    public void markSctpProfileMerge() throws JNCException {
        markLeafMerge("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "create".
     */
    public void markSctpProfileCreate() throws JNCException {
        markLeafCreate("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "delete".
     */
    public void markSctpProfileDelete() throws JNCException {
        markLeafDelete("sctpProfile");
    }

    /* Access methods for optional leaf child: "mme-realm". */

    /**
     * Gets the value for child leaf "mme-realm".
     * @return The value of the leaf.
     */
    public YangString getMmeRealmValue() throws JNCException {
        return (YangString)getValue("mme-realm");
    }

    /**
     * Sets the value for child leaf "mme-realm",
     * using instance of generated typedef class.
     * @param mmeRealmValue The value to set.
     * @param mmeRealmValue used during instantiation.
     */
    public void setMmeRealmValue(YangString mmeRealmValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mme-realm",
            mmeRealmValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mme-realm",
     * using a String value.
     * @param mmeRealmValue used during instantiation.
     */
    public void setMmeRealmValue(String mmeRealmValue) throws JNCException {
        setMmeRealmValue(new YangString(mmeRealmValue));
    }

    /**
     * Unsets the value for child leaf "mme-realm".
     */
    public void unsetMmeRealmValue() throws JNCException {
        delete("mme-realm");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mme-realm" leaf will not have a value.
     */
    public void addMmeRealm() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mme-realm",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mme-realm" with operation "replace".
     */
    public void markMmeRealmReplace() throws JNCException {
        markLeafReplace("mmeRealm");
    }

    /**
     * Marks the leaf "mme-realm" with operation "merge".
     */
    public void markMmeRealmMerge() throws JNCException {
        markLeafMerge("mmeRealm");
    }

    /**
     * Marks the leaf "mme-realm" with operation "create".
     */
    public void markMmeRealmCreate() throws JNCException {
        markLeafCreate("mmeRealm");
    }

    /**
     * Marks the leaf "mme-realm" with operation "delete".
     */
    public void markMmeRealmDelete() throws JNCException {
        markLeafDelete("mmeRealm");
    }

    /* Access methods for optional leaf child: "watchdog-timer". */

    /**
     * Gets the value for child leaf "watchdog-timer".
     * @return The value of the leaf.
     */
    public YangUInt16 getWatchdogTimerValue() throws JNCException {
        YangUInt16 watchdogTimer = (YangUInt16)getValue("watchdog-timer");
        if (watchdogTimer == null) {
            watchdogTimer = new YangUInt16("30");  // default
        }
        return watchdogTimer;
    }

    /**
     * Sets the value for child leaf "watchdog-timer",
     * using instance of generated typedef class.
     * @param watchdogTimerValue The value to set.
     * @param watchdogTimerValue used during instantiation.
     */
    public void setWatchdogTimerValue(YangUInt16 watchdogTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "watchdog-timer",
            watchdogTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "watchdog-timer",
     * using Java primitive values.
     * @param watchdogTimerValue used during instantiation.
     */
    public void setWatchdogTimerValue(int watchdogTimerValue)
            throws JNCException {
        setWatchdogTimerValue(new YangUInt16(watchdogTimerValue));
    }

    /**
     * Sets the value for child leaf "watchdog-timer",
     * using a String value.
     * @param watchdogTimerValue used during instantiation.
     */
    public void setWatchdogTimerValue(String watchdogTimerValue)
            throws JNCException {
        setWatchdogTimerValue(new YangUInt16(watchdogTimerValue));
    }

    /**
     * Unsets the value for child leaf "watchdog-timer".
     */
    public void unsetWatchdogTimerValue() throws JNCException {
        delete("watchdog-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "watchdog-timer" leaf will not have a value.
     */
    public void addWatchdogTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "watchdog-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "watchdog-timer" with operation "replace".
     */
    public void markWatchdogTimerReplace() throws JNCException {
        markLeafReplace("watchdogTimer");
    }

    /**
     * Marks the leaf "watchdog-timer" with operation "merge".
     */
    public void markWatchdogTimerMerge() throws JNCException {
        markLeafMerge("watchdogTimer");
    }

    /**
     * Marks the leaf "watchdog-timer" with operation "create".
     */
    public void markWatchdogTimerCreate() throws JNCException {
        markLeafCreate("watchdogTimer");
    }

    /**
     * Marks the leaf "watchdog-timer" with operation "delete".
     */
    public void markWatchdogTimerDelete() throws JNCException {
        markLeafDelete("watchdogTimer");
    }

    /* Access methods for optional leaf child: "reconnect-timer". */

    /**
     * Gets the value for child leaf "reconnect-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getReconnectTimerValue() throws JNCException {
        YangUInt8 reconnectTimer = (YangUInt8)getValue("reconnect-timer");
        if (reconnectTimer == null) {
            reconnectTimer = new YangUInt8("30");  // default
        }
        return reconnectTimer;
    }

    /**
     * Sets the value for child leaf "reconnect-timer",
     * using instance of generated typedef class.
     * @param reconnectTimerValue The value to set.
     * @param reconnectTimerValue used during instantiation.
     */
    public void setReconnectTimerValue(YangUInt8 reconnectTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reconnect-timer",
            reconnectTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reconnect-timer",
     * using Java primitive values.
     * @param reconnectTimerValue used during instantiation.
     */
    public void setReconnectTimerValue(short reconnectTimerValue)
            throws JNCException {
        setReconnectTimerValue(new YangUInt8(reconnectTimerValue));
    }

    /**
     * Sets the value for child leaf "reconnect-timer",
     * using a String value.
     * @param reconnectTimerValue used during instantiation.
     */
    public void setReconnectTimerValue(String reconnectTimerValue)
            throws JNCException {
        setReconnectTimerValue(new YangUInt8(reconnectTimerValue));
    }

    /**
     * Unsets the value for child leaf "reconnect-timer".
     */
    public void unsetReconnectTimerValue() throws JNCException {
        delete("reconnect-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reconnect-timer" leaf will not have a value.
     */
    public void addReconnectTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reconnect-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reconnect-timer" with operation "replace".
     */
    public void markReconnectTimerReplace() throws JNCException {
        markLeafReplace("reconnectTimer");
    }

    /**
     * Marks the leaf "reconnect-timer" with operation "merge".
     */
    public void markReconnectTimerMerge() throws JNCException {
        markLeafMerge("reconnectTimer");
    }

    /**
     * Marks the leaf "reconnect-timer" with operation "create".
     */
    public void markReconnectTimerCreate() throws JNCException {
        markLeafCreate("reconnectTimer");
    }

    /**
     * Marks the leaf "reconnect-timer" with operation "delete".
     */
    public void markReconnectTimerDelete() throws JNCException {
        markLeafDelete("reconnectTimer");
    }

    /* Access methods for optional leaf child: "peer-state-timer". */

    /**
     * Gets the value for child leaf "peer-state-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getPeerStateTimerValue() throws JNCException {
        YangUInt8 peerStateTimer = (YangUInt8)getValue("peer-state-timer");
        if (peerStateTimer == null) {
            peerStateTimer = new YangUInt8("30");  // default
        }
        return peerStateTimer;
    }

    /**
     * Sets the value for child leaf "peer-state-timer",
     * using instance of generated typedef class.
     * @param peerStateTimerValue The value to set.
     * @param peerStateTimerValue used during instantiation.
     */
    public void setPeerStateTimerValue(YangUInt8 peerStateTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "peer-state-timer",
            peerStateTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "peer-state-timer",
     * using Java primitive values.
     * @param peerStateTimerValue used during instantiation.
     */
    public void setPeerStateTimerValue(short peerStateTimerValue)
            throws JNCException {
        setPeerStateTimerValue(new YangUInt8(peerStateTimerValue));
    }

    /**
     * Sets the value for child leaf "peer-state-timer",
     * using a String value.
     * @param peerStateTimerValue used during instantiation.
     */
    public void setPeerStateTimerValue(String peerStateTimerValue)
            throws JNCException {
        setPeerStateTimerValue(new YangUInt8(peerStateTimerValue));
    }

    /**
     * Unsets the value for child leaf "peer-state-timer".
     */
    public void unsetPeerStateTimerValue() throws JNCException {
        delete("peer-state-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "peer-state-timer" leaf will not have a value.
     */
    public void addPeerStateTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "peer-state-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "peer-state-timer" with operation "replace".
     */
    public void markPeerStateTimerReplace() throws JNCException {
        markLeafReplace("peerStateTimer");
    }

    /**
     * Marks the leaf "peer-state-timer" with operation "merge".
     */
    public void markPeerStateTimerMerge() throws JNCException {
        markLeafMerge("peerStateTimer");
    }

    /**
     * Marks the leaf "peer-state-timer" with operation "create".
     */
    public void markPeerStateTimerCreate() throws JNCException {
        markLeafCreate("peerStateTimer");
    }

    /**
     * Marks the leaf "peer-state-timer" with operation "delete".
     */
    public void markPeerStateTimerDelete() throws JNCException {
        markLeafDelete("peerStateTimer");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /* Access methods for optional leaf child: "peer-selection-alg". */

    /**
     * Gets the value for child leaf "peer-selection-alg".
     * @return The value of the leaf.
     */
    public YangEnumeration getPeerSelectionAlgValue() throws JNCException {
        YangEnumeration peerSelectionAlg = (YangEnumeration)getValue("peer-selection-alg");
        if (peerSelectionAlg == null) {
            peerSelectionAlg = new YangEnumeration("load-based", new String[] {  // default
                "load-based",
                "round-robin",
            });
        }
        return peerSelectionAlg;
    }

    /**
     * Sets the value for child leaf "peer-selection-alg",
     * using instance of generated typedef class.
     * @param peerSelectionAlgValue The value to set.
     * @param peerSelectionAlgValue used during instantiation.
     */
    public void setPeerSelectionAlgValue(YangEnumeration peerSelectionAlgValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "peer-selection-alg",
            peerSelectionAlgValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "peer-selection-alg",
     * using a String value.
     * @param peerSelectionAlgValue used during instantiation.
     */
    public void setPeerSelectionAlgValue(String peerSelectionAlgValue)
            throws JNCException {
        setPeerSelectionAlgValue(new YangEnumeration(peerSelectionAlgValue, new String[] {
             "load-based",
             "round-robin",
        }));
    }

    /**
     * Unsets the value for child leaf "peer-selection-alg".
     */
    public void unsetPeerSelectionAlgValue() throws JNCException {
        delete("peer-selection-alg");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "peer-selection-alg" leaf will not have a value.
     */
    public void addPeerSelectionAlg() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "peer-selection-alg",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "peer-selection-alg" with operation "replace".
     */
    public void markPeerSelectionAlgReplace() throws JNCException {
        markLeafReplace("peerSelectionAlg");
    }

    /**
     * Marks the leaf "peer-selection-alg" with operation "merge".
     */
    public void markPeerSelectionAlgMerge() throws JNCException {
        markLeafMerge("peerSelectionAlg");
    }

    /**
     * Marks the leaf "peer-selection-alg" with operation "create".
     */
    public void markPeerSelectionAlgCreate() throws JNCException {
        markLeafCreate("peerSelectionAlg");
    }

    /**
     * Marks the leaf "peer-selection-alg" with operation "delete".
     */
    public void markPeerSelectionAlgDelete() throws JNCException {
        markLeafDelete("peerSelectionAlg");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
