/* 
 * @(#)RemoteDest.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.ss7;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/ss7/remote-dest"
 * <p>
 * See line 272 in
 * sigtranCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class RemoteDest extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty RemoteDest object.
     */
    public RemoteDest() {
        super(Epc.NAMESPACE, "remote-dest");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public RemoteDest clone() {
        return (RemoteDest)cloneContent(new RemoteDest());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public RemoteDest cloneShallow() {
        return (RemoteDest)cloneShallowContent(new RemoteDest());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "destination-point-code",
            "location",
            "service",
            "sccp-state",
            "m3ua-state",
            "reachable-peer",
            "unreachable-peer",
            "restricted-peer",
            "rout-network-failure",
            "rout-unequip-sccp",
            "rout-network-congest",
            "unequip-sccp",
            "network-congest",
            "network-failure",
            "msu-tx",
            "rf-msu-congest",
            "rf-msu-unroutable",
            "user-part-unavailable",
            "user-part-inaccessible",
            "msu-rtx",
            "user-part-unequipped",
        };
    }

    /* Access methods for optional leaf child: "destination-point-code". */

    /**
     * Gets the value for child leaf "destination-point-code".
     * @return The value of the leaf.
     */
    public YangString getDestinationPointCodeValue() throws JNCException {
        return (YangString)getValue("destination-point-code");
    }

    /**
     * Sets the value for child leaf "destination-point-code",
     * using instance of generated typedef class.
     * @param destinationPointCodeValue The value to set.
     * @param destinationPointCodeValue used during instantiation.
     */
    public void setDestinationPointCodeValue(YangString destinationPointCodeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "destination-point-code",
            destinationPointCodeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "destination-point-code",
     * using a String value.
     * @param destinationPointCodeValue used during instantiation.
     */
    public void setDestinationPointCodeValue(String destinationPointCodeValue)
            throws JNCException {
        setDestinationPointCodeValue(new YangString(destinationPointCodeValue));
    }

    /**
     * Unsets the value for child leaf "destination-point-code".
     */
    public void unsetDestinationPointCodeValue() throws JNCException {
        delete("destination-point-code");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "destination-point-code" leaf will not have a value.
     */
    public void addDestinationPointCode() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "destination-point-code",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "destination-point-code" with operation "replace".
     */
    public void markDestinationPointCodeReplace() throws JNCException {
        markLeafReplace("destinationPointCode");
    }

    /**
     * Marks the leaf "destination-point-code" with operation "merge".
     */
    public void markDestinationPointCodeMerge() throws JNCException {
        markLeafMerge("destinationPointCode");
    }

    /**
     * Marks the leaf "destination-point-code" with operation "create".
     */
    public void markDestinationPointCodeCreate() throws JNCException {
        markLeafCreate("destinationPointCode");
    }

    /**
     * Marks the leaf "destination-point-code" with operation "delete".
     */
    public void markDestinationPointCodeDelete() throws JNCException {
        markLeafDelete("destinationPointCode");
    }

    /* Access methods for optional leaf child: "location". */

    /**
     * Gets the value for child leaf "location".
     * @return The value of the leaf.
     */
    public YangString getLocationValue() throws JNCException {
        return (YangString)getValue("location");
    }

    /**
     * Sets the value for child leaf "location",
     * using instance of generated typedef class.
     * @param locationValue The value to set.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(YangString locationValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            locationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location",
     * using a String value.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(String locationValue) throws JNCException {
        setLocationValue(new YangString(locationValue));
    }

    /**
     * Unsets the value for child leaf "location".
     */
    public void unsetLocationValue() throws JNCException {
        delete("location");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location" leaf will not have a value.
     */
    public void addLocation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location" with operation "replace".
     */
    public void markLocationReplace() throws JNCException {
        markLeafReplace("location");
    }

    /**
     * Marks the leaf "location" with operation "merge".
     */
    public void markLocationMerge() throws JNCException {
        markLeafMerge("location");
    }

    /**
     * Marks the leaf "location" with operation "create".
     */
    public void markLocationCreate() throws JNCException {
        markLeafCreate("location");
    }

    /**
     * Marks the leaf "location" with operation "delete".
     */
    public void markLocationDelete() throws JNCException {
        markLeafDelete("location");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "sccp-state". */

    /**
     * Gets the value for child leaf "sccp-state".
     * @return The value of the leaf.
     */
    public YangString getSccpStateValue() throws JNCException {
        return (YangString)getValue("sccp-state");
    }

    /**
     * Sets the value for child leaf "sccp-state",
     * using instance of generated typedef class.
     * @param sccpStateValue The value to set.
     * @param sccpStateValue used during instantiation.
     */
    public void setSccpStateValue(YangString sccpStateValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-state",
            sccpStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-state",
     * using a String value.
     * @param sccpStateValue used during instantiation.
     */
    public void setSccpStateValue(String sccpStateValue) throws JNCException {
        setSccpStateValue(new YangString(sccpStateValue));
    }

    /**
     * Unsets the value for child leaf "sccp-state".
     */
    public void unsetSccpStateValue() throws JNCException {
        delete("sccp-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-state" leaf will not have a value.
     */
    public void addSccpState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-state" with operation "replace".
     */
    public void markSccpStateReplace() throws JNCException {
        markLeafReplace("sccpState");
    }

    /**
     * Marks the leaf "sccp-state" with operation "merge".
     */
    public void markSccpStateMerge() throws JNCException {
        markLeafMerge("sccpState");
    }

    /**
     * Marks the leaf "sccp-state" with operation "create".
     */
    public void markSccpStateCreate() throws JNCException {
        markLeafCreate("sccpState");
    }

    /**
     * Marks the leaf "sccp-state" with operation "delete".
     */
    public void markSccpStateDelete() throws JNCException {
        markLeafDelete("sccpState");
    }

    /* Access methods for optional leaf child: "m3ua-state". */

    /**
     * Gets the value for child leaf "m3ua-state".
     * @return The value of the leaf.
     */
    public YangString getM3uaStateValue() throws JNCException {
        return (YangString)getValue("m3ua-state");
    }

    /**
     * Sets the value for child leaf "m3ua-state",
     * using instance of generated typedef class.
     * @param m3uaStateValue The value to set.
     * @param m3uaStateValue used during instantiation.
     */
    public void setM3uaStateValue(YangString m3uaStateValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "m3ua-state",
            m3uaStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "m3ua-state",
     * using a String value.
     * @param m3uaStateValue used during instantiation.
     */
    public void setM3uaStateValue(String m3uaStateValue) throws JNCException {
        setM3uaStateValue(new YangString(m3uaStateValue));
    }

    /**
     * Unsets the value for child leaf "m3ua-state".
     */
    public void unsetM3uaStateValue() throws JNCException {
        delete("m3ua-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "m3ua-state" leaf will not have a value.
     */
    public void addM3uaState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "m3ua-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "m3ua-state" with operation "replace".
     */
    public void markM3uaStateReplace() throws JNCException {
        markLeafReplace("m3uaState");
    }

    /**
     * Marks the leaf "m3ua-state" with operation "merge".
     */
    public void markM3uaStateMerge() throws JNCException {
        markLeafMerge("m3uaState");
    }

    /**
     * Marks the leaf "m3ua-state" with operation "create".
     */
    public void markM3uaStateCreate() throws JNCException {
        markLeafCreate("m3uaState");
    }

    /**
     * Marks the leaf "m3ua-state" with operation "delete".
     */
    public void markM3uaStateDelete() throws JNCException {
        markLeafDelete("m3uaState");
    }

    /* Access methods for optional leaf child: "reachable-peer". */

    /**
     * Gets the value for child leaf "reachable-peer".
     * @return The value of the leaf.
     */
    public YangString getReachablePeerValue() throws JNCException {
        return (YangString)getValue("reachable-peer");
    }

    /**
     * Sets the value for child leaf "reachable-peer",
     * using instance of generated typedef class.
     * @param reachablePeerValue The value to set.
     * @param reachablePeerValue used during instantiation.
     */
    public void setReachablePeerValue(YangString reachablePeerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reachable-peer",
            reachablePeerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reachable-peer",
     * using a String value.
     * @param reachablePeerValue used during instantiation.
     */
    public void setReachablePeerValue(String reachablePeerValue)
            throws JNCException {
        setReachablePeerValue(new YangString(reachablePeerValue));
    }

    /**
     * Unsets the value for child leaf "reachable-peer".
     */
    public void unsetReachablePeerValue() throws JNCException {
        delete("reachable-peer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reachable-peer" leaf will not have a value.
     */
    public void addReachablePeer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reachable-peer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reachable-peer" with operation "replace".
     */
    public void markReachablePeerReplace() throws JNCException {
        markLeafReplace("reachablePeer");
    }

    /**
     * Marks the leaf "reachable-peer" with operation "merge".
     */
    public void markReachablePeerMerge() throws JNCException {
        markLeafMerge("reachablePeer");
    }

    /**
     * Marks the leaf "reachable-peer" with operation "create".
     */
    public void markReachablePeerCreate() throws JNCException {
        markLeafCreate("reachablePeer");
    }

    /**
     * Marks the leaf "reachable-peer" with operation "delete".
     */
    public void markReachablePeerDelete() throws JNCException {
        markLeafDelete("reachablePeer");
    }

    /* Access methods for optional leaf child: "unreachable-peer". */

    /**
     * Gets the value for child leaf "unreachable-peer".
     * @return The value of the leaf.
     */
    public YangString getUnreachablePeerValue() throws JNCException {
        return (YangString)getValue("unreachable-peer");
    }

    /**
     * Sets the value for child leaf "unreachable-peer",
     * using instance of generated typedef class.
     * @param unreachablePeerValue The value to set.
     * @param unreachablePeerValue used during instantiation.
     */
    public void setUnreachablePeerValue(YangString unreachablePeerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unreachable-peer",
            unreachablePeerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "unreachable-peer",
     * using a String value.
     * @param unreachablePeerValue used during instantiation.
     */
    public void setUnreachablePeerValue(String unreachablePeerValue)
            throws JNCException {
        setUnreachablePeerValue(new YangString(unreachablePeerValue));
    }

    /**
     * Unsets the value for child leaf "unreachable-peer".
     */
    public void unsetUnreachablePeerValue() throws JNCException {
        delete("unreachable-peer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "unreachable-peer" leaf will not have a value.
     */
    public void addUnreachablePeer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unreachable-peer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "unreachable-peer" with operation "replace".
     */
    public void markUnreachablePeerReplace() throws JNCException {
        markLeafReplace("unreachablePeer");
    }

    /**
     * Marks the leaf "unreachable-peer" with operation "merge".
     */
    public void markUnreachablePeerMerge() throws JNCException {
        markLeafMerge("unreachablePeer");
    }

    /**
     * Marks the leaf "unreachable-peer" with operation "create".
     */
    public void markUnreachablePeerCreate() throws JNCException {
        markLeafCreate("unreachablePeer");
    }

    /**
     * Marks the leaf "unreachable-peer" with operation "delete".
     */
    public void markUnreachablePeerDelete() throws JNCException {
        markLeafDelete("unreachablePeer");
    }

    /* Access methods for optional leaf child: "restricted-peer". */

    /**
     * Gets the value for child leaf "restricted-peer".
     * @return The value of the leaf.
     */
    public YangString getRestrictedPeerValue() throws JNCException {
        return (YangString)getValue("restricted-peer");
    }

    /**
     * Sets the value for child leaf "restricted-peer",
     * using instance of generated typedef class.
     * @param restrictedPeerValue The value to set.
     * @param restrictedPeerValue used during instantiation.
     */
    public void setRestrictedPeerValue(YangString restrictedPeerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "restricted-peer",
            restrictedPeerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "restricted-peer",
     * using a String value.
     * @param restrictedPeerValue used during instantiation.
     */
    public void setRestrictedPeerValue(String restrictedPeerValue)
            throws JNCException {
        setRestrictedPeerValue(new YangString(restrictedPeerValue));
    }

    /**
     * Unsets the value for child leaf "restricted-peer".
     */
    public void unsetRestrictedPeerValue() throws JNCException {
        delete("restricted-peer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "restricted-peer" leaf will not have a value.
     */
    public void addRestrictedPeer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "restricted-peer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "restricted-peer" with operation "replace".
     */
    public void markRestrictedPeerReplace() throws JNCException {
        markLeafReplace("restrictedPeer");
    }

    /**
     * Marks the leaf "restricted-peer" with operation "merge".
     */
    public void markRestrictedPeerMerge() throws JNCException {
        markLeafMerge("restrictedPeer");
    }

    /**
     * Marks the leaf "restricted-peer" with operation "create".
     */
    public void markRestrictedPeerCreate() throws JNCException {
        markLeafCreate("restrictedPeer");
    }

    /**
     * Marks the leaf "restricted-peer" with operation "delete".
     */
    public void markRestrictedPeerDelete() throws JNCException {
        markLeafDelete("restrictedPeer");
    }

    /* Access methods for optional leaf child: "rout-network-failure". */

    /**
     * Gets the value for child leaf "rout-network-failure".
     * @return The value of the leaf.
     */
    public YangUInt32 getRoutNetworkFailureValue() throws JNCException {
        return (YangUInt32)getValue("rout-network-failure");
    }

    /**
     * Sets the value for child leaf "rout-network-failure",
     * using instance of generated typedef class.
     * @param routNetworkFailureValue The value to set.
     * @param routNetworkFailureValue used during instantiation.
     */
    public void setRoutNetworkFailureValue(YangUInt32 routNetworkFailureValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-network-failure",
            routNetworkFailureValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rout-network-failure",
     * using Java primitive values.
     * @param routNetworkFailureValue used during instantiation.
     */
    public void setRoutNetworkFailureValue(long routNetworkFailureValue)
            throws JNCException {
        setRoutNetworkFailureValue(new YangUInt32(routNetworkFailureValue));
    }

    /**
     * Sets the value for child leaf "rout-network-failure",
     * using a String value.
     * @param routNetworkFailureValue used during instantiation.
     */
    public void setRoutNetworkFailureValue(String routNetworkFailureValue)
            throws JNCException {
        setRoutNetworkFailureValue(new YangUInt32(routNetworkFailureValue));
    }

    /**
     * Unsets the value for child leaf "rout-network-failure".
     */
    public void unsetRoutNetworkFailureValue() throws JNCException {
        delete("rout-network-failure");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rout-network-failure" leaf will not have a value.
     */
    public void addRoutNetworkFailure() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-network-failure",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rout-network-failure" with operation "replace".
     */
    public void markRoutNetworkFailureReplace() throws JNCException {
        markLeafReplace("routNetworkFailure");
    }

    /**
     * Marks the leaf "rout-network-failure" with operation "merge".
     */
    public void markRoutNetworkFailureMerge() throws JNCException {
        markLeafMerge("routNetworkFailure");
    }

    /**
     * Marks the leaf "rout-network-failure" with operation "create".
     */
    public void markRoutNetworkFailureCreate() throws JNCException {
        markLeafCreate("routNetworkFailure");
    }

    /**
     * Marks the leaf "rout-network-failure" with operation "delete".
     */
    public void markRoutNetworkFailureDelete() throws JNCException {
        markLeafDelete("routNetworkFailure");
    }

    /* Access methods for optional leaf child: "rout-unequip-sccp". */

    /**
     * Gets the value for child leaf "rout-unequip-sccp".
     * @return The value of the leaf.
     */
    public YangUInt32 getRoutUnequipSccpValue() throws JNCException {
        return (YangUInt32)getValue("rout-unequip-sccp");
    }

    /**
     * Sets the value for child leaf "rout-unequip-sccp",
     * using instance of generated typedef class.
     * @param routUnequipSccpValue The value to set.
     * @param routUnequipSccpValue used during instantiation.
     */
    public void setRoutUnequipSccpValue(YangUInt32 routUnequipSccpValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-unequip-sccp",
            routUnequipSccpValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rout-unequip-sccp",
     * using Java primitive values.
     * @param routUnequipSccpValue used during instantiation.
     */
    public void setRoutUnequipSccpValue(long routUnequipSccpValue)
            throws JNCException {
        setRoutUnequipSccpValue(new YangUInt32(routUnequipSccpValue));
    }

    /**
     * Sets the value for child leaf "rout-unequip-sccp",
     * using a String value.
     * @param routUnequipSccpValue used during instantiation.
     */
    public void setRoutUnequipSccpValue(String routUnequipSccpValue)
            throws JNCException {
        setRoutUnequipSccpValue(new YangUInt32(routUnequipSccpValue));
    }

    /**
     * Unsets the value for child leaf "rout-unequip-sccp".
     */
    public void unsetRoutUnequipSccpValue() throws JNCException {
        delete("rout-unequip-sccp");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rout-unequip-sccp" leaf will not have a value.
     */
    public void addRoutUnequipSccp() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-unequip-sccp",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rout-unequip-sccp" with operation "replace".
     */
    public void markRoutUnequipSccpReplace() throws JNCException {
        markLeafReplace("routUnequipSccp");
    }

    /**
     * Marks the leaf "rout-unequip-sccp" with operation "merge".
     */
    public void markRoutUnequipSccpMerge() throws JNCException {
        markLeafMerge("routUnequipSccp");
    }

    /**
     * Marks the leaf "rout-unequip-sccp" with operation "create".
     */
    public void markRoutUnequipSccpCreate() throws JNCException {
        markLeafCreate("routUnequipSccp");
    }

    /**
     * Marks the leaf "rout-unequip-sccp" with operation "delete".
     */
    public void markRoutUnequipSccpDelete() throws JNCException {
        markLeafDelete("routUnequipSccp");
    }

    /* Access methods for optional leaf child: "rout-network-congest". */

    /**
     * Gets the value for child leaf "rout-network-congest".
     * @return The value of the leaf.
     */
    public YangUInt32 getRoutNetworkCongestValue() throws JNCException {
        return (YangUInt32)getValue("rout-network-congest");
    }

    /**
     * Sets the value for child leaf "rout-network-congest",
     * using instance of generated typedef class.
     * @param routNetworkCongestValue The value to set.
     * @param routNetworkCongestValue used during instantiation.
     */
    public void setRoutNetworkCongestValue(YangUInt32 routNetworkCongestValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-network-congest",
            routNetworkCongestValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rout-network-congest",
     * using Java primitive values.
     * @param routNetworkCongestValue used during instantiation.
     */
    public void setRoutNetworkCongestValue(long routNetworkCongestValue)
            throws JNCException {
        setRoutNetworkCongestValue(new YangUInt32(routNetworkCongestValue));
    }

    /**
     * Sets the value for child leaf "rout-network-congest",
     * using a String value.
     * @param routNetworkCongestValue used during instantiation.
     */
    public void setRoutNetworkCongestValue(String routNetworkCongestValue)
            throws JNCException {
        setRoutNetworkCongestValue(new YangUInt32(routNetworkCongestValue));
    }

    /**
     * Unsets the value for child leaf "rout-network-congest".
     */
    public void unsetRoutNetworkCongestValue() throws JNCException {
        delete("rout-network-congest");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rout-network-congest" leaf will not have a value.
     */
    public void addRoutNetworkCongest() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rout-network-congest",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rout-network-congest" with operation "replace".
     */
    public void markRoutNetworkCongestReplace() throws JNCException {
        markLeafReplace("routNetworkCongest");
    }

    /**
     * Marks the leaf "rout-network-congest" with operation "merge".
     */
    public void markRoutNetworkCongestMerge() throws JNCException {
        markLeafMerge("routNetworkCongest");
    }

    /**
     * Marks the leaf "rout-network-congest" with operation "create".
     */
    public void markRoutNetworkCongestCreate() throws JNCException {
        markLeafCreate("routNetworkCongest");
    }

    /**
     * Marks the leaf "rout-network-congest" with operation "delete".
     */
    public void markRoutNetworkCongestDelete() throws JNCException {
        markLeafDelete("routNetworkCongest");
    }

    /* Access methods for optional leaf child: "unequip-sccp". */

    /**
     * Gets the value for child leaf "unequip-sccp".
     * @return The value of the leaf.
     */
    public YangUInt32 getUnequipSccpValue() throws JNCException {
        return (YangUInt32)getValue("unequip-sccp");
    }

    /**
     * Sets the value for child leaf "unequip-sccp",
     * using instance of generated typedef class.
     * @param unequipSccpValue The value to set.
     * @param unequipSccpValue used during instantiation.
     */
    public void setUnequipSccpValue(YangUInt32 unequipSccpValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unequip-sccp",
            unequipSccpValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "unequip-sccp",
     * using Java primitive values.
     * @param unequipSccpValue used during instantiation.
     */
    public void setUnequipSccpValue(long unequipSccpValue) throws JNCException {
        setUnequipSccpValue(new YangUInt32(unequipSccpValue));
    }

    /**
     * Sets the value for child leaf "unequip-sccp",
     * using a String value.
     * @param unequipSccpValue used during instantiation.
     */
    public void setUnequipSccpValue(String unequipSccpValue)
            throws JNCException {
        setUnequipSccpValue(new YangUInt32(unequipSccpValue));
    }

    /**
     * Unsets the value for child leaf "unequip-sccp".
     */
    public void unsetUnequipSccpValue() throws JNCException {
        delete("unequip-sccp");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "unequip-sccp" leaf will not have a value.
     */
    public void addUnequipSccp() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unequip-sccp",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "unequip-sccp" with operation "replace".
     */
    public void markUnequipSccpReplace() throws JNCException {
        markLeafReplace("unequipSccp");
    }

    /**
     * Marks the leaf "unequip-sccp" with operation "merge".
     */
    public void markUnequipSccpMerge() throws JNCException {
        markLeafMerge("unequipSccp");
    }

    /**
     * Marks the leaf "unequip-sccp" with operation "create".
     */
    public void markUnequipSccpCreate() throws JNCException {
        markLeafCreate("unequipSccp");
    }

    /**
     * Marks the leaf "unequip-sccp" with operation "delete".
     */
    public void markUnequipSccpDelete() throws JNCException {
        markLeafDelete("unequipSccp");
    }

    /* Access methods for optional leaf child: "network-congest". */

    /**
     * Gets the value for child leaf "network-congest".
     * @return The value of the leaf.
     */
    public YangUInt32 getNetworkCongestValue() throws JNCException {
        return (YangUInt32)getValue("network-congest");
    }

    /**
     * Sets the value for child leaf "network-congest",
     * using instance of generated typedef class.
     * @param networkCongestValue The value to set.
     * @param networkCongestValue used during instantiation.
     */
    public void setNetworkCongestValue(YangUInt32 networkCongestValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "network-congest",
            networkCongestValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "network-congest",
     * using Java primitive values.
     * @param networkCongestValue used during instantiation.
     */
    public void setNetworkCongestValue(long networkCongestValue)
            throws JNCException {
        setNetworkCongestValue(new YangUInt32(networkCongestValue));
    }

    /**
     * Sets the value for child leaf "network-congest",
     * using a String value.
     * @param networkCongestValue used during instantiation.
     */
    public void setNetworkCongestValue(String networkCongestValue)
            throws JNCException {
        setNetworkCongestValue(new YangUInt32(networkCongestValue));
    }

    /**
     * Unsets the value for child leaf "network-congest".
     */
    public void unsetNetworkCongestValue() throws JNCException {
        delete("network-congest");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "network-congest" leaf will not have a value.
     */
    public void addNetworkCongest() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "network-congest",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "network-congest" with operation "replace".
     */
    public void markNetworkCongestReplace() throws JNCException {
        markLeafReplace("networkCongest");
    }

    /**
     * Marks the leaf "network-congest" with operation "merge".
     */
    public void markNetworkCongestMerge() throws JNCException {
        markLeafMerge("networkCongest");
    }

    /**
     * Marks the leaf "network-congest" with operation "create".
     */
    public void markNetworkCongestCreate() throws JNCException {
        markLeafCreate("networkCongest");
    }

    /**
     * Marks the leaf "network-congest" with operation "delete".
     */
    public void markNetworkCongestDelete() throws JNCException {
        markLeafDelete("networkCongest");
    }

    /* Access methods for optional leaf child: "network-failure". */

    /**
     * Gets the value for child leaf "network-failure".
     * @return The value of the leaf.
     */
    public YangUInt32 getNetworkFailureValue() throws JNCException {
        return (YangUInt32)getValue("network-failure");
    }

    /**
     * Sets the value for child leaf "network-failure",
     * using instance of generated typedef class.
     * @param networkFailureValue The value to set.
     * @param networkFailureValue used during instantiation.
     */
    public void setNetworkFailureValue(YangUInt32 networkFailureValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "network-failure",
            networkFailureValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "network-failure",
     * using Java primitive values.
     * @param networkFailureValue used during instantiation.
     */
    public void setNetworkFailureValue(long networkFailureValue)
            throws JNCException {
        setNetworkFailureValue(new YangUInt32(networkFailureValue));
    }

    /**
     * Sets the value for child leaf "network-failure",
     * using a String value.
     * @param networkFailureValue used during instantiation.
     */
    public void setNetworkFailureValue(String networkFailureValue)
            throws JNCException {
        setNetworkFailureValue(new YangUInt32(networkFailureValue));
    }

    /**
     * Unsets the value for child leaf "network-failure".
     */
    public void unsetNetworkFailureValue() throws JNCException {
        delete("network-failure");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "network-failure" leaf will not have a value.
     */
    public void addNetworkFailure() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "network-failure",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "network-failure" with operation "replace".
     */
    public void markNetworkFailureReplace() throws JNCException {
        markLeafReplace("networkFailure");
    }

    /**
     * Marks the leaf "network-failure" with operation "merge".
     */
    public void markNetworkFailureMerge() throws JNCException {
        markLeafMerge("networkFailure");
    }

    /**
     * Marks the leaf "network-failure" with operation "create".
     */
    public void markNetworkFailureCreate() throws JNCException {
        markLeafCreate("networkFailure");
    }

    /**
     * Marks the leaf "network-failure" with operation "delete".
     */
    public void markNetworkFailureDelete() throws JNCException {
        markLeafDelete("networkFailure");
    }

    /* Access methods for optional leaf child: "msu-tx". */

    /**
     * Gets the value for child leaf "msu-tx".
     * @return The value of the leaf.
     */
    public YangUInt32 getMsuTxValue() throws JNCException {
        return (YangUInt32)getValue("msu-tx");
    }

    /**
     * Sets the value for child leaf "msu-tx",
     * using instance of generated typedef class.
     * @param msuTxValue The value to set.
     * @param msuTxValue used during instantiation.
     */
    public void setMsuTxValue(YangUInt32 msuTxValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msu-tx",
            msuTxValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "msu-tx",
     * using Java primitive values.
     * @param msuTxValue used during instantiation.
     */
    public void setMsuTxValue(long msuTxValue) throws JNCException {
        setMsuTxValue(new YangUInt32(msuTxValue));
    }

    /**
     * Sets the value for child leaf "msu-tx",
     * using a String value.
     * @param msuTxValue used during instantiation.
     */
    public void setMsuTxValue(String msuTxValue) throws JNCException {
        setMsuTxValue(new YangUInt32(msuTxValue));
    }

    /**
     * Unsets the value for child leaf "msu-tx".
     */
    public void unsetMsuTxValue() throws JNCException {
        delete("msu-tx");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "msu-tx" leaf will not have a value.
     */
    public void addMsuTx() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msu-tx",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "msu-tx" with operation "replace".
     */
    public void markMsuTxReplace() throws JNCException {
        markLeafReplace("msuTx");
    }

    /**
     * Marks the leaf "msu-tx" with operation "merge".
     */
    public void markMsuTxMerge() throws JNCException {
        markLeafMerge("msuTx");
    }

    /**
     * Marks the leaf "msu-tx" with operation "create".
     */
    public void markMsuTxCreate() throws JNCException {
        markLeafCreate("msuTx");
    }

    /**
     * Marks the leaf "msu-tx" with operation "delete".
     */
    public void markMsuTxDelete() throws JNCException {
        markLeafDelete("msuTx");
    }

    /* Access methods for optional leaf child: "rf-msu-congest". */

    /**
     * Gets the value for child leaf "rf-msu-congest".
     * @return The value of the leaf.
     */
    public YangUInt32 getRfMsuCongestValue() throws JNCException {
        return (YangUInt32)getValue("rf-msu-congest");
    }

    /**
     * Sets the value for child leaf "rf-msu-congest",
     * using instance of generated typedef class.
     * @param rfMsuCongestValue The value to set.
     * @param rfMsuCongestValue used during instantiation.
     */
    public void setRfMsuCongestValue(YangUInt32 rfMsuCongestValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rf-msu-congest",
            rfMsuCongestValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rf-msu-congest",
     * using Java primitive values.
     * @param rfMsuCongestValue used during instantiation.
     */
    public void setRfMsuCongestValue(long rfMsuCongestValue)
            throws JNCException {
        setRfMsuCongestValue(new YangUInt32(rfMsuCongestValue));
    }

    /**
     * Sets the value for child leaf "rf-msu-congest",
     * using a String value.
     * @param rfMsuCongestValue used during instantiation.
     */
    public void setRfMsuCongestValue(String rfMsuCongestValue)
            throws JNCException {
        setRfMsuCongestValue(new YangUInt32(rfMsuCongestValue));
    }

    /**
     * Unsets the value for child leaf "rf-msu-congest".
     */
    public void unsetRfMsuCongestValue() throws JNCException {
        delete("rf-msu-congest");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rf-msu-congest" leaf will not have a value.
     */
    public void addRfMsuCongest() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rf-msu-congest",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rf-msu-congest" with operation "replace".
     */
    public void markRfMsuCongestReplace() throws JNCException {
        markLeafReplace("rfMsuCongest");
    }

    /**
     * Marks the leaf "rf-msu-congest" with operation "merge".
     */
    public void markRfMsuCongestMerge() throws JNCException {
        markLeafMerge("rfMsuCongest");
    }

    /**
     * Marks the leaf "rf-msu-congest" with operation "create".
     */
    public void markRfMsuCongestCreate() throws JNCException {
        markLeafCreate("rfMsuCongest");
    }

    /**
     * Marks the leaf "rf-msu-congest" with operation "delete".
     */
    public void markRfMsuCongestDelete() throws JNCException {
        markLeafDelete("rfMsuCongest");
    }

    /* Access methods for optional leaf child: "rf-msu-unroutable". */

    /**
     * Gets the value for child leaf "rf-msu-unroutable".
     * @return The value of the leaf.
     */
    public YangUInt32 getRfMsuUnroutableValue() throws JNCException {
        return (YangUInt32)getValue("rf-msu-unroutable");
    }

    /**
     * Sets the value for child leaf "rf-msu-unroutable",
     * using instance of generated typedef class.
     * @param rfMsuUnroutableValue The value to set.
     * @param rfMsuUnroutableValue used during instantiation.
     */
    public void setRfMsuUnroutableValue(YangUInt32 rfMsuUnroutableValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rf-msu-unroutable",
            rfMsuUnroutableValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rf-msu-unroutable",
     * using Java primitive values.
     * @param rfMsuUnroutableValue used during instantiation.
     */
    public void setRfMsuUnroutableValue(long rfMsuUnroutableValue)
            throws JNCException {
        setRfMsuUnroutableValue(new YangUInt32(rfMsuUnroutableValue));
    }

    /**
     * Sets the value for child leaf "rf-msu-unroutable",
     * using a String value.
     * @param rfMsuUnroutableValue used during instantiation.
     */
    public void setRfMsuUnroutableValue(String rfMsuUnroutableValue)
            throws JNCException {
        setRfMsuUnroutableValue(new YangUInt32(rfMsuUnroutableValue));
    }

    /**
     * Unsets the value for child leaf "rf-msu-unroutable".
     */
    public void unsetRfMsuUnroutableValue() throws JNCException {
        delete("rf-msu-unroutable");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rf-msu-unroutable" leaf will not have a value.
     */
    public void addRfMsuUnroutable() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rf-msu-unroutable",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rf-msu-unroutable" with operation "replace".
     */
    public void markRfMsuUnroutableReplace() throws JNCException {
        markLeafReplace("rfMsuUnroutable");
    }

    /**
     * Marks the leaf "rf-msu-unroutable" with operation "merge".
     */
    public void markRfMsuUnroutableMerge() throws JNCException {
        markLeafMerge("rfMsuUnroutable");
    }

    /**
     * Marks the leaf "rf-msu-unroutable" with operation "create".
     */
    public void markRfMsuUnroutableCreate() throws JNCException {
        markLeafCreate("rfMsuUnroutable");
    }

    /**
     * Marks the leaf "rf-msu-unroutable" with operation "delete".
     */
    public void markRfMsuUnroutableDelete() throws JNCException {
        markLeafDelete("rfMsuUnroutable");
    }

    /* Access methods for optional leaf child: "user-part-unavailable". */

    /**
     * Gets the value for child leaf "user-part-unavailable".
     * @return The value of the leaf.
     */
    public YangUInt32 getUserPartUnavailableValue() throws JNCException {
        return (YangUInt32)getValue("user-part-unavailable");
    }

    /**
     * Sets the value for child leaf "user-part-unavailable",
     * using instance of generated typedef class.
     * @param userPartUnavailableValue The value to set.
     * @param userPartUnavailableValue used during instantiation.
     */
    public void setUserPartUnavailableValue(YangUInt32 userPartUnavailableValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-unavailable",
            userPartUnavailableValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "user-part-unavailable",
     * using Java primitive values.
     * @param userPartUnavailableValue used during instantiation.
     */
    public void setUserPartUnavailableValue(long userPartUnavailableValue)
            throws JNCException {
        setUserPartUnavailableValue(new YangUInt32(userPartUnavailableValue));
    }

    /**
     * Sets the value for child leaf "user-part-unavailable",
     * using a String value.
     * @param userPartUnavailableValue used during instantiation.
     */
    public void setUserPartUnavailableValue(String userPartUnavailableValue)
            throws JNCException {
        setUserPartUnavailableValue(new YangUInt32(userPartUnavailableValue));
    }

    /**
     * Unsets the value for child leaf "user-part-unavailable".
     */
    public void unsetUserPartUnavailableValue() throws JNCException {
        delete("user-part-unavailable");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "user-part-unavailable" leaf will not have a value.
     */
    public void addUserPartUnavailable() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-unavailable",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "user-part-unavailable" with operation "replace".
     */
    public void markUserPartUnavailableReplace() throws JNCException {
        markLeafReplace("userPartUnavailable");
    }

    /**
     * Marks the leaf "user-part-unavailable" with operation "merge".
     */
    public void markUserPartUnavailableMerge() throws JNCException {
        markLeafMerge("userPartUnavailable");
    }

    /**
     * Marks the leaf "user-part-unavailable" with operation "create".
     */
    public void markUserPartUnavailableCreate() throws JNCException {
        markLeafCreate("userPartUnavailable");
    }

    /**
     * Marks the leaf "user-part-unavailable" with operation "delete".
     */
    public void markUserPartUnavailableDelete() throws JNCException {
        markLeafDelete("userPartUnavailable");
    }

    /* Access methods for optional leaf child: "user-part-inaccessible". */

    /**
     * Gets the value for child leaf "user-part-inaccessible".
     * @return The value of the leaf.
     */
    public YangUInt32 getUserPartInaccessibleValue() throws JNCException {
        return (YangUInt32)getValue("user-part-inaccessible");
    }

    /**
     * Sets the value for child leaf "user-part-inaccessible",
     * using instance of generated typedef class.
     * @param userPartInaccessibleValue The value to set.
     * @param userPartInaccessibleValue used during instantiation.
     */
    public void setUserPartInaccessibleValue(YangUInt32 userPartInaccessibleValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-inaccessible",
            userPartInaccessibleValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "user-part-inaccessible",
     * using Java primitive values.
     * @param userPartInaccessibleValue used during instantiation.
     */
    public void setUserPartInaccessibleValue(long userPartInaccessibleValue)
            throws JNCException {
        setUserPartInaccessibleValue(new YangUInt32(userPartInaccessibleValue));
    }

    /**
     * Sets the value for child leaf "user-part-inaccessible",
     * using a String value.
     * @param userPartInaccessibleValue used during instantiation.
     */
    public void setUserPartInaccessibleValue(String userPartInaccessibleValue)
            throws JNCException {
        setUserPartInaccessibleValue(new YangUInt32(userPartInaccessibleValue));
    }

    /**
     * Unsets the value for child leaf "user-part-inaccessible".
     */
    public void unsetUserPartInaccessibleValue() throws JNCException {
        delete("user-part-inaccessible");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "user-part-inaccessible" leaf will not have a value.
     */
    public void addUserPartInaccessible() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-inaccessible",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "user-part-inaccessible" with operation "replace".
     */
    public void markUserPartInaccessibleReplace() throws JNCException {
        markLeafReplace("userPartInaccessible");
    }

    /**
     * Marks the leaf "user-part-inaccessible" with operation "merge".
     */
    public void markUserPartInaccessibleMerge() throws JNCException {
        markLeafMerge("userPartInaccessible");
    }

    /**
     * Marks the leaf "user-part-inaccessible" with operation "create".
     */
    public void markUserPartInaccessibleCreate() throws JNCException {
        markLeafCreate("userPartInaccessible");
    }

    /**
     * Marks the leaf "user-part-inaccessible" with operation "delete".
     */
    public void markUserPartInaccessibleDelete() throws JNCException {
        markLeafDelete("userPartInaccessible");
    }

    /* Access methods for optional leaf child: "msu-rtx". */

    /**
     * Gets the value for child leaf "msu-rtx".
     * @return The value of the leaf.
     */
    public YangUInt32 getMsuRtxValue() throws JNCException {
        return (YangUInt32)getValue("msu-rtx");
    }

    /**
     * Sets the value for child leaf "msu-rtx",
     * using instance of generated typedef class.
     * @param msuRtxValue The value to set.
     * @param msuRtxValue used during instantiation.
     */
    public void setMsuRtxValue(YangUInt32 msuRtxValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msu-rtx",
            msuRtxValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "msu-rtx",
     * using Java primitive values.
     * @param msuRtxValue used during instantiation.
     */
    public void setMsuRtxValue(long msuRtxValue) throws JNCException {
        setMsuRtxValue(new YangUInt32(msuRtxValue));
    }

    /**
     * Sets the value for child leaf "msu-rtx",
     * using a String value.
     * @param msuRtxValue used during instantiation.
     */
    public void setMsuRtxValue(String msuRtxValue) throws JNCException {
        setMsuRtxValue(new YangUInt32(msuRtxValue));
    }

    /**
     * Unsets the value for child leaf "msu-rtx".
     */
    public void unsetMsuRtxValue() throws JNCException {
        delete("msu-rtx");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "msu-rtx" leaf will not have a value.
     */
    public void addMsuRtx() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "msu-rtx",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "msu-rtx" with operation "replace".
     */
    public void markMsuRtxReplace() throws JNCException {
        markLeafReplace("msuRtx");
    }

    /**
     * Marks the leaf "msu-rtx" with operation "merge".
     */
    public void markMsuRtxMerge() throws JNCException {
        markLeafMerge("msuRtx");
    }

    /**
     * Marks the leaf "msu-rtx" with operation "create".
     */
    public void markMsuRtxCreate() throws JNCException {
        markLeafCreate("msuRtx");
    }

    /**
     * Marks the leaf "msu-rtx" with operation "delete".
     */
    public void markMsuRtxDelete() throws JNCException {
        markLeafDelete("msuRtx");
    }

    /* Access methods for optional leaf child: "user-part-unequipped". */

    /**
     * Gets the value for child leaf "user-part-unequipped".
     * @return The value of the leaf.
     */
    public YangUInt32 getUserPartUnequippedValue() throws JNCException {
        return (YangUInt32)getValue("user-part-unequipped");
    }

    /**
     * Sets the value for child leaf "user-part-unequipped",
     * using instance of generated typedef class.
     * @param userPartUnequippedValue The value to set.
     * @param userPartUnequippedValue used during instantiation.
     */
    public void setUserPartUnequippedValue(YangUInt32 userPartUnequippedValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-unequipped",
            userPartUnequippedValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "user-part-unequipped",
     * using Java primitive values.
     * @param userPartUnequippedValue used during instantiation.
     */
    public void setUserPartUnequippedValue(long userPartUnequippedValue)
            throws JNCException {
        setUserPartUnequippedValue(new YangUInt32(userPartUnequippedValue));
    }

    /**
     * Sets the value for child leaf "user-part-unequipped",
     * using a String value.
     * @param userPartUnequippedValue used during instantiation.
     */
    public void setUserPartUnequippedValue(String userPartUnequippedValue)
            throws JNCException {
        setUserPartUnequippedValue(new YangUInt32(userPartUnequippedValue));
    }

    /**
     * Unsets the value for child leaf "user-part-unequipped".
     */
    public void unsetUserPartUnequippedValue() throws JNCException {
        delete("user-part-unequipped");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "user-part-unequipped" leaf will not have a value.
     */
    public void addUserPartUnequipped() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "user-part-unequipped",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "user-part-unequipped" with operation "replace".
     */
    public void markUserPartUnequippedReplace() throws JNCException {
        markLeafReplace("userPartUnequipped");
    }

    /**
     * Marks the leaf "user-part-unequipped" with operation "merge".
     */
    public void markUserPartUnequippedMerge() throws JNCException {
        markLeafMerge("userPartUnequipped");
    }

    /**
     * Marks the leaf "user-part-unequipped" with operation "create".
     */
    public void markUserPartUnequippedCreate() throws JNCException {
        markLeafCreate("userPartUnequipped");
    }

    /**
     * Marks the leaf "user-part-unequipped" with operation "delete".
     */
    public void markUserPartUnequippedDelete() throws JNCException {
        markLeafDelete("userPartUnequipped");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
