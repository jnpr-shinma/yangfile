/* 
 * @(#)MmeTcapProfile.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.ss7;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/ss7/mme-tcap-profile"
 * <p>
 * See line 19 in
 * tcapConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeTcapProfile extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeTcapProfile object.
     */
    public MmeTcapProfile() {
        super(Epc.NAMESPACE, "mme-tcap-profile");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeTcapProfile clone() {
        return (MmeTcapProfile)cloneContent(new MmeTcapProfile());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeTcapProfile cloneShallow() {
        return (MmeTcapProfile)cloneShallowContent(new MmeTcapProfile());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "nature-of-address",
            "sccp-class-of-operation",
            "e164-trans-type",
            "e164-mofsm-trans-type",
            "e212-trans-type",
            "e214-trans-type",
            "sccp-return-option",
            "hop-counter",
            "xudt-option",
            "max-map-transactions",
            "max-map-invokes",
            "max-cap-transactions",
            "max-cap-invokes",
        };
    }

    /* Access methods for optional leaf child: "nature-of-address". */

    /**
     * Gets the value for child leaf "nature-of-address".
     * @return The value of the leaf.
     */
    public YangEnumeration getNatureOfAddressValue() throws JNCException {
        YangEnumeration natureOfAddress = (YangEnumeration)getValue("nature-of-address");
        if (natureOfAddress == null) {
            natureOfAddress = new YangEnumeration("intl-num", new String[] {  // default
                "sub-num",
                "res-national-use",
                "nat-spec-num",
                "intl-num",
            });
        }
        return natureOfAddress;
    }

    /**
     * Sets the value for child leaf "nature-of-address",
     * using instance of generated typedef class.
     * @param natureOfAddressValue The value to set.
     * @param natureOfAddressValue used during instantiation.
     */
    public void setNatureOfAddressValue(YangEnumeration natureOfAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nature-of-address",
            natureOfAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nature-of-address",
     * using a String value.
     * @param natureOfAddressValue used during instantiation.
     */
    public void setNatureOfAddressValue(String natureOfAddressValue)
            throws JNCException {
        setNatureOfAddressValue(new YangEnumeration(natureOfAddressValue, new String[] {
             "sub-num",
             "res-national-use",
             "nat-spec-num",
             "intl-num",
        }));
    }

    /**
     * Unsets the value for child leaf "nature-of-address".
     */
    public void unsetNatureOfAddressValue() throws JNCException {
        delete("nature-of-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nature-of-address" leaf will not have a value.
     */
    public void addNatureOfAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nature-of-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nature-of-address" with operation "replace".
     */
    public void markNatureOfAddressReplace() throws JNCException {
        markLeafReplace("natureOfAddress");
    }

    /**
     * Marks the leaf "nature-of-address" with operation "merge".
     */
    public void markNatureOfAddressMerge() throws JNCException {
        markLeafMerge("natureOfAddress");
    }

    /**
     * Marks the leaf "nature-of-address" with operation "create".
     */
    public void markNatureOfAddressCreate() throws JNCException {
        markLeafCreate("natureOfAddress");
    }

    /**
     * Marks the leaf "nature-of-address" with operation "delete".
     */
    public void markNatureOfAddressDelete() throws JNCException {
        markLeafDelete("natureOfAddress");
    }

    /* Access methods for optional leaf child: "sccp-class-of-operation". */

    /**
     * Gets the value for child leaf "sccp-class-of-operation".
     * @return The value of the leaf.
     */
    public YangEnumeration getSccpClassOfOperationValue() throws JNCException {
        YangEnumeration sccpClassOfOperation = (YangEnumeration)getValue("sccp-class-of-operation");
        if (sccpClassOfOperation == null) {
            sccpClassOfOperation = new YangEnumeration("sequenced", new String[] {  // default
                "non-sequenced",
                "sequenced",
            });
        }
        return sccpClassOfOperation;
    }

    /**
     * Sets the value for child leaf "sccp-class-of-operation",
     * using instance of generated typedef class.
     * @param sccpClassOfOperationValue The value to set.
     * @param sccpClassOfOperationValue used during instantiation.
     */
    public void setSccpClassOfOperationValue(YangEnumeration sccpClassOfOperationValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-class-of-operation",
            sccpClassOfOperationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-class-of-operation",
     * using a String value.
     * @param sccpClassOfOperationValue used during instantiation.
     */
    public void setSccpClassOfOperationValue(String sccpClassOfOperationValue)
            throws JNCException {
        setSccpClassOfOperationValue(new YangEnumeration(sccpClassOfOperationValue, new String[] {
             "non-sequenced",
             "sequenced",
        }));
    }

    /**
     * Unsets the value for child leaf "sccp-class-of-operation".
     */
    public void unsetSccpClassOfOperationValue() throws JNCException {
        delete("sccp-class-of-operation");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-class-of-operation" leaf will not have a value.
     */
    public void addSccpClassOfOperation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-class-of-operation",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-class-of-operation" with operation "replace".
     */
    public void markSccpClassOfOperationReplace() throws JNCException {
        markLeafReplace("sccpClassOfOperation");
    }

    /**
     * Marks the leaf "sccp-class-of-operation" with operation "merge".
     */
    public void markSccpClassOfOperationMerge() throws JNCException {
        markLeafMerge("sccpClassOfOperation");
    }

    /**
     * Marks the leaf "sccp-class-of-operation" with operation "create".
     */
    public void markSccpClassOfOperationCreate() throws JNCException {
        markLeafCreate("sccpClassOfOperation");
    }

    /**
     * Marks the leaf "sccp-class-of-operation" with operation "delete".
     */
    public void markSccpClassOfOperationDelete() throws JNCException {
        markLeafDelete("sccpClassOfOperation");
    }

    /* Access methods for optional leaf child: "e164-trans-type". */

    /**
     * Gets the value for child leaf "e164-trans-type".
     * @return The value of the leaf.
     */
    public YangString getE164TransTypeValue() throws JNCException {
        YangString e164TransType = (YangString)getValue("e164-trans-type");
        if (e164TransType == null) {
            e164TransType = new YangString("auto-config");  // default
        }
        return e164TransType;
    }

    /**
     * Sets the value for child leaf "e164-trans-type",
     * using instance of generated typedef class.
     * @param e164TransTypeValue The value to set.
     * @param e164TransTypeValue used during instantiation.
     */
    public void setE164TransTypeValue(YangString e164TransTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e164-trans-type",
            e164TransTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "e164-trans-type",
     * using a String value.
     * @param e164TransTypeValue used during instantiation.
     */
    public void setE164TransTypeValue(String e164TransTypeValue)
            throws JNCException {
        setE164TransTypeValue(new YangString(e164TransTypeValue));
    }

    /**
     * Unsets the value for child leaf "e164-trans-type".
     */
    public void unsetE164TransTypeValue() throws JNCException {
        delete("e164-trans-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "e164-trans-type" leaf will not have a value.
     */
    public void addE164TransType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e164-trans-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "e164-trans-type" with operation "replace".
     */
    public void markE164TransTypeReplace() throws JNCException {
        markLeafReplace("e164TransType");
    }

    /**
     * Marks the leaf "e164-trans-type" with operation "merge".
     */
    public void markE164TransTypeMerge() throws JNCException {
        markLeafMerge("e164TransType");
    }

    /**
     * Marks the leaf "e164-trans-type" with operation "create".
     */
    public void markE164TransTypeCreate() throws JNCException {
        markLeafCreate("e164TransType");
    }

    /**
     * Marks the leaf "e164-trans-type" with operation "delete".
     */
    public void markE164TransTypeDelete() throws JNCException {
        markLeafDelete("e164TransType");
    }

    /* Access methods for optional leaf child: "e164-mofsm-trans-type". */

    /**
     * Gets the value for child leaf "e164-mofsm-trans-type".
     * @return The value of the leaf.
     */
    public YangString getE164MofsmTransTypeValue() throws JNCException {
        YangString e164MofsmTransType = (YangString)getValue("e164-mofsm-trans-type");
        if (e164MofsmTransType == null) {
            e164MofsmTransType = new YangString("auto-config");  // default
        }
        return e164MofsmTransType;
    }

    /**
     * Sets the value for child leaf "e164-mofsm-trans-type",
     * using instance of generated typedef class.
     * @param e164MofsmTransTypeValue The value to set.
     * @param e164MofsmTransTypeValue used during instantiation.
     */
    public void setE164MofsmTransTypeValue(YangString e164MofsmTransTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e164-mofsm-trans-type",
            e164MofsmTransTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "e164-mofsm-trans-type",
     * using a String value.
     * @param e164MofsmTransTypeValue used during instantiation.
     */
    public void setE164MofsmTransTypeValue(String e164MofsmTransTypeValue)
            throws JNCException {
        setE164MofsmTransTypeValue(new YangString(e164MofsmTransTypeValue));
    }

    /**
     * Unsets the value for child leaf "e164-mofsm-trans-type".
     */
    public void unsetE164MofsmTransTypeValue() throws JNCException {
        delete("e164-mofsm-trans-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "e164-mofsm-trans-type" leaf will not have a value.
     */
    public void addE164MofsmTransType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e164-mofsm-trans-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "e164-mofsm-trans-type" with operation "replace".
     */
    public void markE164MofsmTransTypeReplace() throws JNCException {
        markLeafReplace("e164MofsmTransType");
    }

    /**
     * Marks the leaf "e164-mofsm-trans-type" with operation "merge".
     */
    public void markE164MofsmTransTypeMerge() throws JNCException {
        markLeafMerge("e164MofsmTransType");
    }

    /**
     * Marks the leaf "e164-mofsm-trans-type" with operation "create".
     */
    public void markE164MofsmTransTypeCreate() throws JNCException {
        markLeafCreate("e164MofsmTransType");
    }

    /**
     * Marks the leaf "e164-mofsm-trans-type" with operation "delete".
     */
    public void markE164MofsmTransTypeDelete() throws JNCException {
        markLeafDelete("e164MofsmTransType");
    }

    /* Access methods for optional leaf child: "e212-trans-type". */

    /**
     * Gets the value for child leaf "e212-trans-type".
     * @return The value of the leaf.
     */
    public YangString getE212TransTypeValue() throws JNCException {
        YangString e212TransType = (YangString)getValue("e212-trans-type");
        if (e212TransType == null) {
            e212TransType = new YangString("auto-config");  // default
        }
        return e212TransType;
    }

    /**
     * Sets the value for child leaf "e212-trans-type",
     * using instance of generated typedef class.
     * @param e212TransTypeValue The value to set.
     * @param e212TransTypeValue used during instantiation.
     */
    public void setE212TransTypeValue(YangString e212TransTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e212-trans-type",
            e212TransTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "e212-trans-type",
     * using a String value.
     * @param e212TransTypeValue used during instantiation.
     */
    public void setE212TransTypeValue(String e212TransTypeValue)
            throws JNCException {
        setE212TransTypeValue(new YangString(e212TransTypeValue));
    }

    /**
     * Unsets the value for child leaf "e212-trans-type".
     */
    public void unsetE212TransTypeValue() throws JNCException {
        delete("e212-trans-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "e212-trans-type" leaf will not have a value.
     */
    public void addE212TransType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e212-trans-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "e212-trans-type" with operation "replace".
     */
    public void markE212TransTypeReplace() throws JNCException {
        markLeafReplace("e212TransType");
    }

    /**
     * Marks the leaf "e212-trans-type" with operation "merge".
     */
    public void markE212TransTypeMerge() throws JNCException {
        markLeafMerge("e212TransType");
    }

    /**
     * Marks the leaf "e212-trans-type" with operation "create".
     */
    public void markE212TransTypeCreate() throws JNCException {
        markLeafCreate("e212TransType");
    }

    /**
     * Marks the leaf "e212-trans-type" with operation "delete".
     */
    public void markE212TransTypeDelete() throws JNCException {
        markLeafDelete("e212TransType");
    }

    /* Access methods for optional leaf child: "e214-trans-type". */

    /**
     * Gets the value for child leaf "e214-trans-type".
     * @return The value of the leaf.
     */
    public YangUInt8 getE214TransTypeValue() throws JNCException {
        YangUInt8 e214TransType = (YangUInt8)getValue("e214-trans-type");
        if (e214TransType == null) {
            e214TransType = new YangUInt8("0");  // default
        }
        return e214TransType;
    }

    /**
     * Sets the value for child leaf "e214-trans-type",
     * using instance of generated typedef class.
     * @param e214TransTypeValue The value to set.
     * @param e214TransTypeValue used during instantiation.
     */
    public void setE214TransTypeValue(YangUInt8 e214TransTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e214-trans-type",
            e214TransTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "e214-trans-type",
     * using Java primitive values.
     * @param e214TransTypeValue used during instantiation.
     */
    public void setE214TransTypeValue(short e214TransTypeValue)
            throws JNCException {
        setE214TransTypeValue(new YangUInt8(e214TransTypeValue));
    }

    /**
     * Sets the value for child leaf "e214-trans-type",
     * using a String value.
     * @param e214TransTypeValue used during instantiation.
     */
    public void setE214TransTypeValue(String e214TransTypeValue)
            throws JNCException {
        setE214TransTypeValue(new YangUInt8(e214TransTypeValue));
    }

    /**
     * Unsets the value for child leaf "e214-trans-type".
     */
    public void unsetE214TransTypeValue() throws JNCException {
        delete("e214-trans-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "e214-trans-type" leaf will not have a value.
     */
    public void addE214TransType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "e214-trans-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "e214-trans-type" with operation "replace".
     */
    public void markE214TransTypeReplace() throws JNCException {
        markLeafReplace("e214TransType");
    }

    /**
     * Marks the leaf "e214-trans-type" with operation "merge".
     */
    public void markE214TransTypeMerge() throws JNCException {
        markLeafMerge("e214TransType");
    }

    /**
     * Marks the leaf "e214-trans-type" with operation "create".
     */
    public void markE214TransTypeCreate() throws JNCException {
        markLeafCreate("e214TransType");
    }

    /**
     * Marks the leaf "e214-trans-type" with operation "delete".
     */
    public void markE214TransTypeDelete() throws JNCException {
        markLeafDelete("e214TransType");
    }

    /* Access methods for optional leaf child: "sccp-return-option". */

    /**
     * Gets the value for child leaf "sccp-return-option".
     * @return The value of the leaf.
     */
    public YangEnumeration getSccpReturnOptionValue() throws JNCException {
        YangEnumeration sccpReturnOption = (YangEnumeration)getValue("sccp-return-option");
        if (sccpReturnOption == null) {
            sccpReturnOption = new YangEnumeration("return", new String[] {  // default
                "no-return",
                "return",
            });
        }
        return sccpReturnOption;
    }

    /**
     * Sets the value for child leaf "sccp-return-option",
     * using instance of generated typedef class.
     * @param sccpReturnOptionValue The value to set.
     * @param sccpReturnOptionValue used during instantiation.
     */
    public void setSccpReturnOptionValue(YangEnumeration sccpReturnOptionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-return-option",
            sccpReturnOptionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-return-option",
     * using a String value.
     * @param sccpReturnOptionValue used during instantiation.
     */
    public void setSccpReturnOptionValue(String sccpReturnOptionValue)
            throws JNCException {
        setSccpReturnOptionValue(new YangEnumeration(sccpReturnOptionValue, new String[] {
             "no-return",
             "return",
        }));
    }

    /**
     * Unsets the value for child leaf "sccp-return-option".
     */
    public void unsetSccpReturnOptionValue() throws JNCException {
        delete("sccp-return-option");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-return-option" leaf will not have a value.
     */
    public void addSccpReturnOption() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-return-option",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-return-option" with operation "replace".
     */
    public void markSccpReturnOptionReplace() throws JNCException {
        markLeafReplace("sccpReturnOption");
    }

    /**
     * Marks the leaf "sccp-return-option" with operation "merge".
     */
    public void markSccpReturnOptionMerge() throws JNCException {
        markLeafMerge("sccpReturnOption");
    }

    /**
     * Marks the leaf "sccp-return-option" with operation "create".
     */
    public void markSccpReturnOptionCreate() throws JNCException {
        markLeafCreate("sccpReturnOption");
    }

    /**
     * Marks the leaf "sccp-return-option" with operation "delete".
     */
    public void markSccpReturnOptionDelete() throws JNCException {
        markLeafDelete("sccpReturnOption");
    }

    /* Access methods for optional leaf child: "hop-counter". */

    /**
     * Gets the value for child leaf "hop-counter".
     * @return The value of the leaf.
     */
    public YangUInt8 getHopCounterValue() throws JNCException {
        YangUInt8 hopCounter = (YangUInt8)getValue("hop-counter");
        if (hopCounter == null) {
            hopCounter = new YangUInt8("15");  // default
        }
        return hopCounter;
    }

    /**
     * Sets the value for child leaf "hop-counter",
     * using instance of generated typedef class.
     * @param hopCounterValue The value to set.
     * @param hopCounterValue used during instantiation.
     */
    public void setHopCounterValue(YangUInt8 hopCounterValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hop-counter",
            hopCounterValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "hop-counter",
     * using Java primitive values.
     * @param hopCounterValue used during instantiation.
     */
    public void setHopCounterValue(short hopCounterValue) throws JNCException {
        setHopCounterValue(new YangUInt8(hopCounterValue));
    }

    /**
     * Sets the value for child leaf "hop-counter",
     * using a String value.
     * @param hopCounterValue used during instantiation.
     */
    public void setHopCounterValue(String hopCounterValue) throws JNCException {
        setHopCounterValue(new YangUInt8(hopCounterValue));
    }

    /**
     * Unsets the value for child leaf "hop-counter".
     */
    public void unsetHopCounterValue() throws JNCException {
        delete("hop-counter");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "hop-counter" leaf will not have a value.
     */
    public void addHopCounter() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hop-counter",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "hop-counter" with operation "replace".
     */
    public void markHopCounterReplace() throws JNCException {
        markLeafReplace("hopCounter");
    }

    /**
     * Marks the leaf "hop-counter" with operation "merge".
     */
    public void markHopCounterMerge() throws JNCException {
        markLeafMerge("hopCounter");
    }

    /**
     * Marks the leaf "hop-counter" with operation "create".
     */
    public void markHopCounterCreate() throws JNCException {
        markLeafCreate("hopCounter");
    }

    /**
     * Marks the leaf "hop-counter" with operation "delete".
     */
    public void markHopCounterDelete() throws JNCException {
        markLeafDelete("hopCounter");
    }

    /* Access methods for optional leaf child: "xudt-option". */

    /**
     * Gets the value for child leaf "xudt-option".
     * @return The value of the leaf.
     */
    public YangEnumeration getXudtOptionValue() throws JNCException {
        YangEnumeration xudtOption = (YangEnumeration)getValue("xudt-option");
        if (xudtOption == null) {
            xudtOption = new YangEnumeration("off", new String[] {  // default
                "on",
                "off",
            });
        }
        return xudtOption;
    }

    /**
     * Sets the value for child leaf "xudt-option",
     * using instance of generated typedef class.
     * @param xudtOptionValue The value to set.
     * @param xudtOptionValue used during instantiation.
     */
    public void setXudtOptionValue(YangEnumeration xudtOptionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "xudt-option",
            xudtOptionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "xudt-option",
     * using a String value.
     * @param xudtOptionValue used during instantiation.
     */
    public void setXudtOptionValue(String xudtOptionValue) throws JNCException {
        setXudtOptionValue(new YangEnumeration(xudtOptionValue, new String[] {
             "on",
             "off",
        }));
    }

    /**
     * Unsets the value for child leaf "xudt-option".
     */
    public void unsetXudtOptionValue() throws JNCException {
        delete("xudt-option");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "xudt-option" leaf will not have a value.
     */
    public void addXudtOption() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "xudt-option",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "xudt-option" with operation "replace".
     */
    public void markXudtOptionReplace() throws JNCException {
        markLeafReplace("xudtOption");
    }

    /**
     * Marks the leaf "xudt-option" with operation "merge".
     */
    public void markXudtOptionMerge() throws JNCException {
        markLeafMerge("xudtOption");
    }

    /**
     * Marks the leaf "xudt-option" with operation "create".
     */
    public void markXudtOptionCreate() throws JNCException {
        markLeafCreate("xudtOption");
    }

    /**
     * Marks the leaf "xudt-option" with operation "delete".
     */
    public void markXudtOptionDelete() throws JNCException {
        markLeafDelete("xudtOption");
    }

    /* Access methods for optional leaf child: "max-map-transactions". */

    /**
     * Gets the value for child leaf "max-map-transactions".
     * @return The value of the leaf.
     */
    public YangUInt16 getMaxMapTransactionsValue() throws JNCException {
        YangUInt16 maxMapTransactions = (YangUInt16)getValue("max-map-transactions");
        if (maxMapTransactions == null) {
            maxMapTransactions = new YangUInt16("2000");  // default
        }
        return maxMapTransactions;
    }

    /**
     * Sets the value for child leaf "max-map-transactions",
     * using instance of generated typedef class.
     * @param maxMapTransactionsValue The value to set.
     * @param maxMapTransactionsValue used during instantiation.
     */
    public void setMaxMapTransactionsValue(YangUInt16 maxMapTransactionsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-map-transactions",
            maxMapTransactionsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "max-map-transactions",
     * using Java primitive values.
     * @param maxMapTransactionsValue used during instantiation.
     */
    public void setMaxMapTransactionsValue(int maxMapTransactionsValue)
            throws JNCException {
        setMaxMapTransactionsValue(new YangUInt16(maxMapTransactionsValue));
    }

    /**
     * Sets the value for child leaf "max-map-transactions",
     * using a String value.
     * @param maxMapTransactionsValue used during instantiation.
     */
    public void setMaxMapTransactionsValue(String maxMapTransactionsValue)
            throws JNCException {
        setMaxMapTransactionsValue(new YangUInt16(maxMapTransactionsValue));
    }

    /**
     * Unsets the value for child leaf "max-map-transactions".
     */
    public void unsetMaxMapTransactionsValue() throws JNCException {
        delete("max-map-transactions");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "max-map-transactions" leaf will not have a value.
     */
    public void addMaxMapTransactions() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-map-transactions",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "max-map-transactions" with operation "replace".
     */
    public void markMaxMapTransactionsReplace() throws JNCException {
        markLeafReplace("maxMapTransactions");
    }

    /**
     * Marks the leaf "max-map-transactions" with operation "merge".
     */
    public void markMaxMapTransactionsMerge() throws JNCException {
        markLeafMerge("maxMapTransactions");
    }

    /**
     * Marks the leaf "max-map-transactions" with operation "create".
     */
    public void markMaxMapTransactionsCreate() throws JNCException {
        markLeafCreate("maxMapTransactions");
    }

    /**
     * Marks the leaf "max-map-transactions" with operation "delete".
     */
    public void markMaxMapTransactionsDelete() throws JNCException {
        markLeafDelete("maxMapTransactions");
    }

    /* Access methods for optional leaf child: "max-map-invokes". */

    /**
     * Gets the value for child leaf "max-map-invokes".
     * @return The value of the leaf.
     */
    public YangUInt16 getMaxMapInvokesValue() throws JNCException {
        YangUInt16 maxMapInvokes = (YangUInt16)getValue("max-map-invokes");
        if (maxMapInvokes == null) {
            maxMapInvokes = new YangUInt16("3000");  // default
        }
        return maxMapInvokes;
    }

    /**
     * Sets the value for child leaf "max-map-invokes",
     * using instance of generated typedef class.
     * @param maxMapInvokesValue The value to set.
     * @param maxMapInvokesValue used during instantiation.
     */
    public void setMaxMapInvokesValue(YangUInt16 maxMapInvokesValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-map-invokes",
            maxMapInvokesValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "max-map-invokes",
     * using Java primitive values.
     * @param maxMapInvokesValue used during instantiation.
     */
    public void setMaxMapInvokesValue(int maxMapInvokesValue)
            throws JNCException {
        setMaxMapInvokesValue(new YangUInt16(maxMapInvokesValue));
    }

    /**
     * Sets the value for child leaf "max-map-invokes",
     * using a String value.
     * @param maxMapInvokesValue used during instantiation.
     */
    public void setMaxMapInvokesValue(String maxMapInvokesValue)
            throws JNCException {
        setMaxMapInvokesValue(new YangUInt16(maxMapInvokesValue));
    }

    /**
     * Unsets the value for child leaf "max-map-invokes".
     */
    public void unsetMaxMapInvokesValue() throws JNCException {
        delete("max-map-invokes");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "max-map-invokes" leaf will not have a value.
     */
    public void addMaxMapInvokes() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-map-invokes",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "max-map-invokes" with operation "replace".
     */
    public void markMaxMapInvokesReplace() throws JNCException {
        markLeafReplace("maxMapInvokes");
    }

    /**
     * Marks the leaf "max-map-invokes" with operation "merge".
     */
    public void markMaxMapInvokesMerge() throws JNCException {
        markLeafMerge("maxMapInvokes");
    }

    /**
     * Marks the leaf "max-map-invokes" with operation "create".
     */
    public void markMaxMapInvokesCreate() throws JNCException {
        markLeafCreate("maxMapInvokes");
    }

    /**
     * Marks the leaf "max-map-invokes" with operation "delete".
     */
    public void markMaxMapInvokesDelete() throws JNCException {
        markLeafDelete("maxMapInvokes");
    }

    /* Access methods for optional leaf child: "max-cap-transactions". */

    /**
     * Gets the value for child leaf "max-cap-transactions".
     * @return The value of the leaf.
     */
    public YangUInt16 getMaxCapTransactionsValue() throws JNCException {
        YangUInt16 maxCapTransactions = (YangUInt16)getValue("max-cap-transactions");
        if (maxCapTransactions == null) {
            maxCapTransactions = new YangUInt16("2000");  // default
        }
        return maxCapTransactions;
    }

    /**
     * Sets the value for child leaf "max-cap-transactions",
     * using instance of generated typedef class.
     * @param maxCapTransactionsValue The value to set.
     * @param maxCapTransactionsValue used during instantiation.
     */
    public void setMaxCapTransactionsValue(YangUInt16 maxCapTransactionsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-cap-transactions",
            maxCapTransactionsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "max-cap-transactions",
     * using Java primitive values.
     * @param maxCapTransactionsValue used during instantiation.
     */
    public void setMaxCapTransactionsValue(int maxCapTransactionsValue)
            throws JNCException {
        setMaxCapTransactionsValue(new YangUInt16(maxCapTransactionsValue));
    }

    /**
     * Sets the value for child leaf "max-cap-transactions",
     * using a String value.
     * @param maxCapTransactionsValue used during instantiation.
     */
    public void setMaxCapTransactionsValue(String maxCapTransactionsValue)
            throws JNCException {
        setMaxCapTransactionsValue(new YangUInt16(maxCapTransactionsValue));
    }

    /**
     * Unsets the value for child leaf "max-cap-transactions".
     */
    public void unsetMaxCapTransactionsValue() throws JNCException {
        delete("max-cap-transactions");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "max-cap-transactions" leaf will not have a value.
     */
    public void addMaxCapTransactions() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-cap-transactions",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "max-cap-transactions" with operation "replace".
     */
    public void markMaxCapTransactionsReplace() throws JNCException {
        markLeafReplace("maxCapTransactions");
    }

    /**
     * Marks the leaf "max-cap-transactions" with operation "merge".
     */
    public void markMaxCapTransactionsMerge() throws JNCException {
        markLeafMerge("maxCapTransactions");
    }

    /**
     * Marks the leaf "max-cap-transactions" with operation "create".
     */
    public void markMaxCapTransactionsCreate() throws JNCException {
        markLeafCreate("maxCapTransactions");
    }

    /**
     * Marks the leaf "max-cap-transactions" with operation "delete".
     */
    public void markMaxCapTransactionsDelete() throws JNCException {
        markLeafDelete("maxCapTransactions");
    }

    /* Access methods for optional leaf child: "max-cap-invokes". */

    /**
     * Gets the value for child leaf "max-cap-invokes".
     * @return The value of the leaf.
     */
    public YangUInt16 getMaxCapInvokesValue() throws JNCException {
        YangUInt16 maxCapInvokes = (YangUInt16)getValue("max-cap-invokes");
        if (maxCapInvokes == null) {
            maxCapInvokes = new YangUInt16("3000");  // default
        }
        return maxCapInvokes;
    }

    /**
     * Sets the value for child leaf "max-cap-invokes",
     * using instance of generated typedef class.
     * @param maxCapInvokesValue The value to set.
     * @param maxCapInvokesValue used during instantiation.
     */
    public void setMaxCapInvokesValue(YangUInt16 maxCapInvokesValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-cap-invokes",
            maxCapInvokesValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "max-cap-invokes",
     * using Java primitive values.
     * @param maxCapInvokesValue used during instantiation.
     */
    public void setMaxCapInvokesValue(int maxCapInvokesValue)
            throws JNCException {
        setMaxCapInvokesValue(new YangUInt16(maxCapInvokesValue));
    }

    /**
     * Sets the value for child leaf "max-cap-invokes",
     * using a String value.
     * @param maxCapInvokesValue used during instantiation.
     */
    public void setMaxCapInvokesValue(String maxCapInvokesValue)
            throws JNCException {
        setMaxCapInvokesValue(new YangUInt16(maxCapInvokesValue));
    }

    /**
     * Unsets the value for child leaf "max-cap-invokes".
     */
    public void unsetMaxCapInvokesValue() throws JNCException {
        delete("max-cap-invokes");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "max-cap-invokes" leaf will not have a value.
     */
    public void addMaxCapInvokes() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-cap-invokes",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "max-cap-invokes" with operation "replace".
     */
    public void markMaxCapInvokesReplace() throws JNCException {
        markLeafReplace("maxCapInvokes");
    }

    /**
     * Marks the leaf "max-cap-invokes" with operation "merge".
     */
    public void markMaxCapInvokesMerge() throws JNCException {
        markLeafMerge("maxCapInvokes");
    }

    /**
     * Marks the leaf "max-cap-invokes" with operation "create".
     */
    public void markMaxCapInvokesCreate() throws JNCException {
        markLeafCreate("maxCapInvokes");
    }

    /**
     * Marks the leaf "max-cap-invokes" with operation "delete".
     */
    public void markMaxCapInvokesDelete() throws JNCException {
        markLeafDelete("maxCapInvokes");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
