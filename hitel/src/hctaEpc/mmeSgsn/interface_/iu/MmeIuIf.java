/* 
 * @(#)MmeIuIf.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.iu;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/iu/mme-iu-if"
 * <p>
 * See line 45 in
 * rncConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeIuIf extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeIuIf object.
     */
    public MmeIuIf() {
        super(Epc.NAMESPACE, "mme-iu-if");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeIuIf clone() {
        return (MmeIuIf)cloneContent(new MmeIuIf());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeIuIf cloneShallow() {
        return (MmeIuIf)cloneShallowContent(new MmeIuIf());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "reset-ack-timer-tratr",
            "reset-timer-trafr",
            "reset-retry-trafr",
            "sccp-class-of-service",
            "sccp-connection-establish-timer",
            "sccp-inactivity-test-timer",
            "sccp-inactivity-receive-timer",
            "sccp-timer-release",
            "sccp-timer-repeat-release",
            "sccp-pause-delay-timer",
            "trab-assgt-timer",
            "trab-assgt-retry",
            "reloc-alloc-timer",
            "reloc-complete-timer",
            "iu-release-timer",
            "iu-signaling-act-timer",
            "security-mode-timer",
            "security-mode-retry",
            "srns-rau-timer",
            "inter-rat-indirect-forwarding",
            "indirect-data-fwd-ip-address",
            "indirect-tunnel-hold-timer",
            "version",
            "reloc-resource-release-timer",
            "dscp-mark",
            "csg-expiration-release-timer",
            "signaling-variant",
        };
    }

    /* Access methods for optional leaf child: "reset-ack-timer-tratr". */

    /**
     * Gets the value for child leaf "reset-ack-timer-tratr".
     * @return The value of the leaf.
     */
    public YangUInt8 getResetAckTimerTratrValue() throws JNCException {
        YangUInt8 resetAckTimerTratr = (YangUInt8)getValue("reset-ack-timer-tratr");
        if (resetAckTimerTratr == null) {
            resetAckTimerTratr = new YangUInt8("60");  // default
        }
        return resetAckTimerTratr;
    }

    /**
     * Sets the value for child leaf "reset-ack-timer-tratr",
     * using instance of generated typedef class.
     * @param resetAckTimerTratrValue The value to set.
     * @param resetAckTimerTratrValue used during instantiation.
     */
    public void setResetAckTimerTratrValue(YangUInt8 resetAckTimerTratrValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-ack-timer-tratr",
            resetAckTimerTratrValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reset-ack-timer-tratr",
     * using Java primitive values.
     * @param resetAckTimerTratrValue used during instantiation.
     */
    public void setResetAckTimerTratrValue(short resetAckTimerTratrValue)
            throws JNCException {
        setResetAckTimerTratrValue(new YangUInt8(resetAckTimerTratrValue));
    }

    /**
     * Sets the value for child leaf "reset-ack-timer-tratr",
     * using a String value.
     * @param resetAckTimerTratrValue used during instantiation.
     */
    public void setResetAckTimerTratrValue(String resetAckTimerTratrValue)
            throws JNCException {
        setResetAckTimerTratrValue(new YangUInt8(resetAckTimerTratrValue));
    }

    /**
     * Unsets the value for child leaf "reset-ack-timer-tratr".
     */
    public void unsetResetAckTimerTratrValue() throws JNCException {
        delete("reset-ack-timer-tratr");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reset-ack-timer-tratr" leaf will not have a value.
     */
    public void addResetAckTimerTratr() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-ack-timer-tratr",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reset-ack-timer-tratr" with operation "replace".
     */
    public void markResetAckTimerTratrReplace() throws JNCException {
        markLeafReplace("resetAckTimerTratr");
    }

    /**
     * Marks the leaf "reset-ack-timer-tratr" with operation "merge".
     */
    public void markResetAckTimerTratrMerge() throws JNCException {
        markLeafMerge("resetAckTimerTratr");
    }

    /**
     * Marks the leaf "reset-ack-timer-tratr" with operation "create".
     */
    public void markResetAckTimerTratrCreate() throws JNCException {
        markLeafCreate("resetAckTimerTratr");
    }

    /**
     * Marks the leaf "reset-ack-timer-tratr" with operation "delete".
     */
    public void markResetAckTimerTratrDelete() throws JNCException {
        markLeafDelete("resetAckTimerTratr");
    }

    /* Access methods for optional leaf child: "reset-timer-trafr". */

    /**
     * Gets the value for child leaf "reset-timer-trafr".
     * @return The value of the leaf.
     */
    public YangUInt8 getResetTimerTrafrValue() throws JNCException {
        YangUInt8 resetTimerTrafr = (YangUInt8)getValue("reset-timer-trafr");
        if (resetTimerTrafr == null) {
            resetTimerTrafr = new YangUInt8("90");  // default
        }
        return resetTimerTrafr;
    }

    /**
     * Sets the value for child leaf "reset-timer-trafr",
     * using instance of generated typedef class.
     * @param resetTimerTrafrValue The value to set.
     * @param resetTimerTrafrValue used during instantiation.
     */
    public void setResetTimerTrafrValue(YangUInt8 resetTimerTrafrValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-timer-trafr",
            resetTimerTrafrValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reset-timer-trafr",
     * using Java primitive values.
     * @param resetTimerTrafrValue used during instantiation.
     */
    public void setResetTimerTrafrValue(short resetTimerTrafrValue)
            throws JNCException {
        setResetTimerTrafrValue(new YangUInt8(resetTimerTrafrValue));
    }

    /**
     * Sets the value for child leaf "reset-timer-trafr",
     * using a String value.
     * @param resetTimerTrafrValue used during instantiation.
     */
    public void setResetTimerTrafrValue(String resetTimerTrafrValue)
            throws JNCException {
        setResetTimerTrafrValue(new YangUInt8(resetTimerTrafrValue));
    }

    /**
     * Unsets the value for child leaf "reset-timer-trafr".
     */
    public void unsetResetTimerTrafrValue() throws JNCException {
        delete("reset-timer-trafr");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reset-timer-trafr" leaf will not have a value.
     */
    public void addResetTimerTrafr() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-timer-trafr",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reset-timer-trafr" with operation "replace".
     */
    public void markResetTimerTrafrReplace() throws JNCException {
        markLeafReplace("resetTimerTrafr");
    }

    /**
     * Marks the leaf "reset-timer-trafr" with operation "merge".
     */
    public void markResetTimerTrafrMerge() throws JNCException {
        markLeafMerge("resetTimerTrafr");
    }

    /**
     * Marks the leaf "reset-timer-trafr" with operation "create".
     */
    public void markResetTimerTrafrCreate() throws JNCException {
        markLeafCreate("resetTimerTrafr");
    }

    /**
     * Marks the leaf "reset-timer-trafr" with operation "delete".
     */
    public void markResetTimerTrafrDelete() throws JNCException {
        markLeafDelete("resetTimerTrafr");
    }

    /* Access methods for optional leaf child: "reset-retry-trafr". */

    /**
     * Gets the value for child leaf "reset-retry-trafr".
     * @return The value of the leaf.
     */
    public YangUInt8 getResetRetryTrafrValue() throws JNCException {
        YangUInt8 resetRetryTrafr = (YangUInt8)getValue("reset-retry-trafr");
        if (resetRetryTrafr == null) {
            resetRetryTrafr = new YangUInt8("1");  // default
        }
        return resetRetryTrafr;
    }

    /**
     * Sets the value for child leaf "reset-retry-trafr",
     * using instance of generated typedef class.
     * @param resetRetryTrafrValue The value to set.
     * @param resetRetryTrafrValue used during instantiation.
     */
    public void setResetRetryTrafrValue(YangUInt8 resetRetryTrafrValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-retry-trafr",
            resetRetryTrafrValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reset-retry-trafr",
     * using Java primitive values.
     * @param resetRetryTrafrValue used during instantiation.
     */
    public void setResetRetryTrafrValue(short resetRetryTrafrValue)
            throws JNCException {
        setResetRetryTrafrValue(new YangUInt8(resetRetryTrafrValue));
    }

    /**
     * Sets the value for child leaf "reset-retry-trafr",
     * using a String value.
     * @param resetRetryTrafrValue used during instantiation.
     */
    public void setResetRetryTrafrValue(String resetRetryTrafrValue)
            throws JNCException {
        setResetRetryTrafrValue(new YangUInt8(resetRetryTrafrValue));
    }

    /**
     * Unsets the value for child leaf "reset-retry-trafr".
     */
    public void unsetResetRetryTrafrValue() throws JNCException {
        delete("reset-retry-trafr");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reset-retry-trafr" leaf will not have a value.
     */
    public void addResetRetryTrafr() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-retry-trafr",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reset-retry-trafr" with operation "replace".
     */
    public void markResetRetryTrafrReplace() throws JNCException {
        markLeafReplace("resetRetryTrafr");
    }

    /**
     * Marks the leaf "reset-retry-trafr" with operation "merge".
     */
    public void markResetRetryTrafrMerge() throws JNCException {
        markLeafMerge("resetRetryTrafr");
    }

    /**
     * Marks the leaf "reset-retry-trafr" with operation "create".
     */
    public void markResetRetryTrafrCreate() throws JNCException {
        markLeafCreate("resetRetryTrafr");
    }

    /**
     * Marks the leaf "reset-retry-trafr" with operation "delete".
     */
    public void markResetRetryTrafrDelete() throws JNCException {
        markLeafDelete("resetRetryTrafr");
    }

    /* Access methods for optional leaf child: "sccp-class-of-service". */

    /**
     * Gets the value for child leaf "sccp-class-of-service".
     * @return The value of the leaf.
     */
    public YangEnumeration getSccpClassOfServiceValue() throws JNCException {
        return (YangEnumeration)getValue("sccp-class-of-service");
    }

    /**
     * Sets the value for child leaf "sccp-class-of-service",
     * using instance of generated typedef class.
     * @param sccpClassOfServiceValue The value to set.
     * @param sccpClassOfServiceValue used during instantiation.
     */
    public void setSccpClassOfServiceValue(YangEnumeration sccpClassOfServiceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-class-of-service",
            sccpClassOfServiceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-class-of-service",
     * using a String value.
     * @param sccpClassOfServiceValue used during instantiation.
     */
    public void setSccpClassOfServiceValue(String sccpClassOfServiceValue)
            throws JNCException {
        setSccpClassOfServiceValue(new YangEnumeration(sccpClassOfServiceValue, new String[] {
             "connection-less",
             "connection-oriented",
             "connection-less,connection-oriented",
        }));
    }

    /**
     * Unsets the value for child leaf "sccp-class-of-service".
     */
    public void unsetSccpClassOfServiceValue() throws JNCException {
        delete("sccp-class-of-service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-class-of-service" leaf will not have a value.
     */
    public void addSccpClassOfService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-class-of-service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-class-of-service" with operation "replace".
     */
    public void markSccpClassOfServiceReplace() throws JNCException {
        markLeafReplace("sccpClassOfService");
    }

    /**
     * Marks the leaf "sccp-class-of-service" with operation "merge".
     */
    public void markSccpClassOfServiceMerge() throws JNCException {
        markLeafMerge("sccpClassOfService");
    }

    /**
     * Marks the leaf "sccp-class-of-service" with operation "create".
     */
    public void markSccpClassOfServiceCreate() throws JNCException {
        markLeafCreate("sccpClassOfService");
    }

    /**
     * Marks the leaf "sccp-class-of-service" with operation "delete".
     */
    public void markSccpClassOfServiceDelete() throws JNCException {
        markLeafDelete("sccpClassOfService");
    }

    /* Access methods for optional leaf child: "sccp-connection-establish-timer". */

    /**
     * Gets the value for child leaf "sccp-connection-establish-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getSccpConnectionEstablishTimerValue() throws JNCException {
        YangUInt8 sccpConnectionEstablishTimer = (YangUInt8)getValue("sccp-connection-establish-timer");
        if (sccpConnectionEstablishTimer == null) {
            sccpConnectionEstablishTimer = new YangUInt8("60");  // default
        }
        return sccpConnectionEstablishTimer;
    }

    /**
     * Sets the value for child leaf "sccp-connection-establish-timer",
     * using instance of generated typedef class.
     * @param sccpConnectionEstablishTimerValue The value to set.
     * @param sccpConnectionEstablishTimerValue used during instantiation.
     */
    public void setSccpConnectionEstablishTimerValue(YangUInt8 sccpConnectionEstablishTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-connection-establish-timer",
            sccpConnectionEstablishTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-connection-establish-timer",
     * using Java primitive values.
     * @param sccpConnectionEstablishTimerValue used during instantiation.
     */
    public void setSccpConnectionEstablishTimerValue(short sccpConnectionEstablishTimerValue)
            throws JNCException {
        setSccpConnectionEstablishTimerValue(new YangUInt8(sccpConnectionEstablishTimerValue));
    }

    /**
     * Sets the value for child leaf "sccp-connection-establish-timer",
     * using a String value.
     * @param sccpConnectionEstablishTimerValue used during instantiation.
     */
    public void setSccpConnectionEstablishTimerValue(String sccpConnectionEstablishTimerValue)
            throws JNCException {
        setSccpConnectionEstablishTimerValue(new YangUInt8(sccpConnectionEstablishTimerValue));
    }

    /**
     * Unsets the value for child leaf "sccp-connection-establish-timer".
     */
    public void unsetSccpConnectionEstablishTimerValue() throws JNCException {
        delete("sccp-connection-establish-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-connection-establish-timer" leaf will not have a value.
     */
    public void addSccpConnectionEstablishTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-connection-establish-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-connection-establish-timer" with operation "replace".
     */
    public void markSccpConnectionEstablishTimerReplace() throws JNCException {
        markLeafReplace("sccpConnectionEstablishTimer");
    }

    /**
     * Marks the leaf "sccp-connection-establish-timer" with operation "merge".
     */
    public void markSccpConnectionEstablishTimerMerge() throws JNCException {
        markLeafMerge("sccpConnectionEstablishTimer");
    }

    /**
     * Marks the leaf "sccp-connection-establish-timer" with operation "create".
     */
    public void markSccpConnectionEstablishTimerCreate() throws JNCException {
        markLeafCreate("sccpConnectionEstablishTimer");
    }

    /**
     * Marks the leaf "sccp-connection-establish-timer" with operation "delete".
     */
    public void markSccpConnectionEstablishTimerDelete() throws JNCException {
        markLeafDelete("sccpConnectionEstablishTimer");
    }

    /* Access methods for optional leaf child: "sccp-inactivity-test-timer". */

    /**
     * Gets the value for child leaf "sccp-inactivity-test-timer".
     * @return The value of the leaf.
     */
    public YangUInt16 getSccpInactivityTestTimerValue() throws JNCException {
        YangUInt16 sccpInactivityTestTimer = (YangUInt16)getValue("sccp-inactivity-test-timer");
        if (sccpInactivityTestTimer == null) {
            sccpInactivityTestTimer = new YangUInt16("300");  // default
        }
        return sccpInactivityTestTimer;
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-test-timer",
     * using instance of generated typedef class.
     * @param sccpInactivityTestTimerValue The value to set.
     * @param sccpInactivityTestTimerValue used during instantiation.
     */
    public void setSccpInactivityTestTimerValue(YangUInt16 sccpInactivityTestTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-inactivity-test-timer",
            sccpInactivityTestTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-test-timer",
     * using Java primitive values.
     * @param sccpInactivityTestTimerValue used during instantiation.
     */
    public void setSccpInactivityTestTimerValue(int sccpInactivityTestTimerValue)
            throws JNCException {
        setSccpInactivityTestTimerValue(new YangUInt16(sccpInactivityTestTimerValue));
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-test-timer",
     * using a String value.
     * @param sccpInactivityTestTimerValue used during instantiation.
     */
    public void setSccpInactivityTestTimerValue(String sccpInactivityTestTimerValue)
            throws JNCException {
        setSccpInactivityTestTimerValue(new YangUInt16(sccpInactivityTestTimerValue));
    }

    /**
     * Unsets the value for child leaf "sccp-inactivity-test-timer".
     */
    public void unsetSccpInactivityTestTimerValue() throws JNCException {
        delete("sccp-inactivity-test-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-inactivity-test-timer" leaf will not have a value.
     */
    public void addSccpInactivityTestTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-inactivity-test-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-inactivity-test-timer" with operation "replace".
     */
    public void markSccpInactivityTestTimerReplace() throws JNCException {
        markLeafReplace("sccpInactivityTestTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-test-timer" with operation "merge".
     */
    public void markSccpInactivityTestTimerMerge() throws JNCException {
        markLeafMerge("sccpInactivityTestTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-test-timer" with operation "create".
     */
    public void markSccpInactivityTestTimerCreate() throws JNCException {
        markLeafCreate("sccpInactivityTestTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-test-timer" with operation "delete".
     */
    public void markSccpInactivityTestTimerDelete() throws JNCException {
        markLeafDelete("sccpInactivityTestTimer");
    }

    /* Access methods for optional leaf child: "sccp-inactivity-receive-timer". */

    /**
     * Gets the value for child leaf "sccp-inactivity-receive-timer".
     * @return The value of the leaf.
     */
    public YangUInt16 getSccpInactivityReceiveTimerValue() throws JNCException {
        YangUInt16 sccpInactivityReceiveTimer = (YangUInt16)getValue("sccp-inactivity-receive-timer");
        if (sccpInactivityReceiveTimer == null) {
            sccpInactivityReceiveTimer = new YangUInt16("660");  // default
        }
        return sccpInactivityReceiveTimer;
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-receive-timer",
     * using instance of generated typedef class.
     * @param sccpInactivityReceiveTimerValue The value to set.
     * @param sccpInactivityReceiveTimerValue used during instantiation.
     */
    public void setSccpInactivityReceiveTimerValue(YangUInt16 sccpInactivityReceiveTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-inactivity-receive-timer",
            sccpInactivityReceiveTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-receive-timer",
     * using Java primitive values.
     * @param sccpInactivityReceiveTimerValue used during instantiation.
     */
    public void setSccpInactivityReceiveTimerValue(int sccpInactivityReceiveTimerValue)
            throws JNCException {
        setSccpInactivityReceiveTimerValue(new YangUInt16(sccpInactivityReceiveTimerValue));
    }

    /**
     * Sets the value for child leaf "sccp-inactivity-receive-timer",
     * using a String value.
     * @param sccpInactivityReceiveTimerValue used during instantiation.
     */
    public void setSccpInactivityReceiveTimerValue(String sccpInactivityReceiveTimerValue)
            throws JNCException {
        setSccpInactivityReceiveTimerValue(new YangUInt16(sccpInactivityReceiveTimerValue));
    }

    /**
     * Unsets the value for child leaf "sccp-inactivity-receive-timer".
     */
    public void unsetSccpInactivityReceiveTimerValue() throws JNCException {
        delete("sccp-inactivity-receive-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-inactivity-receive-timer" leaf will not have a value.
     */
    public void addSccpInactivityReceiveTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-inactivity-receive-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-inactivity-receive-timer" with operation "replace".
     */
    public void markSccpInactivityReceiveTimerReplace() throws JNCException {
        markLeafReplace("sccpInactivityReceiveTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-receive-timer" with operation "merge".
     */
    public void markSccpInactivityReceiveTimerMerge() throws JNCException {
        markLeafMerge("sccpInactivityReceiveTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-receive-timer" with operation "create".
     */
    public void markSccpInactivityReceiveTimerCreate() throws JNCException {
        markLeafCreate("sccpInactivityReceiveTimer");
    }

    /**
     * Marks the leaf "sccp-inactivity-receive-timer" with operation "delete".
     */
    public void markSccpInactivityReceiveTimerDelete() throws JNCException {
        markLeafDelete("sccpInactivityReceiveTimer");
    }

    /* Access methods for optional leaf child: "sccp-timer-release". */

    /**
     * Gets the value for child leaf "sccp-timer-release".
     * @return The value of the leaf.
     */
    public YangUInt8 getSccpTimerReleaseValue() throws JNCException {
        YangUInt8 sccpTimerRelease = (YangUInt8)getValue("sccp-timer-release");
        if (sccpTimerRelease == null) {
            sccpTimerRelease = new YangUInt8("10");  // default
        }
        return sccpTimerRelease;
    }

    /**
     * Sets the value for child leaf "sccp-timer-release",
     * using instance of generated typedef class.
     * @param sccpTimerReleaseValue The value to set.
     * @param sccpTimerReleaseValue used during instantiation.
     */
    public void setSccpTimerReleaseValue(YangUInt8 sccpTimerReleaseValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-timer-release",
            sccpTimerReleaseValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-timer-release",
     * using Java primitive values.
     * @param sccpTimerReleaseValue used during instantiation.
     */
    public void setSccpTimerReleaseValue(short sccpTimerReleaseValue)
            throws JNCException {
        setSccpTimerReleaseValue(new YangUInt8(sccpTimerReleaseValue));
    }

    /**
     * Sets the value for child leaf "sccp-timer-release",
     * using a String value.
     * @param sccpTimerReleaseValue used during instantiation.
     */
    public void setSccpTimerReleaseValue(String sccpTimerReleaseValue)
            throws JNCException {
        setSccpTimerReleaseValue(new YangUInt8(sccpTimerReleaseValue));
    }

    /**
     * Unsets the value for child leaf "sccp-timer-release".
     */
    public void unsetSccpTimerReleaseValue() throws JNCException {
        delete("sccp-timer-release");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-timer-release" leaf will not have a value.
     */
    public void addSccpTimerRelease() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-timer-release",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-timer-release" with operation "replace".
     */
    public void markSccpTimerReleaseReplace() throws JNCException {
        markLeafReplace("sccpTimerRelease");
    }

    /**
     * Marks the leaf "sccp-timer-release" with operation "merge".
     */
    public void markSccpTimerReleaseMerge() throws JNCException {
        markLeafMerge("sccpTimerRelease");
    }

    /**
     * Marks the leaf "sccp-timer-release" with operation "create".
     */
    public void markSccpTimerReleaseCreate() throws JNCException {
        markLeafCreate("sccpTimerRelease");
    }

    /**
     * Marks the leaf "sccp-timer-release" with operation "delete".
     */
    public void markSccpTimerReleaseDelete() throws JNCException {
        markLeafDelete("sccpTimerRelease");
    }

    /* Access methods for optional leaf child: "sccp-timer-repeat-release". */

    /**
     * Gets the value for child leaf "sccp-timer-repeat-release".
     * @return The value of the leaf.
     */
    public YangUInt8 getSccpTimerRepeatReleaseValue() throws JNCException {
        YangUInt8 sccpTimerRepeatRelease = (YangUInt8)getValue("sccp-timer-repeat-release");
        if (sccpTimerRepeatRelease == null) {
            sccpTimerRepeatRelease = new YangUInt8("20");  // default
        }
        return sccpTimerRepeatRelease;
    }

    /**
     * Sets the value for child leaf "sccp-timer-repeat-release",
     * using instance of generated typedef class.
     * @param sccpTimerRepeatReleaseValue The value to set.
     * @param sccpTimerRepeatReleaseValue used during instantiation.
     */
    public void setSccpTimerRepeatReleaseValue(YangUInt8 sccpTimerRepeatReleaseValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-timer-repeat-release",
            sccpTimerRepeatReleaseValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-timer-repeat-release",
     * using Java primitive values.
     * @param sccpTimerRepeatReleaseValue used during instantiation.
     */
    public void setSccpTimerRepeatReleaseValue(short sccpTimerRepeatReleaseValue)
            throws JNCException {
        setSccpTimerRepeatReleaseValue(new YangUInt8(sccpTimerRepeatReleaseValue));
    }

    /**
     * Sets the value for child leaf "sccp-timer-repeat-release",
     * using a String value.
     * @param sccpTimerRepeatReleaseValue used during instantiation.
     */
    public void setSccpTimerRepeatReleaseValue(String sccpTimerRepeatReleaseValue)
            throws JNCException {
        setSccpTimerRepeatReleaseValue(new YangUInt8(sccpTimerRepeatReleaseValue));
    }

    /**
     * Unsets the value for child leaf "sccp-timer-repeat-release".
     */
    public void unsetSccpTimerRepeatReleaseValue() throws JNCException {
        delete("sccp-timer-repeat-release");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-timer-repeat-release" leaf will not have a value.
     */
    public void addSccpTimerRepeatRelease() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-timer-repeat-release",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-timer-repeat-release" with operation "replace".
     */
    public void markSccpTimerRepeatReleaseReplace() throws JNCException {
        markLeafReplace("sccpTimerRepeatRelease");
    }

    /**
     * Marks the leaf "sccp-timer-repeat-release" with operation "merge".
     */
    public void markSccpTimerRepeatReleaseMerge() throws JNCException {
        markLeafMerge("sccpTimerRepeatRelease");
    }

    /**
     * Marks the leaf "sccp-timer-repeat-release" with operation "create".
     */
    public void markSccpTimerRepeatReleaseCreate() throws JNCException {
        markLeafCreate("sccpTimerRepeatRelease");
    }

    /**
     * Marks the leaf "sccp-timer-repeat-release" with operation "delete".
     */
    public void markSccpTimerRepeatReleaseDelete() throws JNCException {
        markLeafDelete("sccpTimerRepeatRelease");
    }

    /* Access methods for optional leaf child: "sccp-pause-delay-timer". */

    /**
     * Gets the value for child leaf "sccp-pause-delay-timer".
     * @return The value of the leaf.
     */
    public YangString getSccpPauseDelayTimerValue() throws JNCException {
        YangString sccpPauseDelayTimer = (YangString)getValue("sccp-pause-delay-timer");
        if (sccpPauseDelayTimer == null) {
            sccpPauseDelayTimer = new YangString("120");  // default
        }
        return sccpPauseDelayTimer;
    }

    /**
     * Sets the value for child leaf "sccp-pause-delay-timer",
     * using instance of generated typedef class.
     * @param sccpPauseDelayTimerValue The value to set.
     * @param sccpPauseDelayTimerValue used during instantiation.
     */
    public void setSccpPauseDelayTimerValue(YangString sccpPauseDelayTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-pause-delay-timer",
            sccpPauseDelayTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sccp-pause-delay-timer",
     * using a String value.
     * @param sccpPauseDelayTimerValue used during instantiation.
     */
    public void setSccpPauseDelayTimerValue(String sccpPauseDelayTimerValue)
            throws JNCException {
        setSccpPauseDelayTimerValue(new YangString(sccpPauseDelayTimerValue));
    }

    /**
     * Unsets the value for child leaf "sccp-pause-delay-timer".
     */
    public void unsetSccpPauseDelayTimerValue() throws JNCException {
        delete("sccp-pause-delay-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sccp-pause-delay-timer" leaf will not have a value.
     */
    public void addSccpPauseDelayTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sccp-pause-delay-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sccp-pause-delay-timer" with operation "replace".
     */
    public void markSccpPauseDelayTimerReplace() throws JNCException {
        markLeafReplace("sccpPauseDelayTimer");
    }

    /**
     * Marks the leaf "sccp-pause-delay-timer" with operation "merge".
     */
    public void markSccpPauseDelayTimerMerge() throws JNCException {
        markLeafMerge("sccpPauseDelayTimer");
    }

    /**
     * Marks the leaf "sccp-pause-delay-timer" with operation "create".
     */
    public void markSccpPauseDelayTimerCreate() throws JNCException {
        markLeafCreate("sccpPauseDelayTimer");
    }

    /**
     * Marks the leaf "sccp-pause-delay-timer" with operation "delete".
     */
    public void markSccpPauseDelayTimerDelete() throws JNCException {
        markLeafDelete("sccpPauseDelayTimer");
    }

    /* Access methods for optional leaf child: "trab-assgt-timer". */

    /**
     * Gets the value for child leaf "trab-assgt-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getTrabAssgtTimerValue() throws JNCException {
        YangUInt8 trabAssgtTimer = (YangUInt8)getValue("trab-assgt-timer");
        if (trabAssgtTimer == null) {
            trabAssgtTimer = new YangUInt8("4");  // default
        }
        return trabAssgtTimer;
    }

    /**
     * Sets the value for child leaf "trab-assgt-timer",
     * using instance of generated typedef class.
     * @param trabAssgtTimerValue The value to set.
     * @param trabAssgtTimerValue used during instantiation.
     */
    public void setTrabAssgtTimerValue(YangUInt8 trabAssgtTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "trab-assgt-timer",
            trabAssgtTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "trab-assgt-timer",
     * using Java primitive values.
     * @param trabAssgtTimerValue used during instantiation.
     */
    public void setTrabAssgtTimerValue(short trabAssgtTimerValue)
            throws JNCException {
        setTrabAssgtTimerValue(new YangUInt8(trabAssgtTimerValue));
    }

    /**
     * Sets the value for child leaf "trab-assgt-timer",
     * using a String value.
     * @param trabAssgtTimerValue used during instantiation.
     */
    public void setTrabAssgtTimerValue(String trabAssgtTimerValue)
            throws JNCException {
        setTrabAssgtTimerValue(new YangUInt8(trabAssgtTimerValue));
    }

    /**
     * Unsets the value for child leaf "trab-assgt-timer".
     */
    public void unsetTrabAssgtTimerValue() throws JNCException {
        delete("trab-assgt-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "trab-assgt-timer" leaf will not have a value.
     */
    public void addTrabAssgtTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "trab-assgt-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "trab-assgt-timer" with operation "replace".
     */
    public void markTrabAssgtTimerReplace() throws JNCException {
        markLeafReplace("trabAssgtTimer");
    }

    /**
     * Marks the leaf "trab-assgt-timer" with operation "merge".
     */
    public void markTrabAssgtTimerMerge() throws JNCException {
        markLeafMerge("trabAssgtTimer");
    }

    /**
     * Marks the leaf "trab-assgt-timer" with operation "create".
     */
    public void markTrabAssgtTimerCreate() throws JNCException {
        markLeafCreate("trabAssgtTimer");
    }

    /**
     * Marks the leaf "trab-assgt-timer" with operation "delete".
     */
    public void markTrabAssgtTimerDelete() throws JNCException {
        markLeafDelete("trabAssgtTimer");
    }

    /* Access methods for optional leaf child: "trab-assgt-retry". */

    /**
     * Gets the value for child leaf "trab-assgt-retry".
     * @return The value of the leaf.
     */
    public YangUInt8 getTrabAssgtRetryValue() throws JNCException {
        YangUInt8 trabAssgtRetry = (YangUInt8)getValue("trab-assgt-retry");
        if (trabAssgtRetry == null) {
            trabAssgtRetry = new YangUInt8("4");  // default
        }
        return trabAssgtRetry;
    }

    /**
     * Sets the value for child leaf "trab-assgt-retry",
     * using instance of generated typedef class.
     * @param trabAssgtRetryValue The value to set.
     * @param trabAssgtRetryValue used during instantiation.
     */
    public void setTrabAssgtRetryValue(YangUInt8 trabAssgtRetryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "trab-assgt-retry",
            trabAssgtRetryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "trab-assgt-retry",
     * using Java primitive values.
     * @param trabAssgtRetryValue used during instantiation.
     */
    public void setTrabAssgtRetryValue(short trabAssgtRetryValue)
            throws JNCException {
        setTrabAssgtRetryValue(new YangUInt8(trabAssgtRetryValue));
    }

    /**
     * Sets the value for child leaf "trab-assgt-retry",
     * using a String value.
     * @param trabAssgtRetryValue used during instantiation.
     */
    public void setTrabAssgtRetryValue(String trabAssgtRetryValue)
            throws JNCException {
        setTrabAssgtRetryValue(new YangUInt8(trabAssgtRetryValue));
    }

    /**
     * Unsets the value for child leaf "trab-assgt-retry".
     */
    public void unsetTrabAssgtRetryValue() throws JNCException {
        delete("trab-assgt-retry");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "trab-assgt-retry" leaf will not have a value.
     */
    public void addTrabAssgtRetry() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "trab-assgt-retry",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "trab-assgt-retry" with operation "replace".
     */
    public void markTrabAssgtRetryReplace() throws JNCException {
        markLeafReplace("trabAssgtRetry");
    }

    /**
     * Marks the leaf "trab-assgt-retry" with operation "merge".
     */
    public void markTrabAssgtRetryMerge() throws JNCException {
        markLeafMerge("trabAssgtRetry");
    }

    /**
     * Marks the leaf "trab-assgt-retry" with operation "create".
     */
    public void markTrabAssgtRetryCreate() throws JNCException {
        markLeafCreate("trabAssgtRetry");
    }

    /**
     * Marks the leaf "trab-assgt-retry" with operation "delete".
     */
    public void markTrabAssgtRetryDelete() throws JNCException {
        markLeafDelete("trabAssgtRetry");
    }

    /* Access methods for optional leaf child: "reloc-alloc-timer". */

    /**
     * Gets the value for child leaf "reloc-alloc-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRelocAllocTimerValue() throws JNCException {
        YangUInt8 relocAllocTimer = (YangUInt8)getValue("reloc-alloc-timer");
        if (relocAllocTimer == null) {
            relocAllocTimer = new YangUInt8("10");  // default
        }
        return relocAllocTimer;
    }

    /**
     * Sets the value for child leaf "reloc-alloc-timer",
     * using instance of generated typedef class.
     * @param relocAllocTimerValue The value to set.
     * @param relocAllocTimerValue used during instantiation.
     */
    public void setRelocAllocTimerValue(YangUInt8 relocAllocTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-alloc-timer",
            relocAllocTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reloc-alloc-timer",
     * using Java primitive values.
     * @param relocAllocTimerValue used during instantiation.
     */
    public void setRelocAllocTimerValue(short relocAllocTimerValue)
            throws JNCException {
        setRelocAllocTimerValue(new YangUInt8(relocAllocTimerValue));
    }

    /**
     * Sets the value for child leaf "reloc-alloc-timer",
     * using a String value.
     * @param relocAllocTimerValue used during instantiation.
     */
    public void setRelocAllocTimerValue(String relocAllocTimerValue)
            throws JNCException {
        setRelocAllocTimerValue(new YangUInt8(relocAllocTimerValue));
    }

    /**
     * Unsets the value for child leaf "reloc-alloc-timer".
     */
    public void unsetRelocAllocTimerValue() throws JNCException {
        delete("reloc-alloc-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reloc-alloc-timer" leaf will not have a value.
     */
    public void addRelocAllocTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-alloc-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reloc-alloc-timer" with operation "replace".
     */
    public void markRelocAllocTimerReplace() throws JNCException {
        markLeafReplace("relocAllocTimer");
    }

    /**
     * Marks the leaf "reloc-alloc-timer" with operation "merge".
     */
    public void markRelocAllocTimerMerge() throws JNCException {
        markLeafMerge("relocAllocTimer");
    }

    /**
     * Marks the leaf "reloc-alloc-timer" with operation "create".
     */
    public void markRelocAllocTimerCreate() throws JNCException {
        markLeafCreate("relocAllocTimer");
    }

    /**
     * Marks the leaf "reloc-alloc-timer" with operation "delete".
     */
    public void markRelocAllocTimerDelete() throws JNCException {
        markLeafDelete("relocAllocTimer");
    }

    /* Access methods for optional leaf child: "reloc-complete-timer". */

    /**
     * Gets the value for child leaf "reloc-complete-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRelocCompleteTimerValue() throws JNCException {
        YangUInt8 relocCompleteTimer = (YangUInt8)getValue("reloc-complete-timer");
        if (relocCompleteTimer == null) {
            relocCompleteTimer = new YangUInt8("25");  // default
        }
        return relocCompleteTimer;
    }

    /**
     * Sets the value for child leaf "reloc-complete-timer",
     * using instance of generated typedef class.
     * @param relocCompleteTimerValue The value to set.
     * @param relocCompleteTimerValue used during instantiation.
     */
    public void setRelocCompleteTimerValue(YangUInt8 relocCompleteTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-complete-timer",
            relocCompleteTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reloc-complete-timer",
     * using Java primitive values.
     * @param relocCompleteTimerValue used during instantiation.
     */
    public void setRelocCompleteTimerValue(short relocCompleteTimerValue)
            throws JNCException {
        setRelocCompleteTimerValue(new YangUInt8(relocCompleteTimerValue));
    }

    /**
     * Sets the value for child leaf "reloc-complete-timer",
     * using a String value.
     * @param relocCompleteTimerValue used during instantiation.
     */
    public void setRelocCompleteTimerValue(String relocCompleteTimerValue)
            throws JNCException {
        setRelocCompleteTimerValue(new YangUInt8(relocCompleteTimerValue));
    }

    /**
     * Unsets the value for child leaf "reloc-complete-timer".
     */
    public void unsetRelocCompleteTimerValue() throws JNCException {
        delete("reloc-complete-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reloc-complete-timer" leaf will not have a value.
     */
    public void addRelocCompleteTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-complete-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reloc-complete-timer" with operation "replace".
     */
    public void markRelocCompleteTimerReplace() throws JNCException {
        markLeafReplace("relocCompleteTimer");
    }

    /**
     * Marks the leaf "reloc-complete-timer" with operation "merge".
     */
    public void markRelocCompleteTimerMerge() throws JNCException {
        markLeafMerge("relocCompleteTimer");
    }

    /**
     * Marks the leaf "reloc-complete-timer" with operation "create".
     */
    public void markRelocCompleteTimerCreate() throws JNCException {
        markLeafCreate("relocCompleteTimer");
    }

    /**
     * Marks the leaf "reloc-complete-timer" with operation "delete".
     */
    public void markRelocCompleteTimerDelete() throws JNCException {
        markLeafDelete("relocCompleteTimer");
    }

    /* Access methods for optional leaf child: "iu-release-timer". */

    /**
     * Gets the value for child leaf "iu-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getIuReleaseTimerValue() throws JNCException {
        YangUInt8 iuReleaseTimer = (YangUInt8)getValue("iu-release-timer");
        if (iuReleaseTimer == null) {
            iuReleaseTimer = new YangUInt8("5");  // default
        }
        return iuReleaseTimer;
    }

    /**
     * Sets the value for child leaf "iu-release-timer",
     * using instance of generated typedef class.
     * @param iuReleaseTimerValue The value to set.
     * @param iuReleaseTimerValue used during instantiation.
     */
    public void setIuReleaseTimerValue(YangUInt8 iuReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "iu-release-timer",
            iuReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "iu-release-timer",
     * using Java primitive values.
     * @param iuReleaseTimerValue used during instantiation.
     */
    public void setIuReleaseTimerValue(short iuReleaseTimerValue)
            throws JNCException {
        setIuReleaseTimerValue(new YangUInt8(iuReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "iu-release-timer",
     * using a String value.
     * @param iuReleaseTimerValue used during instantiation.
     */
    public void setIuReleaseTimerValue(String iuReleaseTimerValue)
            throws JNCException {
        setIuReleaseTimerValue(new YangUInt8(iuReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "iu-release-timer".
     */
    public void unsetIuReleaseTimerValue() throws JNCException {
        delete("iu-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "iu-release-timer" leaf will not have a value.
     */
    public void addIuReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "iu-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "iu-release-timer" with operation "replace".
     */
    public void markIuReleaseTimerReplace() throws JNCException {
        markLeafReplace("iuReleaseTimer");
    }

    /**
     * Marks the leaf "iu-release-timer" with operation "merge".
     */
    public void markIuReleaseTimerMerge() throws JNCException {
        markLeafMerge("iuReleaseTimer");
    }

    /**
     * Marks the leaf "iu-release-timer" with operation "create".
     */
    public void markIuReleaseTimerCreate() throws JNCException {
        markLeafCreate("iuReleaseTimer");
    }

    /**
     * Marks the leaf "iu-release-timer" with operation "delete".
     */
    public void markIuReleaseTimerDelete() throws JNCException {
        markLeafDelete("iuReleaseTimer");
    }

    /* Access methods for optional leaf child: "iu-signaling-act-timer". */

    /**
     * Gets the value for child leaf "iu-signaling-act-timer".
     * @return The value of the leaf.
     */
    public YangString getIuSignalingActTimerValue() throws JNCException {
        YangString iuSignalingActTimer = (YangString)getValue("iu-signaling-act-timer");
        if (iuSignalingActTimer == null) {
            iuSignalingActTimer = new YangString("5");  // default
        }
        return iuSignalingActTimer;
    }

    /**
     * Sets the value for child leaf "iu-signaling-act-timer",
     * using instance of generated typedef class.
     * @param iuSignalingActTimerValue The value to set.
     * @param iuSignalingActTimerValue used during instantiation.
     */
    public void setIuSignalingActTimerValue(YangString iuSignalingActTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "iu-signaling-act-timer",
            iuSignalingActTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "iu-signaling-act-timer",
     * using a String value.
     * @param iuSignalingActTimerValue used during instantiation.
     */
    public void setIuSignalingActTimerValue(String iuSignalingActTimerValue)
            throws JNCException {
        setIuSignalingActTimerValue(new YangString(iuSignalingActTimerValue));
    }

    /**
     * Unsets the value for child leaf "iu-signaling-act-timer".
     */
    public void unsetIuSignalingActTimerValue() throws JNCException {
        delete("iu-signaling-act-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "iu-signaling-act-timer" leaf will not have a value.
     */
    public void addIuSignalingActTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "iu-signaling-act-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "iu-signaling-act-timer" with operation "replace".
     */
    public void markIuSignalingActTimerReplace() throws JNCException {
        markLeafReplace("iuSignalingActTimer");
    }

    /**
     * Marks the leaf "iu-signaling-act-timer" with operation "merge".
     */
    public void markIuSignalingActTimerMerge() throws JNCException {
        markLeafMerge("iuSignalingActTimer");
    }

    /**
     * Marks the leaf "iu-signaling-act-timer" with operation "create".
     */
    public void markIuSignalingActTimerCreate() throws JNCException {
        markLeafCreate("iuSignalingActTimer");
    }

    /**
     * Marks the leaf "iu-signaling-act-timer" with operation "delete".
     */
    public void markIuSignalingActTimerDelete() throws JNCException {
        markLeafDelete("iuSignalingActTimer");
    }

    /* Access methods for optional leaf child: "security-mode-timer". */

    /**
     * Gets the value for child leaf "security-mode-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getSecurityModeTimerValue() throws JNCException {
        YangUInt8 securityModeTimer = (YangUInt8)getValue("security-mode-timer");
        if (securityModeTimer == null) {
            securityModeTimer = new YangUInt8("5");  // default
        }
        return securityModeTimer;
    }

    /**
     * Sets the value for child leaf "security-mode-timer",
     * using instance of generated typedef class.
     * @param securityModeTimerValue The value to set.
     * @param securityModeTimerValue used during instantiation.
     */
    public void setSecurityModeTimerValue(YangUInt8 securityModeTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-mode-timer",
            securityModeTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "security-mode-timer",
     * using Java primitive values.
     * @param securityModeTimerValue used during instantiation.
     */
    public void setSecurityModeTimerValue(short securityModeTimerValue)
            throws JNCException {
        setSecurityModeTimerValue(new YangUInt8(securityModeTimerValue));
    }

    /**
     * Sets the value for child leaf "security-mode-timer",
     * using a String value.
     * @param securityModeTimerValue used during instantiation.
     */
    public void setSecurityModeTimerValue(String securityModeTimerValue)
            throws JNCException {
        setSecurityModeTimerValue(new YangUInt8(securityModeTimerValue));
    }

    /**
     * Unsets the value for child leaf "security-mode-timer".
     */
    public void unsetSecurityModeTimerValue() throws JNCException {
        delete("security-mode-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "security-mode-timer" leaf will not have a value.
     */
    public void addSecurityModeTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-mode-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "security-mode-timer" with operation "replace".
     */
    public void markSecurityModeTimerReplace() throws JNCException {
        markLeafReplace("securityModeTimer");
    }

    /**
     * Marks the leaf "security-mode-timer" with operation "merge".
     */
    public void markSecurityModeTimerMerge() throws JNCException {
        markLeafMerge("securityModeTimer");
    }

    /**
     * Marks the leaf "security-mode-timer" with operation "create".
     */
    public void markSecurityModeTimerCreate() throws JNCException {
        markLeafCreate("securityModeTimer");
    }

    /**
     * Marks the leaf "security-mode-timer" with operation "delete".
     */
    public void markSecurityModeTimerDelete() throws JNCException {
        markLeafDelete("securityModeTimer");
    }

    /* Access methods for optional leaf child: "security-mode-retry". */

    /**
     * Gets the value for child leaf "security-mode-retry".
     * @return The value of the leaf.
     */
    public YangUInt8 getSecurityModeRetryValue() throws JNCException {
        YangUInt8 securityModeRetry = (YangUInt8)getValue("security-mode-retry");
        if (securityModeRetry == null) {
            securityModeRetry = new YangUInt8("2");  // default
        }
        return securityModeRetry;
    }

    /**
     * Sets the value for child leaf "security-mode-retry",
     * using instance of generated typedef class.
     * @param securityModeRetryValue The value to set.
     * @param securityModeRetryValue used during instantiation.
     */
    public void setSecurityModeRetryValue(YangUInt8 securityModeRetryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-mode-retry",
            securityModeRetryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "security-mode-retry",
     * using Java primitive values.
     * @param securityModeRetryValue used during instantiation.
     */
    public void setSecurityModeRetryValue(short securityModeRetryValue)
            throws JNCException {
        setSecurityModeRetryValue(new YangUInt8(securityModeRetryValue));
    }

    /**
     * Sets the value for child leaf "security-mode-retry",
     * using a String value.
     * @param securityModeRetryValue used during instantiation.
     */
    public void setSecurityModeRetryValue(String securityModeRetryValue)
            throws JNCException {
        setSecurityModeRetryValue(new YangUInt8(securityModeRetryValue));
    }

    /**
     * Unsets the value for child leaf "security-mode-retry".
     */
    public void unsetSecurityModeRetryValue() throws JNCException {
        delete("security-mode-retry");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "security-mode-retry" leaf will not have a value.
     */
    public void addSecurityModeRetry() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-mode-retry",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "security-mode-retry" with operation "replace".
     */
    public void markSecurityModeRetryReplace() throws JNCException {
        markLeafReplace("securityModeRetry");
    }

    /**
     * Marks the leaf "security-mode-retry" with operation "merge".
     */
    public void markSecurityModeRetryMerge() throws JNCException {
        markLeafMerge("securityModeRetry");
    }

    /**
     * Marks the leaf "security-mode-retry" with operation "create".
     */
    public void markSecurityModeRetryCreate() throws JNCException {
        markLeafCreate("securityModeRetry");
    }

    /**
     * Marks the leaf "security-mode-retry" with operation "delete".
     */
    public void markSecurityModeRetryDelete() throws JNCException {
        markLeafDelete("securityModeRetry");
    }

    /* Access methods for optional leaf child: "srns-rau-timer". */

    /**
     * Gets the value for child leaf "srns-rau-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getSrnsRauTimerValue() throws JNCException {
        YangUInt8 srnsRauTimer = (YangUInt8)getValue("srns-rau-timer");
        if (srnsRauTimer == null) {
            srnsRauTimer = new YangUInt8("5");  // default
        }
        return srnsRauTimer;
    }

    /**
     * Sets the value for child leaf "srns-rau-timer",
     * using instance of generated typedef class.
     * @param srnsRauTimerValue The value to set.
     * @param srnsRauTimerValue used during instantiation.
     */
    public void setSrnsRauTimerValue(YangUInt8 srnsRauTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "srns-rau-timer",
            srnsRauTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "srns-rau-timer",
     * using Java primitive values.
     * @param srnsRauTimerValue used during instantiation.
     */
    public void setSrnsRauTimerValue(short srnsRauTimerValue)
            throws JNCException {
        setSrnsRauTimerValue(new YangUInt8(srnsRauTimerValue));
    }

    /**
     * Sets the value for child leaf "srns-rau-timer",
     * using a String value.
     * @param srnsRauTimerValue used during instantiation.
     */
    public void setSrnsRauTimerValue(String srnsRauTimerValue)
            throws JNCException {
        setSrnsRauTimerValue(new YangUInt8(srnsRauTimerValue));
    }

    /**
     * Unsets the value for child leaf "srns-rau-timer".
     */
    public void unsetSrnsRauTimerValue() throws JNCException {
        delete("srns-rau-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "srns-rau-timer" leaf will not have a value.
     */
    public void addSrnsRauTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "srns-rau-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "srns-rau-timer" with operation "replace".
     */
    public void markSrnsRauTimerReplace() throws JNCException {
        markLeafReplace("srnsRauTimer");
    }

    /**
     * Marks the leaf "srns-rau-timer" with operation "merge".
     */
    public void markSrnsRauTimerMerge() throws JNCException {
        markLeafMerge("srnsRauTimer");
    }

    /**
     * Marks the leaf "srns-rau-timer" with operation "create".
     */
    public void markSrnsRauTimerCreate() throws JNCException {
        markLeafCreate("srnsRauTimer");
    }

    /**
     * Marks the leaf "srns-rau-timer" with operation "delete".
     */
    public void markSrnsRauTimerDelete() throws JNCException {
        markLeafDelete("srnsRauTimer");
    }

    /* Access methods for optional leaf child: "inter-rat-indirect-forwarding". */

    /**
     * Gets the value for child leaf "inter-rat-indirect-forwarding".
     * @return The value of the leaf.
     */
    public YangEnumeration getInterRatIndirectForwardingValue()
            throws JNCException {
        YangEnumeration interRatIndirectForwarding = (YangEnumeration)getValue("inter-rat-indirect-forwarding");
        if (interRatIndirectForwarding == null) {
            interRatIndirectForwarding = new YangEnumeration("never", new String[] {  // default
                "never",
                "always",
                "inter-plmn-inter-rat",
            });
        }
        return interRatIndirectForwarding;
    }

    /**
     * Sets the value for child leaf "inter-rat-indirect-forwarding",
     * using instance of generated typedef class.
     * @param interRatIndirectForwardingValue The value to set.
     * @param interRatIndirectForwardingValue used during instantiation.
     */
    public void setInterRatIndirectForwardingValue(YangEnumeration interRatIndirectForwardingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "inter-rat-indirect-forwarding",
            interRatIndirectForwardingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "inter-rat-indirect-forwarding",
     * using a String value.
     * @param interRatIndirectForwardingValue used during instantiation.
     */
    public void setInterRatIndirectForwardingValue(String interRatIndirectForwardingValue)
            throws JNCException {
        setInterRatIndirectForwardingValue(new YangEnumeration(interRatIndirectForwardingValue, new String[] {
             "never",
             "always",
             "inter-plmn-inter-rat",
        }));
    }

    /**
     * Unsets the value for child leaf "inter-rat-indirect-forwarding".
     */
    public void unsetInterRatIndirectForwardingValue() throws JNCException {
        delete("inter-rat-indirect-forwarding");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "inter-rat-indirect-forwarding" leaf will not have a value.
     */
    public void addInterRatIndirectForwarding() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "inter-rat-indirect-forwarding",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "replace".
     */
    public void markInterRatIndirectForwardingReplace() throws JNCException {
        markLeafReplace("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "merge".
     */
    public void markInterRatIndirectForwardingMerge() throws JNCException {
        markLeafMerge("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "create".
     */
    public void markInterRatIndirectForwardingCreate() throws JNCException {
        markLeafCreate("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "delete".
     */
    public void markInterRatIndirectForwardingDelete() throws JNCException {
        markLeafDelete("interRatIndirectForwarding");
    }

    /* Access methods for optional leaf child: "indirect-data-fwd-ip-address". */

    /**
     * Gets the value for child leaf "indirect-data-fwd-ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getIndirectDataFwdIpAddressValue() throws JNCException {
        IpAddress indirectDataFwdIpAddress = (IpAddress)getValue("indirect-data-fwd-ip-address");
        if (indirectDataFwdIpAddress == null) {
            indirectDataFwdIpAddress = new IpAddress("0.0.0.0");  // default
        }
        return indirectDataFwdIpAddress;
    }

    /**
     * Sets the value for child leaf "indirect-data-fwd-ip-address",
     * using a JNC type value.
     * @param indirectDataFwdIpAddressValue The value to set.
     * @param indirectDataFwdIpAddressValue used during instantiation.
     */
    public void setIndirectDataFwdIpAddressValue(IpAddress indirectDataFwdIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-data-fwd-ip-address",
            indirectDataFwdIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "indirect-data-fwd-ip-address",
     * using a String value.
     * @param indirectDataFwdIpAddressValue used during instantiation.
     */
    public void setIndirectDataFwdIpAddressValue(String indirectDataFwdIpAddressValue)
            throws JNCException {
        setIndirectDataFwdIpAddressValue(new IpAddress(indirectDataFwdIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "indirect-data-fwd-ip-address".
     */
    public void unsetIndirectDataFwdIpAddressValue() throws JNCException {
        delete("indirect-data-fwd-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "indirect-data-fwd-ip-address" leaf will not have a value.
     */
    public void addIndirectDataFwdIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-data-fwd-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "replace".
     */
    public void markIndirectDataFwdIpAddressReplace() throws JNCException {
        markLeafReplace("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "merge".
     */
    public void markIndirectDataFwdIpAddressMerge() throws JNCException {
        markLeafMerge("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "create".
     */
    public void markIndirectDataFwdIpAddressCreate() throws JNCException {
        markLeafCreate("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "delete".
     */
    public void markIndirectDataFwdIpAddressDelete() throws JNCException {
        markLeafDelete("indirectDataFwdIpAddress");
    }

    /* Access methods for optional leaf child: "indirect-tunnel-hold-timer". */

    /**
     * Gets the value for child leaf "indirect-tunnel-hold-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getIndirectTunnelHoldTimerValue() throws JNCException {
        YangUInt8 indirectTunnelHoldTimer = (YangUInt8)getValue("indirect-tunnel-hold-timer");
        if (indirectTunnelHoldTimer == null) {
            indirectTunnelHoldTimer = new YangUInt8("5");  // default
        }
        return indirectTunnelHoldTimer;
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using instance of generated typedef class.
     * @param indirectTunnelHoldTimerValue The value to set.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(YangUInt8 indirectTunnelHoldTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-tunnel-hold-timer",
            indirectTunnelHoldTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using Java primitive values.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(short indirectTunnelHoldTimerValue)
            throws JNCException {
        setIndirectTunnelHoldTimerValue(new YangUInt8(indirectTunnelHoldTimerValue));
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using a String value.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(String indirectTunnelHoldTimerValue)
            throws JNCException {
        setIndirectTunnelHoldTimerValue(new YangUInt8(indirectTunnelHoldTimerValue));
    }

    /**
     * Unsets the value for child leaf "indirect-tunnel-hold-timer".
     */
    public void unsetIndirectTunnelHoldTimerValue() throws JNCException {
        delete("indirect-tunnel-hold-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "indirect-tunnel-hold-timer" leaf will not have a value.
     */
    public void addIndirectTunnelHoldTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-tunnel-hold-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "replace".
     */
    public void markIndirectTunnelHoldTimerReplace() throws JNCException {
        markLeafReplace("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "merge".
     */
    public void markIndirectTunnelHoldTimerMerge() throws JNCException {
        markLeafMerge("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "create".
     */
    public void markIndirectTunnelHoldTimerCreate() throws JNCException {
        markLeafCreate("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "delete".
     */
    public void markIndirectTunnelHoldTimerDelete() throws JNCException {
        markLeafDelete("indirectTunnelHoldTimer");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10.9.0", new String[] {  // default
                "9.5.0",
                "10.9.0",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "9.5.0",
             "10.9.0",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /* Access methods for optional leaf child: "reloc-resource-release-timer". */

    /**
     * Gets the value for child leaf "reloc-resource-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRelocResourceReleaseTimerValue() throws JNCException {
        YangUInt8 relocResourceReleaseTimer = (YangUInt8)getValue("reloc-resource-release-timer");
        if (relocResourceReleaseTimer == null) {
            relocResourceReleaseTimer = new YangUInt8("5");  // default
        }
        return relocResourceReleaseTimer;
    }

    /**
     * Sets the value for child leaf "reloc-resource-release-timer",
     * using instance of generated typedef class.
     * @param relocResourceReleaseTimerValue The value to set.
     * @param relocResourceReleaseTimerValue used during instantiation.
     */
    public void setRelocResourceReleaseTimerValue(YangUInt8 relocResourceReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-resource-release-timer",
            relocResourceReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reloc-resource-release-timer",
     * using Java primitive values.
     * @param relocResourceReleaseTimerValue used during instantiation.
     */
    public void setRelocResourceReleaseTimerValue(short relocResourceReleaseTimerValue)
            throws JNCException {
        setRelocResourceReleaseTimerValue(new YangUInt8(relocResourceReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "reloc-resource-release-timer",
     * using a String value.
     * @param relocResourceReleaseTimerValue used during instantiation.
     */
    public void setRelocResourceReleaseTimerValue(String relocResourceReleaseTimerValue)
            throws JNCException {
        setRelocResourceReleaseTimerValue(new YangUInt8(relocResourceReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "reloc-resource-release-timer".
     */
    public void unsetRelocResourceReleaseTimerValue() throws JNCException {
        delete("reloc-resource-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reloc-resource-release-timer" leaf will not have a value.
     */
    public void addRelocResourceReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-resource-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reloc-resource-release-timer" with operation "replace".
     */
    public void markRelocResourceReleaseTimerReplace() throws JNCException {
        markLeafReplace("relocResourceReleaseTimer");
    }

    /**
     * Marks the leaf "reloc-resource-release-timer" with operation "merge".
     */
    public void markRelocResourceReleaseTimerMerge() throws JNCException {
        markLeafMerge("relocResourceReleaseTimer");
    }

    /**
     * Marks the leaf "reloc-resource-release-timer" with operation "create".
     */
    public void markRelocResourceReleaseTimerCreate() throws JNCException {
        markLeafCreate("relocResourceReleaseTimer");
    }

    /**
     * Marks the leaf "reloc-resource-release-timer" with operation "delete".
     */
    public void markRelocResourceReleaseTimerDelete() throws JNCException {
        markLeafDelete("relocResourceReleaseTimer");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /* Access methods for optional leaf child: "csg-expiration-release-timer". */

    /**
     * Gets the value for child leaf "csg-expiration-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getCsgExpirationReleaseTimerValue() throws JNCException {
        YangUInt8 csgExpirationReleaseTimer = (YangUInt8)getValue("csg-expiration-release-timer");
        if (csgExpirationReleaseTimer == null) {
            csgExpirationReleaseTimer = new YangUInt8("5");  // default
        }
        return csgExpirationReleaseTimer;
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using instance of generated typedef class.
     * @param csgExpirationReleaseTimerValue The value to set.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(YangUInt8 csgExpirationReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-expiration-release-timer",
            csgExpirationReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using Java primitive values.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(short csgExpirationReleaseTimerValue)
            throws JNCException {
        setCsgExpirationReleaseTimerValue(new YangUInt8(csgExpirationReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using a String value.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(String csgExpirationReleaseTimerValue)
            throws JNCException {
        setCsgExpirationReleaseTimerValue(new YangUInt8(csgExpirationReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "csg-expiration-release-timer".
     */
    public void unsetCsgExpirationReleaseTimerValue() throws JNCException {
        delete("csg-expiration-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csg-expiration-release-timer" leaf will not have a value.
     */
    public void addCsgExpirationReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-expiration-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "replace".
     */
    public void markCsgExpirationReleaseTimerReplace() throws JNCException {
        markLeafReplace("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "merge".
     */
    public void markCsgExpirationReleaseTimerMerge() throws JNCException {
        markLeafMerge("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "create".
     */
    public void markCsgExpirationReleaseTimerCreate() throws JNCException {
        markLeafCreate("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "delete".
     */
    public void markCsgExpirationReleaseTimerDelete() throws JNCException {
        markLeafDelete("csgExpirationReleaseTimer");
    }

    /* Access methods for optional leaf child: "signaling-variant". */

    /**
     * Gets the value for child leaf "signaling-variant".
     * @return The value of the leaf.
     */
    public YangEnumeration getSignalingVariantValue() throws JNCException {
        YangEnumeration signalingVariant = (YangEnumeration)getValue("signaling-variant");
        if (signalingVariant == null) {
            signalingVariant = new YangEnumeration("itu", new String[] {  // default
                "itu",
                "ansi",
            });
        }
        return signalingVariant;
    }

    /**
     * Sets the value for child leaf "signaling-variant",
     * using instance of generated typedef class.
     * @param signalingVariantValue The value to set.
     * @param signalingVariantValue used during instantiation.
     */
    public void setSignalingVariantValue(YangEnumeration signalingVariantValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "signaling-variant",
            signalingVariantValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "signaling-variant",
     * using a String value.
     * @param signalingVariantValue used during instantiation.
     */
    public void setSignalingVariantValue(String signalingVariantValue)
            throws JNCException {
        setSignalingVariantValue(new YangEnumeration(signalingVariantValue, new String[] {
             "itu",
             "ansi",
        }));
    }

    /**
     * Unsets the value for child leaf "signaling-variant".
     */
    public void unsetSignalingVariantValue() throws JNCException {
        delete("signaling-variant");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "signaling-variant" leaf will not have a value.
     */
    public void addSignalingVariant() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "signaling-variant",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "signaling-variant" with operation "replace".
     */
    public void markSignalingVariantReplace() throws JNCException {
        markLeafReplace("signalingVariant");
    }

    /**
     * Marks the leaf "signaling-variant" with operation "merge".
     */
    public void markSignalingVariantMerge() throws JNCException {
        markLeafMerge("signalingVariant");
    }

    /**
     * Marks the leaf "signaling-variant" with operation "create".
     */
    public void markSignalingVariantCreate() throws JNCException {
        markLeafCreate("signalingVariant");
    }

    /**
     * Marks the leaf "signaling-variant" with operation "delete".
     */
    public void markSignalingVariantDelete() throws JNCException {
        markLeafDelete("signalingVariant");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
