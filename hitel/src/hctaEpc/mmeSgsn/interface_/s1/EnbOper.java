/* 
 * @(#)EnbOper.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.s1;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/s1/enb-oper"
 * <p>
 * See line 91 in
 * s1MasterCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class EnbOper extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty EnbOper object.
     */
    public EnbOper() {
        super(Epc.NAMESPACE, "enb-oper");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public EnbOper clone() {
        return (EnbOper)cloneContent(new EnbOper());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public EnbOper cloneShallow() {
        return (EnbOper)cloneShallowContent(new EnbOper());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "plmn-id",
            "enodeb-id",
            "enodeb-type",
            "ip-address1",
            "ip-address2",
            "enodeb-name",
            "process-pid",
            "service",
            "overload-start-sent",
            "connection-state",
            "csg-list",
            "cell-access-mode",
        };
    }

    /* Access methods for optional leaf child: "plmn-id". */

    /**
     * Gets the value for child leaf "plmn-id".
     * @return The value of the leaf.
     */
    public YangString getPlmnIdValue() throws JNCException {
        return (YangString)getValue("plmn-id");
    }

    /**
     * Sets the value for child leaf "plmn-id",
     * using instance of generated typedef class.
     * @param plmnIdValue The value to set.
     * @param plmnIdValue used during instantiation.
     */
    public void setPlmnIdValue(YangString plmnIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "plmn-id",
            plmnIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "plmn-id",
     * using a String value.
     * @param plmnIdValue used during instantiation.
     */
    public void setPlmnIdValue(String plmnIdValue) throws JNCException {
        setPlmnIdValue(new YangString(plmnIdValue));
    }

    /**
     * Unsets the value for child leaf "plmn-id".
     */
    public void unsetPlmnIdValue() throws JNCException {
        delete("plmn-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "plmn-id" leaf will not have a value.
     */
    public void addPlmnId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "plmn-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "plmn-id" with operation "replace".
     */
    public void markPlmnIdReplace() throws JNCException {
        markLeafReplace("plmnId");
    }

    /**
     * Marks the leaf "plmn-id" with operation "merge".
     */
    public void markPlmnIdMerge() throws JNCException {
        markLeafMerge("plmnId");
    }

    /**
     * Marks the leaf "plmn-id" with operation "create".
     */
    public void markPlmnIdCreate() throws JNCException {
        markLeafCreate("plmnId");
    }

    /**
     * Marks the leaf "plmn-id" with operation "delete".
     */
    public void markPlmnIdDelete() throws JNCException {
        markLeafDelete("plmnId");
    }

    /* Access methods for optional leaf child: "enodeb-id". */

    /**
     * Gets the value for child leaf "enodeb-id".
     * @return The value of the leaf.
     */
    public YangUInt32 getEnodebIdValue() throws JNCException {
        return (YangUInt32)getValue("enodeb-id");
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using instance of generated typedef class.
     * @param enodebIdValue The value to set.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(YangUInt32 enodebIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-id",
            enodebIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using Java primitive values.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(long enodebIdValue) throws JNCException {
        setEnodebIdValue(new YangUInt32(enodebIdValue));
    }

    /**
     * Sets the value for child leaf "enodeb-id",
     * using a String value.
     * @param enodebIdValue used during instantiation.
     */
    public void setEnodebIdValue(String enodebIdValue) throws JNCException {
        setEnodebIdValue(new YangUInt32(enodebIdValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-id".
     */
    public void unsetEnodebIdValue() throws JNCException {
        delete("enodeb-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-id" leaf will not have a value.
     */
    public void addEnodebId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-id" with operation "replace".
     */
    public void markEnodebIdReplace() throws JNCException {
        markLeafReplace("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "merge".
     */
    public void markEnodebIdMerge() throws JNCException {
        markLeafMerge("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "create".
     */
    public void markEnodebIdCreate() throws JNCException {
        markLeafCreate("enodebId");
    }

    /**
     * Marks the leaf "enodeb-id" with operation "delete".
     */
    public void markEnodebIdDelete() throws JNCException {
        markLeafDelete("enodebId");
    }

    /* Access methods for optional leaf child: "enodeb-type". */

    /**
     * Gets the value for child leaf "enodeb-type".
     * @return The value of the leaf.
     */
    public YangString getEnodebTypeValue() throws JNCException {
        return (YangString)getValue("enodeb-type");
    }

    /**
     * Sets the value for child leaf "enodeb-type",
     * using instance of generated typedef class.
     * @param enodebTypeValue The value to set.
     * @param enodebTypeValue used during instantiation.
     */
    public void setEnodebTypeValue(YangString enodebTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-type",
            enodebTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-type",
     * using a String value.
     * @param enodebTypeValue used during instantiation.
     */
    public void setEnodebTypeValue(String enodebTypeValue) throws JNCException {
        setEnodebTypeValue(new YangString(enodebTypeValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-type".
     */
    public void unsetEnodebTypeValue() throws JNCException {
        delete("enodeb-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-type" leaf will not have a value.
     */
    public void addEnodebType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-type" with operation "replace".
     */
    public void markEnodebTypeReplace() throws JNCException {
        markLeafReplace("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "merge".
     */
    public void markEnodebTypeMerge() throws JNCException {
        markLeafMerge("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "create".
     */
    public void markEnodebTypeCreate() throws JNCException {
        markLeafCreate("enodebType");
    }

    /**
     * Marks the leaf "enodeb-type" with operation "delete".
     */
    public void markEnodebTypeDelete() throws JNCException {
        markLeafDelete("enodebType");
    }

    /* Access methods for optional leaf child: "ip-address1". */

    /**
     * Gets the value for child leaf "ip-address1".
     * @return The value of the leaf.
     */
    public IpAddress getIpAddress1Value() throws JNCException {
        return (IpAddress)getValue("ip-address1");
    }

    /**
     * Sets the value for child leaf "ip-address1",
     * using a JNC type value.
     * @param ipAddress1Value The value to set.
     * @param ipAddress1Value used during instantiation.
     */
    public void setIpAddress1Value(IpAddress ipAddress1Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1",
            ipAddress1Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address1",
     * using a String value.
     * @param ipAddress1Value used during instantiation.
     */
    public void setIpAddress1Value(String ipAddress1Value) throws JNCException {
        setIpAddress1Value(new IpAddress(ipAddress1Value));
    }

    /**
     * Unsets the value for child leaf "ip-address1".
     */
    public void unsetIpAddress1Value() throws JNCException {
        delete("ip-address1");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address1" leaf will not have a value.
     */
    public void addIpAddress1() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address1" with operation "replace".
     */
    public void markIpAddress1Replace() throws JNCException {
        markLeafReplace("ipAddress1");
    }

    /**
     * Marks the leaf "ip-address1" with operation "merge".
     */
    public void markIpAddress1Merge() throws JNCException {
        markLeafMerge("ipAddress1");
    }

    /**
     * Marks the leaf "ip-address1" with operation "create".
     */
    public void markIpAddress1Create() throws JNCException {
        markLeafCreate("ipAddress1");
    }

    /**
     * Marks the leaf "ip-address1" with operation "delete".
     */
    public void markIpAddress1Delete() throws JNCException {
        markLeafDelete("ipAddress1");
    }

    /* Access methods for optional leaf child: "ip-address2". */

    /**
     * Gets the value for child leaf "ip-address2".
     * @return The value of the leaf.
     */
    public IpAddress getIpAddress2Value() throws JNCException {
        return (IpAddress)getValue("ip-address2");
    }

    /**
     * Sets the value for child leaf "ip-address2",
     * using a JNC type value.
     * @param ipAddress2Value The value to set.
     * @param ipAddress2Value used during instantiation.
     */
    public void setIpAddress2Value(IpAddress ipAddress2Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2",
            ipAddress2Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address2",
     * using a String value.
     * @param ipAddress2Value used during instantiation.
     */
    public void setIpAddress2Value(String ipAddress2Value) throws JNCException {
        setIpAddress2Value(new IpAddress(ipAddress2Value));
    }

    /**
     * Unsets the value for child leaf "ip-address2".
     */
    public void unsetIpAddress2Value() throws JNCException {
        delete("ip-address2");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address2" leaf will not have a value.
     */
    public void addIpAddress2() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address2" with operation "replace".
     */
    public void markIpAddress2Replace() throws JNCException {
        markLeafReplace("ipAddress2");
    }

    /**
     * Marks the leaf "ip-address2" with operation "merge".
     */
    public void markIpAddress2Merge() throws JNCException {
        markLeafMerge("ipAddress2");
    }

    /**
     * Marks the leaf "ip-address2" with operation "create".
     */
    public void markIpAddress2Create() throws JNCException {
        markLeafCreate("ipAddress2");
    }

    /**
     * Marks the leaf "ip-address2" with operation "delete".
     */
    public void markIpAddress2Delete() throws JNCException {
        markLeafDelete("ipAddress2");
    }

    /* Access methods for optional leaf child: "enodeb-name". */

    /**
     * Gets the value for child leaf "enodeb-name".
     * @return The value of the leaf.
     */
    public YangString getEnodebNameValue() throws JNCException {
        return (YangString)getValue("enodeb-name");
    }

    /**
     * Sets the value for child leaf "enodeb-name",
     * using instance of generated typedef class.
     * @param enodebNameValue The value to set.
     * @param enodebNameValue used during instantiation.
     */
    public void setEnodebNameValue(YangString enodebNameValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-name",
            enodebNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enodeb-name",
     * using a String value.
     * @param enodebNameValue used during instantiation.
     */
    public void setEnodebNameValue(String enodebNameValue) throws JNCException {
        setEnodebNameValue(new YangString(enodebNameValue));
    }

    /**
     * Unsets the value for child leaf "enodeb-name".
     */
    public void unsetEnodebNameValue() throws JNCException {
        delete("enodeb-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enodeb-name" leaf will not have a value.
     */
    public void addEnodebName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enodeb-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enodeb-name" with operation "replace".
     */
    public void markEnodebNameReplace() throws JNCException {
        markLeafReplace("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "merge".
     */
    public void markEnodebNameMerge() throws JNCException {
        markLeafMerge("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "create".
     */
    public void markEnodebNameCreate() throws JNCException {
        markLeafCreate("enodebName");
    }

    /**
     * Marks the leaf "enodeb-name" with operation "delete".
     */
    public void markEnodebNameDelete() throws JNCException {
        markLeafDelete("enodebName");
    }

    /* Access methods for optional leaf child: "process-pid". */

    /**
     * Gets the value for child leaf "process-pid".
     * @return The value of the leaf.
     */
    public YangUInt32 getProcessPidValue() throws JNCException {
        return (YangUInt32)getValue("process-pid");
    }

    /**
     * Sets the value for child leaf "process-pid",
     * using instance of generated typedef class.
     * @param processPidValue The value to set.
     * @param processPidValue used during instantiation.
     */
    public void setProcessPidValue(YangUInt32 processPidValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "process-pid",
            processPidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "process-pid",
     * using Java primitive values.
     * @param processPidValue used during instantiation.
     */
    public void setProcessPidValue(long processPidValue) throws JNCException {
        setProcessPidValue(new YangUInt32(processPidValue));
    }

    /**
     * Sets the value for child leaf "process-pid",
     * using a String value.
     * @param processPidValue used during instantiation.
     */
    public void setProcessPidValue(String processPidValue) throws JNCException {
        setProcessPidValue(new YangUInt32(processPidValue));
    }

    /**
     * Unsets the value for child leaf "process-pid".
     */
    public void unsetProcessPidValue() throws JNCException {
        delete("process-pid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "process-pid" leaf will not have a value.
     */
    public void addProcessPid() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "process-pid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "process-pid" with operation "replace".
     */
    public void markProcessPidReplace() throws JNCException {
        markLeafReplace("processPid");
    }

    /**
     * Marks the leaf "process-pid" with operation "merge".
     */
    public void markProcessPidMerge() throws JNCException {
        markLeafMerge("processPid");
    }

    /**
     * Marks the leaf "process-pid" with operation "create".
     */
    public void markProcessPidCreate() throws JNCException {
        markLeafCreate("processPid");
    }

    /**
     * Marks the leaf "process-pid" with operation "delete".
     */
    public void markProcessPidDelete() throws JNCException {
        markLeafDelete("processPid");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "overload-start-sent". */

    /**
     * Gets the value for child leaf "overload-start-sent".
     * @return The value of the leaf.
     */
    public YangString getOverloadStartSentValue() throws JNCException {
        return (YangString)getValue("overload-start-sent");
    }

    /**
     * Sets the value for child leaf "overload-start-sent",
     * using instance of generated typedef class.
     * @param overloadStartSentValue The value to set.
     * @param overloadStartSentValue used during instantiation.
     */
    public void setOverloadStartSentValue(YangString overloadStartSentValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "overload-start-sent",
            overloadStartSentValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "overload-start-sent",
     * using a String value.
     * @param overloadStartSentValue used during instantiation.
     */
    public void setOverloadStartSentValue(String overloadStartSentValue)
            throws JNCException {
        setOverloadStartSentValue(new YangString(overloadStartSentValue));
    }

    /**
     * Unsets the value for child leaf "overload-start-sent".
     */
    public void unsetOverloadStartSentValue() throws JNCException {
        delete("overload-start-sent");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "overload-start-sent" leaf will not have a value.
     */
    public void addOverloadStartSent() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "overload-start-sent",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "overload-start-sent" with operation "replace".
     */
    public void markOverloadStartSentReplace() throws JNCException {
        markLeafReplace("overloadStartSent");
    }

    /**
     * Marks the leaf "overload-start-sent" with operation "merge".
     */
    public void markOverloadStartSentMerge() throws JNCException {
        markLeafMerge("overloadStartSent");
    }

    /**
     * Marks the leaf "overload-start-sent" with operation "create".
     */
    public void markOverloadStartSentCreate() throws JNCException {
        markLeafCreate("overloadStartSent");
    }

    /**
     * Marks the leaf "overload-start-sent" with operation "delete".
     */
    public void markOverloadStartSentDelete() throws JNCException {
        markLeafDelete("overloadStartSent");
    }

    /* Access methods for optional leaf child: "connection-state". */

    /**
     * Gets the value for child leaf "connection-state".
     * @return The value of the leaf.
     */
    public YangString getConnectionStateValue() throws JNCException {
        return (YangString)getValue("connection-state");
    }

    /**
     * Sets the value for child leaf "connection-state",
     * using instance of generated typedef class.
     * @param connectionStateValue The value to set.
     * @param connectionStateValue used during instantiation.
     */
    public void setConnectionStateValue(YangString connectionStateValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "connection-state",
            connectionStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "connection-state",
     * using a String value.
     * @param connectionStateValue used during instantiation.
     */
    public void setConnectionStateValue(String connectionStateValue)
            throws JNCException {
        setConnectionStateValue(new YangString(connectionStateValue));
    }

    /**
     * Unsets the value for child leaf "connection-state".
     */
    public void unsetConnectionStateValue() throws JNCException {
        delete("connection-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "connection-state" leaf will not have a value.
     */
    public void addConnectionState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "connection-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "connection-state" with operation "replace".
     */
    public void markConnectionStateReplace() throws JNCException {
        markLeafReplace("connectionState");
    }

    /**
     * Marks the leaf "connection-state" with operation "merge".
     */
    public void markConnectionStateMerge() throws JNCException {
        markLeafMerge("connectionState");
    }

    /**
     * Marks the leaf "connection-state" with operation "create".
     */
    public void markConnectionStateCreate() throws JNCException {
        markLeafCreate("connectionState");
    }

    /**
     * Marks the leaf "connection-state" with operation "delete".
     */
    public void markConnectionStateDelete() throws JNCException {
        markLeafDelete("connectionState");
    }

    /* Access methods for optional leaf child: "csg-list". */

    /**
     * Gets the value for child leaf "csg-list".
     * @return The value of the leaf.
     */
    public YangString getCsgListValue() throws JNCException {
        return (YangString)getValue("csg-list");
    }

    /**
     * Sets the value for child leaf "csg-list",
     * using instance of generated typedef class.
     * @param csgListValue The value to set.
     * @param csgListValue used during instantiation.
     */
    public void setCsgListValue(YangString csgListValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-list",
            csgListValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csg-list",
     * using a String value.
     * @param csgListValue used during instantiation.
     */
    public void setCsgListValue(String csgListValue) throws JNCException {
        setCsgListValue(new YangString(csgListValue));
    }

    /**
     * Unsets the value for child leaf "csg-list".
     */
    public void unsetCsgListValue() throws JNCException {
        delete("csg-list");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csg-list" leaf will not have a value.
     */
    public void addCsgList() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-list",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csg-list" with operation "replace".
     */
    public void markCsgListReplace() throws JNCException {
        markLeafReplace("csgList");
    }

    /**
     * Marks the leaf "csg-list" with operation "merge".
     */
    public void markCsgListMerge() throws JNCException {
        markLeafMerge("csgList");
    }

    /**
     * Marks the leaf "csg-list" with operation "create".
     */
    public void markCsgListCreate() throws JNCException {
        markLeafCreate("csgList");
    }

    /**
     * Marks the leaf "csg-list" with operation "delete".
     */
    public void markCsgListDelete() throws JNCException {
        markLeafDelete("csgList");
    }

    /* Access methods for optional leaf child: "cell-access-mode". */

    /**
     * Gets the value for child leaf "cell-access-mode".
     * @return The value of the leaf.
     */
    public YangString getCellAccessModeValue() throws JNCException {
        return (YangString)getValue("cell-access-mode");
    }

    /**
     * Sets the value for child leaf "cell-access-mode",
     * using instance of generated typedef class.
     * @param cellAccessModeValue The value to set.
     * @param cellAccessModeValue used during instantiation.
     */
    public void setCellAccessModeValue(YangString cellAccessModeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-access-mode",
            cellAccessModeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cell-access-mode",
     * using a String value.
     * @param cellAccessModeValue used during instantiation.
     */
    public void setCellAccessModeValue(String cellAccessModeValue)
            throws JNCException {
        setCellAccessModeValue(new YangString(cellAccessModeValue));
    }

    /**
     * Unsets the value for child leaf "cell-access-mode".
     */
    public void unsetCellAccessModeValue() throws JNCException {
        delete("cell-access-mode");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cell-access-mode" leaf will not have a value.
     */
    public void addCellAccessMode() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cell-access-mode",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "replace".
     */
    public void markCellAccessModeReplace() throws JNCException {
        markLeafReplace("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "merge".
     */
    public void markCellAccessModeMerge() throws JNCException {
        markLeafMerge("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "create".
     */
    public void markCellAccessModeCreate() throws JNCException {
        markLeafCreate("cellAccessMode");
    }

    /**
     * Marks the leaf "cell-access-mode" with operation "delete".
     */
    public void markCellAccessModeDelete() throws JNCException {
        markLeafDelete("cellAccessMode");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
