/* 
 * @(#)MmeS1Interface.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.s1;
import .ietfInetTypes.IpAddress;
import .ietfInetTypes.Ipv4Address;
import .ietfInetTypes.Ipv6Address;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt32;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/s1/mme-s1-interface"
 * <p>
 * See line 162 in
 * s1MasterConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeS1Interface extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeS1Interface object.
     */
    public MmeS1Interface() {
        super(Epc.NAMESPACE, "mme-s1-interface");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeS1Interface clone() {
        return (MmeS1Interface)cloneContent(new MmeS1Interface());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeS1Interface cloneShallow() {
        return (MmeS1Interface)cloneShallowContent(new MmeS1Interface());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "routing-instance1",
            "routing-instance2",
            "sctp-profile",
            "ip-address1-v4",
            "ip-address2-v4",
            "ip-address1-v6",
            "ip-address2-v6",
            "port",
            "time-to-wait",
            "reloc-prep-timer",
            "reloc-overall-timer",
            "indirect-tunnel-hold-timer",
            "handover-resource-release-timer",
            "ue-context-release-timer",
            "ue-context-modification-timer",
            "wait-for-tau-timer",
            "dscp-mark",
            "inter-rat-indirect-forwarding",
            "intra-rat-indirect-forwarding",
            "indirect-data-fwd-ip-address",
            "version",
            "enb-alarm-clear-time",
            "location-reporting-control",
            "lrc-timer-direct",
            "csg-expiration-release-timer",
            "fgw-sctp-profile",
            "reset-ack-delay-timer",
            "message-logging",
            "warning-message-timer",
            "warning-message-retry",
            "sgw-gtpu-dual-tla-ip-filter",
        };
    }

    /* Access methods for optional leaf child: "routing-instance1". */

    /**
     * Gets the value for child leaf "routing-instance1".
     * @return The value of the leaf.
     */
    public YangString getRoutingInstance1Value() throws JNCException {
        return (YangString)getValue("routing-instance1");
    }

    /**
     * Sets the value for child leaf "routing-instance1",
     * using instance of generated typedef class.
     * @param routingInstance1Value The value to set.
     * @param routingInstance1Value used during instantiation.
     */
    public void setRoutingInstance1Value(YangString routingInstance1Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance1",
            routingInstance1Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "routing-instance1",
     * using a String value.
     * @param routingInstance1Value used during instantiation.
     */
    public void setRoutingInstance1Value(String routingInstance1Value)
            throws JNCException {
        setRoutingInstance1Value(new YangString(routingInstance1Value));
    }

    /**
     * Unsets the value for child leaf "routing-instance1".
     */
    public void unsetRoutingInstance1Value() throws JNCException {
        delete("routing-instance1");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "routing-instance1" leaf will not have a value.
     */
    public void addRoutingInstance1() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance1",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "routing-instance1" with operation "replace".
     */
    public void markRoutingInstance1Replace() throws JNCException {
        markLeafReplace("routingInstance1");
    }

    /**
     * Marks the leaf "routing-instance1" with operation "merge".
     */
    public void markRoutingInstance1Merge() throws JNCException {
        markLeafMerge("routingInstance1");
    }

    /**
     * Marks the leaf "routing-instance1" with operation "create".
     */
    public void markRoutingInstance1Create() throws JNCException {
        markLeafCreate("routingInstance1");
    }

    /**
     * Marks the leaf "routing-instance1" with operation "delete".
     */
    public void markRoutingInstance1Delete() throws JNCException {
        markLeafDelete("routingInstance1");
    }

    /* Access methods for optional leaf child: "routing-instance2". */

    /**
     * Gets the value for child leaf "routing-instance2".
     * @return The value of the leaf.
     */
    public YangString getRoutingInstance2Value() throws JNCException {
        return (YangString)getValue("routing-instance2");
    }

    /**
     * Sets the value for child leaf "routing-instance2",
     * using instance of generated typedef class.
     * @param routingInstance2Value The value to set.
     * @param routingInstance2Value used during instantiation.
     */
    public void setRoutingInstance2Value(YangString routingInstance2Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance2",
            routingInstance2Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "routing-instance2",
     * using a String value.
     * @param routingInstance2Value used during instantiation.
     */
    public void setRoutingInstance2Value(String routingInstance2Value)
            throws JNCException {
        setRoutingInstance2Value(new YangString(routingInstance2Value));
    }

    /**
     * Unsets the value for child leaf "routing-instance2".
     */
    public void unsetRoutingInstance2Value() throws JNCException {
        delete("routing-instance2");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "routing-instance2" leaf will not have a value.
     */
    public void addRoutingInstance2() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance2",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "routing-instance2" with operation "replace".
     */
    public void markRoutingInstance2Replace() throws JNCException {
        markLeafReplace("routingInstance2");
    }

    /**
     * Marks the leaf "routing-instance2" with operation "merge".
     */
    public void markRoutingInstance2Merge() throws JNCException {
        markLeafMerge("routingInstance2");
    }

    /**
     * Marks the leaf "routing-instance2" with operation "create".
     */
    public void markRoutingInstance2Create() throws JNCException {
        markLeafCreate("routingInstance2");
    }

    /**
     * Marks the leaf "routing-instance2" with operation "delete".
     */
    public void markRoutingInstance2Delete() throws JNCException {
        markLeafDelete("routingInstance2");
    }

    /* Access methods for optional leaf child: "sctp-profile". */

    /**
     * Gets the value for child leaf "sctp-profile".
     * @return The value of the leaf.
     */
    public YangString getSctpProfileValue() throws JNCException {
        return (YangString)getValue("sctp-profile");
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using instance of generated typedef class.
     * @param sctpProfileValue The value to set.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(YangString sctpProfileValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            sctpProfileValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sctp-profile",
     * using a String value.
     * @param sctpProfileValue used during instantiation.
     */
    public void setSctpProfileValue(String sctpProfileValue)
            throws JNCException {
        setSctpProfileValue(new YangString(sctpProfileValue));
    }

    /**
     * Unsets the value for child leaf "sctp-profile".
     */
    public void unsetSctpProfileValue() throws JNCException {
        delete("sctp-profile");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sctp-profile" leaf will not have a value.
     */
    public void addSctpProfile() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sctp-profile",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sctp-profile" with operation "replace".
     */
    public void markSctpProfileReplace() throws JNCException {
        markLeafReplace("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "merge".
     */
    public void markSctpProfileMerge() throws JNCException {
        markLeafMerge("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "create".
     */
    public void markSctpProfileCreate() throws JNCException {
        markLeafCreate("sctpProfile");
    }

    /**
     * Marks the leaf "sctp-profile" with operation "delete".
     */
    public void markSctpProfileDelete() throws JNCException {
        markLeafDelete("sctpProfile");
    }

    /* Access methods for optional leaf child: "ip-address1-v4". */

    /**
     * Gets the value for child leaf "ip-address1-v4".
     * @return The value of the leaf.
     */
    public Ipv4Address getIpAddress1V4Value() throws JNCException {
        Ipv4Address ipAddress1V4 = (Ipv4Address)getValue("ip-address1-v4");
        if (ipAddress1V4 == null) {
            ipAddress1V4 = new Ipv4Address("0.0.0.0");  // default
        }
        return ipAddress1V4;
    }

    /**
     * Sets the value for child leaf "ip-address1-v4",
     * using a JNC type value.
     * @param ipAddress1V4Value The value to set.
     * @param ipAddress1V4Value used during instantiation.
     */
    public void setIpAddress1V4Value(Ipv4Address ipAddress1V4Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1-v4",
            ipAddress1V4Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address1-v4",
     * using a String value.
     * @param ipAddress1V4Value used during instantiation.
     */
    public void setIpAddress1V4Value(String ipAddress1V4Value)
            throws JNCException {
        setIpAddress1V4Value(new Ipv4Address(ipAddress1V4Value));
    }

    /**
     * Unsets the value for child leaf "ip-address1-v4".
     */
    public void unsetIpAddress1V4Value() throws JNCException {
        delete("ip-address1-v4");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address1-v4" leaf will not have a value.
     */
    public void addIpAddress1V4() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1-v4",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address1-v4" with operation "replace".
     */
    public void markIpAddress1V4Replace() throws JNCException {
        markLeafReplace("ipAddress1V4");
    }

    /**
     * Marks the leaf "ip-address1-v4" with operation "merge".
     */
    public void markIpAddress1V4Merge() throws JNCException {
        markLeafMerge("ipAddress1V4");
    }

    /**
     * Marks the leaf "ip-address1-v4" with operation "create".
     */
    public void markIpAddress1V4Create() throws JNCException {
        markLeafCreate("ipAddress1V4");
    }

    /**
     * Marks the leaf "ip-address1-v4" with operation "delete".
     */
    public void markIpAddress1V4Delete() throws JNCException {
        markLeafDelete("ipAddress1V4");
    }

    /* Access methods for optional leaf child: "ip-address2-v4". */

    /**
     * Gets the value for child leaf "ip-address2-v4".
     * @return The value of the leaf.
     */
    public Ipv4Address getIpAddress2V4Value() throws JNCException {
        Ipv4Address ipAddress2V4 = (Ipv4Address)getValue("ip-address2-v4");
        if (ipAddress2V4 == null) {
            ipAddress2V4 = new Ipv4Address("0.0.0.0");  // default
        }
        return ipAddress2V4;
    }

    /**
     * Sets the value for child leaf "ip-address2-v4",
     * using a JNC type value.
     * @param ipAddress2V4Value The value to set.
     * @param ipAddress2V4Value used during instantiation.
     */
    public void setIpAddress2V4Value(Ipv4Address ipAddress2V4Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2-v4",
            ipAddress2V4Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address2-v4",
     * using a String value.
     * @param ipAddress2V4Value used during instantiation.
     */
    public void setIpAddress2V4Value(String ipAddress2V4Value)
            throws JNCException {
        setIpAddress2V4Value(new Ipv4Address(ipAddress2V4Value));
    }

    /**
     * Unsets the value for child leaf "ip-address2-v4".
     */
    public void unsetIpAddress2V4Value() throws JNCException {
        delete("ip-address2-v4");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address2-v4" leaf will not have a value.
     */
    public void addIpAddress2V4() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2-v4",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address2-v4" with operation "replace".
     */
    public void markIpAddress2V4Replace() throws JNCException {
        markLeafReplace("ipAddress2V4");
    }

    /**
     * Marks the leaf "ip-address2-v4" with operation "merge".
     */
    public void markIpAddress2V4Merge() throws JNCException {
        markLeafMerge("ipAddress2V4");
    }

    /**
     * Marks the leaf "ip-address2-v4" with operation "create".
     */
    public void markIpAddress2V4Create() throws JNCException {
        markLeafCreate("ipAddress2V4");
    }

    /**
     * Marks the leaf "ip-address2-v4" with operation "delete".
     */
    public void markIpAddress2V4Delete() throws JNCException {
        markLeafDelete("ipAddress2V4");
    }

    /* Access methods for optional leaf child: "ip-address1-v6". */

    /**
     * Gets the value for child leaf "ip-address1-v6".
     * @return The value of the leaf.
     */
    public Ipv6Address getIpAddress1V6Value() throws JNCException {
        Ipv6Address ipAddress1V6 = (Ipv6Address)getValue("ip-address1-v6");
        if (ipAddress1V6 == null) {
            ipAddress1V6 = new Ipv6Address("0:0:0:0:0:0:0:0");  // default
        }
        return ipAddress1V6;
    }

    /**
     * Sets the value for child leaf "ip-address1-v6",
     * using a JNC type value.
     * @param ipAddress1V6Value The value to set.
     * @param ipAddress1V6Value used during instantiation.
     */
    public void setIpAddress1V6Value(Ipv6Address ipAddress1V6Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1-v6",
            ipAddress1V6Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address1-v6",
     * using a String value.
     * @param ipAddress1V6Value used during instantiation.
     */
    public void setIpAddress1V6Value(String ipAddress1V6Value)
            throws JNCException {
        setIpAddress1V6Value(new Ipv6Address(ipAddress1V6Value));
    }

    /**
     * Unsets the value for child leaf "ip-address1-v6".
     */
    public void unsetIpAddress1V6Value() throws JNCException {
        delete("ip-address1-v6");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address1-v6" leaf will not have a value.
     */
    public void addIpAddress1V6() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address1-v6",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address1-v6" with operation "replace".
     */
    public void markIpAddress1V6Replace() throws JNCException {
        markLeafReplace("ipAddress1V6");
    }

    /**
     * Marks the leaf "ip-address1-v6" with operation "merge".
     */
    public void markIpAddress1V6Merge() throws JNCException {
        markLeafMerge("ipAddress1V6");
    }

    /**
     * Marks the leaf "ip-address1-v6" with operation "create".
     */
    public void markIpAddress1V6Create() throws JNCException {
        markLeafCreate("ipAddress1V6");
    }

    /**
     * Marks the leaf "ip-address1-v6" with operation "delete".
     */
    public void markIpAddress1V6Delete() throws JNCException {
        markLeafDelete("ipAddress1V6");
    }

    /* Access methods for optional leaf child: "ip-address2-v6". */

    /**
     * Gets the value for child leaf "ip-address2-v6".
     * @return The value of the leaf.
     */
    public Ipv6Address getIpAddress2V6Value() throws JNCException {
        Ipv6Address ipAddress2V6 = (Ipv6Address)getValue("ip-address2-v6");
        if (ipAddress2V6 == null) {
            ipAddress2V6 = new Ipv6Address("0:0:0:0:0:0:0:0");  // default
        }
        return ipAddress2V6;
    }

    /**
     * Sets the value for child leaf "ip-address2-v6",
     * using a JNC type value.
     * @param ipAddress2V6Value The value to set.
     * @param ipAddress2V6Value used during instantiation.
     */
    public void setIpAddress2V6Value(Ipv6Address ipAddress2V6Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2-v6",
            ipAddress2V6Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address2-v6",
     * using a String value.
     * @param ipAddress2V6Value used during instantiation.
     */
    public void setIpAddress2V6Value(String ipAddress2V6Value)
            throws JNCException {
        setIpAddress2V6Value(new Ipv6Address(ipAddress2V6Value));
    }

    /**
     * Unsets the value for child leaf "ip-address2-v6".
     */
    public void unsetIpAddress2V6Value() throws JNCException {
        delete("ip-address2-v6");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address2-v6" leaf will not have a value.
     */
    public void addIpAddress2V6() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address2-v6",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address2-v6" with operation "replace".
     */
    public void markIpAddress2V6Replace() throws JNCException {
        markLeafReplace("ipAddress2V6");
    }

    /**
     * Marks the leaf "ip-address2-v6" with operation "merge".
     */
    public void markIpAddress2V6Merge() throws JNCException {
        markLeafMerge("ipAddress2V6");
    }

    /**
     * Marks the leaf "ip-address2-v6" with operation "create".
     */
    public void markIpAddress2V6Create() throws JNCException {
        markLeafCreate("ipAddress2V6");
    }

    /**
     * Marks the leaf "ip-address2-v6" with operation "delete".
     */
    public void markIpAddress2V6Delete() throws JNCException {
        markLeafDelete("ipAddress2V6");
    }

    /* Access methods for optional leaf child: "port". */

    /**
     * Gets the value for child leaf "port".
     * @return The value of the leaf.
     */
    public YangUInt32 getPortValue() throws JNCException {
        YangUInt32 port = (YangUInt32)getValue("port");
        if (port == null) {
            port = new YangUInt32("36412");  // default
        }
        return port;
    }

    /**
     * Sets the value for child leaf "port",
     * using instance of generated typedef class.
     * @param portValue The value to set.
     * @param portValue used during instantiation.
     */
    public void setPortValue(YangUInt32 portValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            portValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "port",
     * using Java primitive values.
     * @param portValue used during instantiation.
     */
    public void setPortValue(long portValue) throws JNCException {
        setPortValue(new YangUInt32(portValue));
    }

    /**
     * Sets the value for child leaf "port",
     * using a String value.
     * @param portValue used during instantiation.
     */
    public void setPortValue(String portValue) throws JNCException {
        setPortValue(new YangUInt32(portValue));
    }

    /**
     * Unsets the value for child leaf "port".
     */
    public void unsetPortValue() throws JNCException {
        delete("port");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "port" leaf will not have a value.
     */
    public void addPort() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "port" with operation "replace".
     */
    public void markPortReplace() throws JNCException {
        markLeafReplace("port");
    }

    /**
     * Marks the leaf "port" with operation "merge".
     */
    public void markPortMerge() throws JNCException {
        markLeafMerge("port");
    }

    /**
     * Marks the leaf "port" with operation "create".
     */
    public void markPortCreate() throws JNCException {
        markLeafCreate("port");
    }

    /**
     * Marks the leaf "port" with operation "delete".
     */
    public void markPortDelete() throws JNCException {
        markLeafDelete("port");
    }

    /* Access methods for optional leaf child: "time-to-wait". */

    /**
     * Gets the value for child leaf "time-to-wait".
     * @return The value of the leaf.
     */
    public YangEnumeration getTimeToWaitValue() throws JNCException {
        YangEnumeration timeToWait = (YangEnumeration)getValue("time-to-wait");
        if (timeToWait == null) {
            timeToWait = new YangEnumeration("60", new String[] {  // default
                "1",
                "2",
                "5",
                "10",
                "20",
                "60",
            });
        }
        return timeToWait;
    }

    /**
     * Sets the value for child leaf "time-to-wait",
     * using instance of generated typedef class.
     * @param timeToWaitValue The value to set.
     * @param timeToWaitValue used during instantiation.
     */
    public void setTimeToWaitValue(YangEnumeration timeToWaitValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "time-to-wait",
            timeToWaitValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "time-to-wait",
     * using a String value.
     * @param timeToWaitValue used during instantiation.
     */
    public void setTimeToWaitValue(String timeToWaitValue) throws JNCException {
        setTimeToWaitValue(new YangEnumeration(timeToWaitValue, new String[] {
             "1",
             "2",
             "5",
             "10",
             "20",
             "60",
        }));
    }

    /**
     * Unsets the value for child leaf "time-to-wait".
     */
    public void unsetTimeToWaitValue() throws JNCException {
        delete("time-to-wait");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "time-to-wait" leaf will not have a value.
     */
    public void addTimeToWait() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "time-to-wait",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "time-to-wait" with operation "replace".
     */
    public void markTimeToWaitReplace() throws JNCException {
        markLeafReplace("timeToWait");
    }

    /**
     * Marks the leaf "time-to-wait" with operation "merge".
     */
    public void markTimeToWaitMerge() throws JNCException {
        markLeafMerge("timeToWait");
    }

    /**
     * Marks the leaf "time-to-wait" with operation "create".
     */
    public void markTimeToWaitCreate() throws JNCException {
        markLeafCreate("timeToWait");
    }

    /**
     * Marks the leaf "time-to-wait" with operation "delete".
     */
    public void markTimeToWaitDelete() throws JNCException {
        markLeafDelete("timeToWait");
    }

    /* Access methods for optional leaf child: "reloc-prep-timer". */

    /**
     * Gets the value for child leaf "reloc-prep-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRelocPrepTimerValue() throws JNCException {
        YangUInt8 relocPrepTimer = (YangUInt8)getValue("reloc-prep-timer");
        if (relocPrepTimer == null) {
            relocPrepTimer = new YangUInt8("3");  // default
        }
        return relocPrepTimer;
    }

    /**
     * Sets the value for child leaf "reloc-prep-timer",
     * using instance of generated typedef class.
     * @param relocPrepTimerValue The value to set.
     * @param relocPrepTimerValue used during instantiation.
     */
    public void setRelocPrepTimerValue(YangUInt8 relocPrepTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-prep-timer",
            relocPrepTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reloc-prep-timer",
     * using Java primitive values.
     * @param relocPrepTimerValue used during instantiation.
     */
    public void setRelocPrepTimerValue(short relocPrepTimerValue)
            throws JNCException {
        setRelocPrepTimerValue(new YangUInt8(relocPrepTimerValue));
    }

    /**
     * Sets the value for child leaf "reloc-prep-timer",
     * using a String value.
     * @param relocPrepTimerValue used during instantiation.
     */
    public void setRelocPrepTimerValue(String relocPrepTimerValue)
            throws JNCException {
        setRelocPrepTimerValue(new YangUInt8(relocPrepTimerValue));
    }

    /**
     * Unsets the value for child leaf "reloc-prep-timer".
     */
    public void unsetRelocPrepTimerValue() throws JNCException {
        delete("reloc-prep-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reloc-prep-timer" leaf will not have a value.
     */
    public void addRelocPrepTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-prep-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reloc-prep-timer" with operation "replace".
     */
    public void markRelocPrepTimerReplace() throws JNCException {
        markLeafReplace("relocPrepTimer");
    }

    /**
     * Marks the leaf "reloc-prep-timer" with operation "merge".
     */
    public void markRelocPrepTimerMerge() throws JNCException {
        markLeafMerge("relocPrepTimer");
    }

    /**
     * Marks the leaf "reloc-prep-timer" with operation "create".
     */
    public void markRelocPrepTimerCreate() throws JNCException {
        markLeafCreate("relocPrepTimer");
    }

    /**
     * Marks the leaf "reloc-prep-timer" with operation "delete".
     */
    public void markRelocPrepTimerDelete() throws JNCException {
        markLeafDelete("relocPrepTimer");
    }

    /* Access methods for optional leaf child: "reloc-overall-timer". */

    /**
     * Gets the value for child leaf "reloc-overall-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRelocOverallTimerValue() throws JNCException {
        YangUInt8 relocOverallTimer = (YangUInt8)getValue("reloc-overall-timer");
        if (relocOverallTimer == null) {
            relocOverallTimer = new YangUInt8("5");  // default
        }
        return relocOverallTimer;
    }

    /**
     * Sets the value for child leaf "reloc-overall-timer",
     * using instance of generated typedef class.
     * @param relocOverallTimerValue The value to set.
     * @param relocOverallTimerValue used during instantiation.
     */
    public void setRelocOverallTimerValue(YangUInt8 relocOverallTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-overall-timer",
            relocOverallTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reloc-overall-timer",
     * using Java primitive values.
     * @param relocOverallTimerValue used during instantiation.
     */
    public void setRelocOverallTimerValue(short relocOverallTimerValue)
            throws JNCException {
        setRelocOverallTimerValue(new YangUInt8(relocOverallTimerValue));
    }

    /**
     * Sets the value for child leaf "reloc-overall-timer",
     * using a String value.
     * @param relocOverallTimerValue used during instantiation.
     */
    public void setRelocOverallTimerValue(String relocOverallTimerValue)
            throws JNCException {
        setRelocOverallTimerValue(new YangUInt8(relocOverallTimerValue));
    }

    /**
     * Unsets the value for child leaf "reloc-overall-timer".
     */
    public void unsetRelocOverallTimerValue() throws JNCException {
        delete("reloc-overall-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reloc-overall-timer" leaf will not have a value.
     */
    public void addRelocOverallTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reloc-overall-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reloc-overall-timer" with operation "replace".
     */
    public void markRelocOverallTimerReplace() throws JNCException {
        markLeafReplace("relocOverallTimer");
    }

    /**
     * Marks the leaf "reloc-overall-timer" with operation "merge".
     */
    public void markRelocOverallTimerMerge() throws JNCException {
        markLeafMerge("relocOverallTimer");
    }

    /**
     * Marks the leaf "reloc-overall-timer" with operation "create".
     */
    public void markRelocOverallTimerCreate() throws JNCException {
        markLeafCreate("relocOverallTimer");
    }

    /**
     * Marks the leaf "reloc-overall-timer" with operation "delete".
     */
    public void markRelocOverallTimerDelete() throws JNCException {
        markLeafDelete("relocOverallTimer");
    }

    /* Access methods for optional leaf child: "indirect-tunnel-hold-timer". */

    /**
     * Gets the value for child leaf "indirect-tunnel-hold-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getIndirectTunnelHoldTimerValue() throws JNCException {
        YangUInt8 indirectTunnelHoldTimer = (YangUInt8)getValue("indirect-tunnel-hold-timer");
        if (indirectTunnelHoldTimer == null) {
            indirectTunnelHoldTimer = new YangUInt8("5");  // default
        }
        return indirectTunnelHoldTimer;
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using instance of generated typedef class.
     * @param indirectTunnelHoldTimerValue The value to set.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(YangUInt8 indirectTunnelHoldTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-tunnel-hold-timer",
            indirectTunnelHoldTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using Java primitive values.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(short indirectTunnelHoldTimerValue)
            throws JNCException {
        setIndirectTunnelHoldTimerValue(new YangUInt8(indirectTunnelHoldTimerValue));
    }

    /**
     * Sets the value for child leaf "indirect-tunnel-hold-timer",
     * using a String value.
     * @param indirectTunnelHoldTimerValue used during instantiation.
     */
    public void setIndirectTunnelHoldTimerValue(String indirectTunnelHoldTimerValue)
            throws JNCException {
        setIndirectTunnelHoldTimerValue(new YangUInt8(indirectTunnelHoldTimerValue));
    }

    /**
     * Unsets the value for child leaf "indirect-tunnel-hold-timer".
     */
    public void unsetIndirectTunnelHoldTimerValue() throws JNCException {
        delete("indirect-tunnel-hold-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "indirect-tunnel-hold-timer" leaf will not have a value.
     */
    public void addIndirectTunnelHoldTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-tunnel-hold-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "replace".
     */
    public void markIndirectTunnelHoldTimerReplace() throws JNCException {
        markLeafReplace("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "merge".
     */
    public void markIndirectTunnelHoldTimerMerge() throws JNCException {
        markLeafMerge("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "create".
     */
    public void markIndirectTunnelHoldTimerCreate() throws JNCException {
        markLeafCreate("indirectTunnelHoldTimer");
    }

    /**
     * Marks the leaf "indirect-tunnel-hold-timer" with operation "delete".
     */
    public void markIndirectTunnelHoldTimerDelete() throws JNCException {
        markLeafDelete("indirectTunnelHoldTimer");
    }

    /* Access methods for optional leaf child: "handover-resource-release-timer". */

    /**
     * Gets the value for child leaf "handover-resource-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getHandoverResourceReleaseTimerValue() throws JNCException {
        YangUInt8 handoverResourceReleaseTimer = (YangUInt8)getValue("handover-resource-release-timer");
        if (handoverResourceReleaseTimer == null) {
            handoverResourceReleaseTimer = new YangUInt8("5");  // default
        }
        return handoverResourceReleaseTimer;
    }

    /**
     * Sets the value for child leaf "handover-resource-release-timer",
     * using instance of generated typedef class.
     * @param handoverResourceReleaseTimerValue The value to set.
     * @param handoverResourceReleaseTimerValue used during instantiation.
     */
    public void setHandoverResourceReleaseTimerValue(YangUInt8 handoverResourceReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "handover-resource-release-timer",
            handoverResourceReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "handover-resource-release-timer",
     * using Java primitive values.
     * @param handoverResourceReleaseTimerValue used during instantiation.
     */
    public void setHandoverResourceReleaseTimerValue(short handoverResourceReleaseTimerValue)
            throws JNCException {
        setHandoverResourceReleaseTimerValue(new YangUInt8(handoverResourceReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "handover-resource-release-timer",
     * using a String value.
     * @param handoverResourceReleaseTimerValue used during instantiation.
     */
    public void setHandoverResourceReleaseTimerValue(String handoverResourceReleaseTimerValue)
            throws JNCException {
        setHandoverResourceReleaseTimerValue(new YangUInt8(handoverResourceReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "handover-resource-release-timer".
     */
    public void unsetHandoverResourceReleaseTimerValue() throws JNCException {
        delete("handover-resource-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "handover-resource-release-timer" leaf will not have a value.
     */
    public void addHandoverResourceReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "handover-resource-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "handover-resource-release-timer" with operation "replace".
     */
    public void markHandoverResourceReleaseTimerReplace() throws JNCException {
        markLeafReplace("handoverResourceReleaseTimer");
    }

    /**
     * Marks the leaf "handover-resource-release-timer" with operation "merge".
     */
    public void markHandoverResourceReleaseTimerMerge() throws JNCException {
        markLeafMerge("handoverResourceReleaseTimer");
    }

    /**
     * Marks the leaf "handover-resource-release-timer" with operation "create".
     */
    public void markHandoverResourceReleaseTimerCreate() throws JNCException {
        markLeafCreate("handoverResourceReleaseTimer");
    }

    /**
     * Marks the leaf "handover-resource-release-timer" with operation "delete".
     */
    public void markHandoverResourceReleaseTimerDelete() throws JNCException {
        markLeafDelete("handoverResourceReleaseTimer");
    }

    /* Access methods for optional leaf child: "ue-context-release-timer". */

    /**
     * Gets the value for child leaf "ue-context-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getUeContextReleaseTimerValue() throws JNCException {
        YangUInt8 ueContextReleaseTimer = (YangUInt8)getValue("ue-context-release-timer");
        if (ueContextReleaseTimer == null) {
            ueContextReleaseTimer = new YangUInt8("5");  // default
        }
        return ueContextReleaseTimer;
    }

    /**
     * Sets the value for child leaf "ue-context-release-timer",
     * using instance of generated typedef class.
     * @param ueContextReleaseTimerValue The value to set.
     * @param ueContextReleaseTimerValue used during instantiation.
     */
    public void setUeContextReleaseTimerValue(YangUInt8 ueContextReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-context-release-timer",
            ueContextReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ue-context-release-timer",
     * using Java primitive values.
     * @param ueContextReleaseTimerValue used during instantiation.
     */
    public void setUeContextReleaseTimerValue(short ueContextReleaseTimerValue)
            throws JNCException {
        setUeContextReleaseTimerValue(new YangUInt8(ueContextReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "ue-context-release-timer",
     * using a String value.
     * @param ueContextReleaseTimerValue used during instantiation.
     */
    public void setUeContextReleaseTimerValue(String ueContextReleaseTimerValue)
            throws JNCException {
        setUeContextReleaseTimerValue(new YangUInt8(ueContextReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "ue-context-release-timer".
     */
    public void unsetUeContextReleaseTimerValue() throws JNCException {
        delete("ue-context-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ue-context-release-timer" leaf will not have a value.
     */
    public void addUeContextReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-context-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ue-context-release-timer" with operation "replace".
     */
    public void markUeContextReleaseTimerReplace() throws JNCException {
        markLeafReplace("ueContextReleaseTimer");
    }

    /**
     * Marks the leaf "ue-context-release-timer" with operation "merge".
     */
    public void markUeContextReleaseTimerMerge() throws JNCException {
        markLeafMerge("ueContextReleaseTimer");
    }

    /**
     * Marks the leaf "ue-context-release-timer" with operation "create".
     */
    public void markUeContextReleaseTimerCreate() throws JNCException {
        markLeafCreate("ueContextReleaseTimer");
    }

    /**
     * Marks the leaf "ue-context-release-timer" with operation "delete".
     */
    public void markUeContextReleaseTimerDelete() throws JNCException {
        markLeafDelete("ueContextReleaseTimer");
    }

    /* Access methods for optional leaf child: "ue-context-modification-timer". */

    /**
     * Gets the value for child leaf "ue-context-modification-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getUeContextModificationTimerValue() throws JNCException {
        YangUInt8 ueContextModificationTimer = (YangUInt8)getValue("ue-context-modification-timer");
        if (ueContextModificationTimer == null) {
            ueContextModificationTimer = new YangUInt8("5");  // default
        }
        return ueContextModificationTimer;
    }

    /**
     * Sets the value for child leaf "ue-context-modification-timer",
     * using instance of generated typedef class.
     * @param ueContextModificationTimerValue The value to set.
     * @param ueContextModificationTimerValue used during instantiation.
     */
    public void setUeContextModificationTimerValue(YangUInt8 ueContextModificationTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-context-modification-timer",
            ueContextModificationTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ue-context-modification-timer",
     * using Java primitive values.
     * @param ueContextModificationTimerValue used during instantiation.
     */
    public void setUeContextModificationTimerValue(short ueContextModificationTimerValue)
            throws JNCException {
        setUeContextModificationTimerValue(new YangUInt8(ueContextModificationTimerValue));
    }

    /**
     * Sets the value for child leaf "ue-context-modification-timer",
     * using a String value.
     * @param ueContextModificationTimerValue used during instantiation.
     */
    public void setUeContextModificationTimerValue(String ueContextModificationTimerValue)
            throws JNCException {
        setUeContextModificationTimerValue(new YangUInt8(ueContextModificationTimerValue));
    }

    /**
     * Unsets the value for child leaf "ue-context-modification-timer".
     */
    public void unsetUeContextModificationTimerValue() throws JNCException {
        delete("ue-context-modification-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ue-context-modification-timer" leaf will not have a value.
     */
    public void addUeContextModificationTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ue-context-modification-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ue-context-modification-timer" with operation "replace".
     */
    public void markUeContextModificationTimerReplace() throws JNCException {
        markLeafReplace("ueContextModificationTimer");
    }

    /**
     * Marks the leaf "ue-context-modification-timer" with operation "merge".
     */
    public void markUeContextModificationTimerMerge() throws JNCException {
        markLeafMerge("ueContextModificationTimer");
    }

    /**
     * Marks the leaf "ue-context-modification-timer" with operation "create".
     */
    public void markUeContextModificationTimerCreate() throws JNCException {
        markLeafCreate("ueContextModificationTimer");
    }

    /**
     * Marks the leaf "ue-context-modification-timer" with operation "delete".
     */
    public void markUeContextModificationTimerDelete() throws JNCException {
        markLeafDelete("ueContextModificationTimer");
    }

    /* Access methods for optional leaf child: "wait-for-tau-timer". */

    /**
     * Gets the value for child leaf "wait-for-tau-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getWaitForTauTimerValue() throws JNCException {
        YangUInt8 waitForTauTimer = (YangUInt8)getValue("wait-for-tau-timer");
        if (waitForTauTimer == null) {
            waitForTauTimer = new YangUInt8("5");  // default
        }
        return waitForTauTimer;
    }

    /**
     * Sets the value for child leaf "wait-for-tau-timer",
     * using instance of generated typedef class.
     * @param waitForTauTimerValue The value to set.
     * @param waitForTauTimerValue used during instantiation.
     */
    public void setWaitForTauTimerValue(YangUInt8 waitForTauTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "wait-for-tau-timer",
            waitForTauTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "wait-for-tau-timer",
     * using Java primitive values.
     * @param waitForTauTimerValue used during instantiation.
     */
    public void setWaitForTauTimerValue(short waitForTauTimerValue)
            throws JNCException {
        setWaitForTauTimerValue(new YangUInt8(waitForTauTimerValue));
    }

    /**
     * Sets the value for child leaf "wait-for-tau-timer",
     * using a String value.
     * @param waitForTauTimerValue used during instantiation.
     */
    public void setWaitForTauTimerValue(String waitForTauTimerValue)
            throws JNCException {
        setWaitForTauTimerValue(new YangUInt8(waitForTauTimerValue));
    }

    /**
     * Unsets the value for child leaf "wait-for-tau-timer".
     */
    public void unsetWaitForTauTimerValue() throws JNCException {
        delete("wait-for-tau-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "wait-for-tau-timer" leaf will not have a value.
     */
    public void addWaitForTauTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "wait-for-tau-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "wait-for-tau-timer" with operation "replace".
     */
    public void markWaitForTauTimerReplace() throws JNCException {
        markLeafReplace("waitForTauTimer");
    }

    /**
     * Marks the leaf "wait-for-tau-timer" with operation "merge".
     */
    public void markWaitForTauTimerMerge() throws JNCException {
        markLeafMerge("waitForTauTimer");
    }

    /**
     * Marks the leaf "wait-for-tau-timer" with operation "create".
     */
    public void markWaitForTauTimerCreate() throws JNCException {
        markLeafCreate("waitForTauTimer");
    }

    /**
     * Marks the leaf "wait-for-tau-timer" with operation "delete".
     */
    public void markWaitForTauTimerDelete() throws JNCException {
        markLeafDelete("waitForTauTimer");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /* Access methods for optional leaf child: "inter-rat-indirect-forwarding". */

    /**
     * Gets the value for child leaf "inter-rat-indirect-forwarding".
     * @return The value of the leaf.
     */
    public YangEnumeration getInterRatIndirectForwardingValue()
            throws JNCException {
        YangEnumeration interRatIndirectForwarding = (YangEnumeration)getValue("inter-rat-indirect-forwarding");
        if (interRatIndirectForwarding == null) {
            interRatIndirectForwarding = new YangEnumeration("never", new String[] {  // default
                "never",
                "always",
                "inter-plmn-inter-rat",
            });
        }
        return interRatIndirectForwarding;
    }

    /**
     * Sets the value for child leaf "inter-rat-indirect-forwarding",
     * using instance of generated typedef class.
     * @param interRatIndirectForwardingValue The value to set.
     * @param interRatIndirectForwardingValue used during instantiation.
     */
    public void setInterRatIndirectForwardingValue(YangEnumeration interRatIndirectForwardingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "inter-rat-indirect-forwarding",
            interRatIndirectForwardingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "inter-rat-indirect-forwarding",
     * using a String value.
     * @param interRatIndirectForwardingValue used during instantiation.
     */
    public void setInterRatIndirectForwardingValue(String interRatIndirectForwardingValue)
            throws JNCException {
        setInterRatIndirectForwardingValue(new YangEnumeration(interRatIndirectForwardingValue, new String[] {
             "never",
             "always",
             "inter-plmn-inter-rat",
        }));
    }

    /**
     * Unsets the value for child leaf "inter-rat-indirect-forwarding".
     */
    public void unsetInterRatIndirectForwardingValue() throws JNCException {
        delete("inter-rat-indirect-forwarding");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "inter-rat-indirect-forwarding" leaf will not have a value.
     */
    public void addInterRatIndirectForwarding() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "inter-rat-indirect-forwarding",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "replace".
     */
    public void markInterRatIndirectForwardingReplace() throws JNCException {
        markLeafReplace("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "merge".
     */
    public void markInterRatIndirectForwardingMerge() throws JNCException {
        markLeafMerge("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "create".
     */
    public void markInterRatIndirectForwardingCreate() throws JNCException {
        markLeafCreate("interRatIndirectForwarding");
    }

    /**
     * Marks the leaf "inter-rat-indirect-forwarding" with operation "delete".
     */
    public void markInterRatIndirectForwardingDelete() throws JNCException {
        markLeafDelete("interRatIndirectForwarding");
    }

    /* Access methods for optional leaf child: "intra-rat-indirect-forwarding". */

    /**
     * Gets the value for child leaf "intra-rat-indirect-forwarding".
     * @return The value of the leaf.
     */
    public YangEnumeration getIntraRatIndirectForwardingValue()
            throws JNCException {
        YangEnumeration intraRatIndirectForwarding = (YangEnumeration)getValue("intra-rat-indirect-forwarding");
        if (intraRatIndirectForwarding == null) {
            intraRatIndirectForwarding = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return intraRatIndirectForwarding;
    }

    /**
     * Sets the value for child leaf "intra-rat-indirect-forwarding",
     * using instance of generated typedef class.
     * @param intraRatIndirectForwardingValue The value to set.
     * @param intraRatIndirectForwardingValue used during instantiation.
     */
    public void setIntraRatIndirectForwardingValue(YangEnumeration intraRatIndirectForwardingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "intra-rat-indirect-forwarding",
            intraRatIndirectForwardingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "intra-rat-indirect-forwarding",
     * using a String value.
     * @param intraRatIndirectForwardingValue used during instantiation.
     */
    public void setIntraRatIndirectForwardingValue(String intraRatIndirectForwardingValue)
            throws JNCException {
        setIntraRatIndirectForwardingValue(new YangEnumeration(intraRatIndirectForwardingValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "intra-rat-indirect-forwarding".
     */
    public void unsetIntraRatIndirectForwardingValue() throws JNCException {
        delete("intra-rat-indirect-forwarding");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "intra-rat-indirect-forwarding" leaf will not have a value.
     */
    public void addIntraRatIndirectForwarding() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "intra-rat-indirect-forwarding",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "intra-rat-indirect-forwarding" with operation "replace".
     */
    public void markIntraRatIndirectForwardingReplace() throws JNCException {
        markLeafReplace("intraRatIndirectForwarding");
    }

    /**
     * Marks the leaf "intra-rat-indirect-forwarding" with operation "merge".
     */
    public void markIntraRatIndirectForwardingMerge() throws JNCException {
        markLeafMerge("intraRatIndirectForwarding");
    }

    /**
     * Marks the leaf "intra-rat-indirect-forwarding" with operation "create".
     */
    public void markIntraRatIndirectForwardingCreate() throws JNCException {
        markLeafCreate("intraRatIndirectForwarding");
    }

    /**
     * Marks the leaf "intra-rat-indirect-forwarding" with operation "delete".
     */
    public void markIntraRatIndirectForwardingDelete() throws JNCException {
        markLeafDelete("intraRatIndirectForwarding");
    }

    /* Access methods for optional leaf child: "indirect-data-fwd-ip-address". */

    /**
     * Gets the value for child leaf "indirect-data-fwd-ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getIndirectDataFwdIpAddressValue() throws JNCException {
        IpAddress indirectDataFwdIpAddress = (IpAddress)getValue("indirect-data-fwd-ip-address");
        if (indirectDataFwdIpAddress == null) {
            indirectDataFwdIpAddress = new IpAddress("0.0.0.0");  // default
        }
        return indirectDataFwdIpAddress;
    }

    /**
     * Sets the value for child leaf "indirect-data-fwd-ip-address",
     * using a JNC type value.
     * @param indirectDataFwdIpAddressValue The value to set.
     * @param indirectDataFwdIpAddressValue used during instantiation.
     */
    public void setIndirectDataFwdIpAddressValue(IpAddress indirectDataFwdIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-data-fwd-ip-address",
            indirectDataFwdIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "indirect-data-fwd-ip-address",
     * using a String value.
     * @param indirectDataFwdIpAddressValue used during instantiation.
     */
    public void setIndirectDataFwdIpAddressValue(String indirectDataFwdIpAddressValue)
            throws JNCException {
        setIndirectDataFwdIpAddressValue(new IpAddress(indirectDataFwdIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "indirect-data-fwd-ip-address".
     */
    public void unsetIndirectDataFwdIpAddressValue() throws JNCException {
        delete("indirect-data-fwd-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "indirect-data-fwd-ip-address" leaf will not have a value.
     */
    public void addIndirectDataFwdIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "indirect-data-fwd-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "replace".
     */
    public void markIndirectDataFwdIpAddressReplace() throws JNCException {
        markLeafReplace("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "merge".
     */
    public void markIndirectDataFwdIpAddressMerge() throws JNCException {
        markLeafMerge("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "create".
     */
    public void markIndirectDataFwdIpAddressCreate() throws JNCException {
        markLeafCreate("indirectDataFwdIpAddress");
    }

    /**
     * Marks the leaf "indirect-data-fwd-ip-address" with operation "delete".
     */
    public void markIndirectDataFwdIpAddressDelete() throws JNCException {
        markLeafDelete("indirectDataFwdIpAddress");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10.6.0", new String[] {  // default
                "9.5.1",
                "10.6.0",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "9.5.1",
             "10.6.0",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /* Access methods for optional leaf child: "enb-alarm-clear-time". */

    /**
     * Gets the value for child leaf "enb-alarm-clear-time".
     * @return The value of the leaf.
     */
    public YangUInt16 getEnbAlarmClearTimeValue() throws JNCException {
        YangUInt16 enbAlarmClearTime = (YangUInt16)getValue("enb-alarm-clear-time");
        if (enbAlarmClearTime == null) {
            enbAlarmClearTime = new YangUInt16("24");  // default
        }
        return enbAlarmClearTime;
    }

    /**
     * Sets the value for child leaf "enb-alarm-clear-time",
     * using instance of generated typedef class.
     * @param enbAlarmClearTimeValue The value to set.
     * @param enbAlarmClearTimeValue used during instantiation.
     */
    public void setEnbAlarmClearTimeValue(YangUInt16 enbAlarmClearTimeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enb-alarm-clear-time",
            enbAlarmClearTimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enb-alarm-clear-time",
     * using Java primitive values.
     * @param enbAlarmClearTimeValue used during instantiation.
     */
    public void setEnbAlarmClearTimeValue(int enbAlarmClearTimeValue)
            throws JNCException {
        setEnbAlarmClearTimeValue(new YangUInt16(enbAlarmClearTimeValue));
    }

    /**
     * Sets the value for child leaf "enb-alarm-clear-time",
     * using a String value.
     * @param enbAlarmClearTimeValue used during instantiation.
     */
    public void setEnbAlarmClearTimeValue(String enbAlarmClearTimeValue)
            throws JNCException {
        setEnbAlarmClearTimeValue(new YangUInt16(enbAlarmClearTimeValue));
    }

    /**
     * Unsets the value for child leaf "enb-alarm-clear-time".
     */
    public void unsetEnbAlarmClearTimeValue() throws JNCException {
        delete("enb-alarm-clear-time");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enb-alarm-clear-time" leaf will not have a value.
     */
    public void addEnbAlarmClearTime() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enb-alarm-clear-time",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enb-alarm-clear-time" with operation "replace".
     */
    public void markEnbAlarmClearTimeReplace() throws JNCException {
        markLeafReplace("enbAlarmClearTime");
    }

    /**
     * Marks the leaf "enb-alarm-clear-time" with operation "merge".
     */
    public void markEnbAlarmClearTimeMerge() throws JNCException {
        markLeafMerge("enbAlarmClearTime");
    }

    /**
     * Marks the leaf "enb-alarm-clear-time" with operation "create".
     */
    public void markEnbAlarmClearTimeCreate() throws JNCException {
        markLeafCreate("enbAlarmClearTime");
    }

    /**
     * Marks the leaf "enb-alarm-clear-time" with operation "delete".
     */
    public void markEnbAlarmClearTimeDelete() throws JNCException {
        markLeafDelete("enbAlarmClearTime");
    }

    /* Access methods for optional leaf child: "location-reporting-control". */

    /**
     * Gets the value for child leaf "location-reporting-control".
     * @return The value of the leaf.
     */
    public YangEnumeration getLocationReportingControlValue()
            throws JNCException {
        YangEnumeration locationReportingControl = (YangEnumeration)getValue("location-reporting-control");
        if (locationReportingControl == null) {
            locationReportingControl = new YangEnumeration("disable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return locationReportingControl;
    }

    /**
     * Sets the value for child leaf "location-reporting-control",
     * using instance of generated typedef class.
     * @param locationReportingControlValue The value to set.
     * @param locationReportingControlValue used during instantiation.
     */
    public void setLocationReportingControlValue(YangEnumeration locationReportingControlValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location-reporting-control",
            locationReportingControlValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location-reporting-control",
     * using a String value.
     * @param locationReportingControlValue used during instantiation.
     */
    public void setLocationReportingControlValue(String locationReportingControlValue)
            throws JNCException {
        setLocationReportingControlValue(new YangEnumeration(locationReportingControlValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "location-reporting-control".
     */
    public void unsetLocationReportingControlValue() throws JNCException {
        delete("location-reporting-control");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location-reporting-control" leaf will not have a value.
     */
    public void addLocationReportingControl() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location-reporting-control",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location-reporting-control" with operation "replace".
     */
    public void markLocationReportingControlReplace() throws JNCException {
        markLeafReplace("locationReportingControl");
    }

    /**
     * Marks the leaf "location-reporting-control" with operation "merge".
     */
    public void markLocationReportingControlMerge() throws JNCException {
        markLeafMerge("locationReportingControl");
    }

    /**
     * Marks the leaf "location-reporting-control" with operation "create".
     */
    public void markLocationReportingControlCreate() throws JNCException {
        markLeafCreate("locationReportingControl");
    }

    /**
     * Marks the leaf "location-reporting-control" with operation "delete".
     */
    public void markLocationReportingControlDelete() throws JNCException {
        markLeafDelete("locationReportingControl");
    }

    /* Access methods for optional leaf child: "lrc-timer-direct". */

    /**
     * Gets the value for child leaf "lrc-timer-direct".
     * @return The value of the leaf.
     */
    public YangUInt8 getLrcTimerDirectValue() throws JNCException {
        YangUInt8 lrcTimerDirect = (YangUInt8)getValue("lrc-timer-direct");
        if (lrcTimerDirect == null) {
            lrcTimerDirect = new YangUInt8("5");  // default
        }
        return lrcTimerDirect;
    }

    /**
     * Sets the value for child leaf "lrc-timer-direct",
     * using instance of generated typedef class.
     * @param lrcTimerDirectValue The value to set.
     * @param lrcTimerDirectValue used during instantiation.
     */
    public void setLrcTimerDirectValue(YangUInt8 lrcTimerDirectValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "lrc-timer-direct",
            lrcTimerDirectValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "lrc-timer-direct",
     * using Java primitive values.
     * @param lrcTimerDirectValue used during instantiation.
     */
    public void setLrcTimerDirectValue(short lrcTimerDirectValue)
            throws JNCException {
        setLrcTimerDirectValue(new YangUInt8(lrcTimerDirectValue));
    }

    /**
     * Sets the value for child leaf "lrc-timer-direct",
     * using a String value.
     * @param lrcTimerDirectValue used during instantiation.
     */
    public void setLrcTimerDirectValue(String lrcTimerDirectValue)
            throws JNCException {
        setLrcTimerDirectValue(new YangUInt8(lrcTimerDirectValue));
    }

    /**
     * Unsets the value for child leaf "lrc-timer-direct".
     */
    public void unsetLrcTimerDirectValue() throws JNCException {
        delete("lrc-timer-direct");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "lrc-timer-direct" leaf will not have a value.
     */
    public void addLrcTimerDirect() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "lrc-timer-direct",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "lrc-timer-direct" with operation "replace".
     */
    public void markLrcTimerDirectReplace() throws JNCException {
        markLeafReplace("lrcTimerDirect");
    }

    /**
     * Marks the leaf "lrc-timer-direct" with operation "merge".
     */
    public void markLrcTimerDirectMerge() throws JNCException {
        markLeafMerge("lrcTimerDirect");
    }

    /**
     * Marks the leaf "lrc-timer-direct" with operation "create".
     */
    public void markLrcTimerDirectCreate() throws JNCException {
        markLeafCreate("lrcTimerDirect");
    }

    /**
     * Marks the leaf "lrc-timer-direct" with operation "delete".
     */
    public void markLrcTimerDirectDelete() throws JNCException {
        markLeafDelete("lrcTimerDirect");
    }

    /* Access methods for optional leaf child: "csg-expiration-release-timer". */

    /**
     * Gets the value for child leaf "csg-expiration-release-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getCsgExpirationReleaseTimerValue() throws JNCException {
        YangUInt8 csgExpirationReleaseTimer = (YangUInt8)getValue("csg-expiration-release-timer");
        if (csgExpirationReleaseTimer == null) {
            csgExpirationReleaseTimer = new YangUInt8("5");  // default
        }
        return csgExpirationReleaseTimer;
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using instance of generated typedef class.
     * @param csgExpirationReleaseTimerValue The value to set.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(YangUInt8 csgExpirationReleaseTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-expiration-release-timer",
            csgExpirationReleaseTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using Java primitive values.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(short csgExpirationReleaseTimerValue)
            throws JNCException {
        setCsgExpirationReleaseTimerValue(new YangUInt8(csgExpirationReleaseTimerValue));
    }

    /**
     * Sets the value for child leaf "csg-expiration-release-timer",
     * using a String value.
     * @param csgExpirationReleaseTimerValue used during instantiation.
     */
    public void setCsgExpirationReleaseTimerValue(String csgExpirationReleaseTimerValue)
            throws JNCException {
        setCsgExpirationReleaseTimerValue(new YangUInt8(csgExpirationReleaseTimerValue));
    }

    /**
     * Unsets the value for child leaf "csg-expiration-release-timer".
     */
    public void unsetCsgExpirationReleaseTimerValue() throws JNCException {
        delete("csg-expiration-release-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "csg-expiration-release-timer" leaf will not have a value.
     */
    public void addCsgExpirationReleaseTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "csg-expiration-release-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "replace".
     */
    public void markCsgExpirationReleaseTimerReplace() throws JNCException {
        markLeafReplace("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "merge".
     */
    public void markCsgExpirationReleaseTimerMerge() throws JNCException {
        markLeafMerge("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "create".
     */
    public void markCsgExpirationReleaseTimerCreate() throws JNCException {
        markLeafCreate("csgExpirationReleaseTimer");
    }

    /**
     * Marks the leaf "csg-expiration-release-timer" with operation "delete".
     */
    public void markCsgExpirationReleaseTimerDelete() throws JNCException {
        markLeafDelete("csgExpirationReleaseTimer");
    }

    /* Access methods for optional leaf child: "fgw-sctp-profile". */

    /**
     * Gets the value for child leaf "fgw-sctp-profile".
     * @return The value of the leaf.
     */
    public YangString getFgwSctpProfileValue() throws JNCException {
        return (YangString)getValue("fgw-sctp-profile");
    }

    /**
     * Sets the value for child leaf "fgw-sctp-profile",
     * using instance of generated typedef class.
     * @param fgwSctpProfileValue The value to set.
     * @param fgwSctpProfileValue used during instantiation.
     */
    public void setFgwSctpProfileValue(YangString fgwSctpProfileValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fgw-sctp-profile",
            fgwSctpProfileValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "fgw-sctp-profile",
     * using a String value.
     * @param fgwSctpProfileValue used during instantiation.
     */
    public void setFgwSctpProfileValue(String fgwSctpProfileValue)
            throws JNCException {
        setFgwSctpProfileValue(new YangString(fgwSctpProfileValue));
    }

    /**
     * Unsets the value for child leaf "fgw-sctp-profile".
     */
    public void unsetFgwSctpProfileValue() throws JNCException {
        delete("fgw-sctp-profile");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "fgw-sctp-profile" leaf will not have a value.
     */
    public void addFgwSctpProfile() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fgw-sctp-profile",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "fgw-sctp-profile" with operation "replace".
     */
    public void markFgwSctpProfileReplace() throws JNCException {
        markLeafReplace("fgwSctpProfile");
    }

    /**
     * Marks the leaf "fgw-sctp-profile" with operation "merge".
     */
    public void markFgwSctpProfileMerge() throws JNCException {
        markLeafMerge("fgwSctpProfile");
    }

    /**
     * Marks the leaf "fgw-sctp-profile" with operation "create".
     */
    public void markFgwSctpProfileCreate() throws JNCException {
        markLeafCreate("fgwSctpProfile");
    }

    /**
     * Marks the leaf "fgw-sctp-profile" with operation "delete".
     */
    public void markFgwSctpProfileDelete() throws JNCException {
        markLeafDelete("fgwSctpProfile");
    }

    /* Access methods for optional leaf child: "reset-ack-delay-timer". */

    /**
     * Gets the value for child leaf "reset-ack-delay-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getResetAckDelayTimerValue() throws JNCException {
        YangUInt8 resetAckDelayTimer = (YangUInt8)getValue("reset-ack-delay-timer");
        if (resetAckDelayTimer == null) {
            resetAckDelayTimer = new YangUInt8("14");  // default
        }
        return resetAckDelayTimer;
    }

    /**
     * Sets the value for child leaf "reset-ack-delay-timer",
     * using instance of generated typedef class.
     * @param resetAckDelayTimerValue The value to set.
     * @param resetAckDelayTimerValue used during instantiation.
     */
    public void setResetAckDelayTimerValue(YangUInt8 resetAckDelayTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-ack-delay-timer",
            resetAckDelayTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reset-ack-delay-timer",
     * using Java primitive values.
     * @param resetAckDelayTimerValue used during instantiation.
     */
    public void setResetAckDelayTimerValue(short resetAckDelayTimerValue)
            throws JNCException {
        setResetAckDelayTimerValue(new YangUInt8(resetAckDelayTimerValue));
    }

    /**
     * Sets the value for child leaf "reset-ack-delay-timer",
     * using a String value.
     * @param resetAckDelayTimerValue used during instantiation.
     */
    public void setResetAckDelayTimerValue(String resetAckDelayTimerValue)
            throws JNCException {
        setResetAckDelayTimerValue(new YangUInt8(resetAckDelayTimerValue));
    }

    /**
     * Unsets the value for child leaf "reset-ack-delay-timer".
     */
    public void unsetResetAckDelayTimerValue() throws JNCException {
        delete("reset-ack-delay-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reset-ack-delay-timer" leaf will not have a value.
     */
    public void addResetAckDelayTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-ack-delay-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reset-ack-delay-timer" with operation "replace".
     */
    public void markResetAckDelayTimerReplace() throws JNCException {
        markLeafReplace("resetAckDelayTimer");
    }

    /**
     * Marks the leaf "reset-ack-delay-timer" with operation "merge".
     */
    public void markResetAckDelayTimerMerge() throws JNCException {
        markLeafMerge("resetAckDelayTimer");
    }

    /**
     * Marks the leaf "reset-ack-delay-timer" with operation "create".
     */
    public void markResetAckDelayTimerCreate() throws JNCException {
        markLeafCreate("resetAckDelayTimer");
    }

    /**
     * Marks the leaf "reset-ack-delay-timer" with operation "delete".
     */
    public void markResetAckDelayTimerDelete() throws JNCException {
        markLeafDelete("resetAckDelayTimer");
    }

    /* Access methods for optional leaf child: "message-logging". */

    /**
     * Gets the value for child leaf "message-logging".
     * @return The value of the leaf.
     */
    public YangEnumeration getMessageLoggingValue() throws JNCException {
        YangEnumeration messageLogging = (YangEnumeration)getValue("message-logging");
        if (messageLogging == null) {
            messageLogging = new YangEnumeration("none", new String[] {  // default
                "write-replace-response",
                "none",
            });
        }
        return messageLogging;
    }

    /**
     * Sets the value for child leaf "message-logging",
     * using instance of generated typedef class.
     * @param messageLoggingValue The value to set.
     * @param messageLoggingValue used during instantiation.
     */
    public void setMessageLoggingValue(YangEnumeration messageLoggingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "message-logging",
            messageLoggingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "message-logging",
     * using a String value.
     * @param messageLoggingValue used during instantiation.
     */
    public void setMessageLoggingValue(String messageLoggingValue)
            throws JNCException {
        setMessageLoggingValue(new YangEnumeration(messageLoggingValue, new String[] {
             "write-replace-response",
             "none",
        }));
    }

    /**
     * Unsets the value for child leaf "message-logging".
     */
    public void unsetMessageLoggingValue() throws JNCException {
        delete("message-logging");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "message-logging" leaf will not have a value.
     */
    public void addMessageLogging() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "message-logging",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "message-logging" with operation "replace".
     */
    public void markMessageLoggingReplace() throws JNCException {
        markLeafReplace("messageLogging");
    }

    /**
     * Marks the leaf "message-logging" with operation "merge".
     */
    public void markMessageLoggingMerge() throws JNCException {
        markLeafMerge("messageLogging");
    }

    /**
     * Marks the leaf "message-logging" with operation "create".
     */
    public void markMessageLoggingCreate() throws JNCException {
        markLeafCreate("messageLogging");
    }

    /**
     * Marks the leaf "message-logging" with operation "delete".
     */
    public void markMessageLoggingDelete() throws JNCException {
        markLeafDelete("messageLogging");
    }

    /* Access methods for optional leaf child: "warning-message-timer". */

    /**
     * Gets the value for child leaf "warning-message-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getWarningMessageTimerValue() throws JNCException {
        YangUInt8 warningMessageTimer = (YangUInt8)getValue("warning-message-timer");
        if (warningMessageTimer == null) {
            warningMessageTimer = new YangUInt8("5");  // default
        }
        return warningMessageTimer;
    }

    /**
     * Sets the value for child leaf "warning-message-timer",
     * using instance of generated typedef class.
     * @param warningMessageTimerValue The value to set.
     * @param warningMessageTimerValue used during instantiation.
     */
    public void setWarningMessageTimerValue(YangUInt8 warningMessageTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "warning-message-timer",
            warningMessageTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "warning-message-timer",
     * using Java primitive values.
     * @param warningMessageTimerValue used during instantiation.
     */
    public void setWarningMessageTimerValue(short warningMessageTimerValue)
            throws JNCException {
        setWarningMessageTimerValue(new YangUInt8(warningMessageTimerValue));
    }

    /**
     * Sets the value for child leaf "warning-message-timer",
     * using a String value.
     * @param warningMessageTimerValue used during instantiation.
     */
    public void setWarningMessageTimerValue(String warningMessageTimerValue)
            throws JNCException {
        setWarningMessageTimerValue(new YangUInt8(warningMessageTimerValue));
    }

    /**
     * Unsets the value for child leaf "warning-message-timer".
     */
    public void unsetWarningMessageTimerValue() throws JNCException {
        delete("warning-message-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "warning-message-timer" leaf will not have a value.
     */
    public void addWarningMessageTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "warning-message-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "warning-message-timer" with operation "replace".
     */
    public void markWarningMessageTimerReplace() throws JNCException {
        markLeafReplace("warningMessageTimer");
    }

    /**
     * Marks the leaf "warning-message-timer" with operation "merge".
     */
    public void markWarningMessageTimerMerge() throws JNCException {
        markLeafMerge("warningMessageTimer");
    }

    /**
     * Marks the leaf "warning-message-timer" with operation "create".
     */
    public void markWarningMessageTimerCreate() throws JNCException {
        markLeafCreate("warningMessageTimer");
    }

    /**
     * Marks the leaf "warning-message-timer" with operation "delete".
     */
    public void markWarningMessageTimerDelete() throws JNCException {
        markLeafDelete("warningMessageTimer");
    }

    /* Access methods for optional leaf child: "warning-message-retry". */

    /**
     * Gets the value for child leaf "warning-message-retry".
     * @return The value of the leaf.
     */
    public YangUInt8 getWarningMessageRetryValue() throws JNCException {
        YangUInt8 warningMessageRetry = (YangUInt8)getValue("warning-message-retry");
        if (warningMessageRetry == null) {
            warningMessageRetry = new YangUInt8("0");  // default
        }
        return warningMessageRetry;
    }

    /**
     * Sets the value for child leaf "warning-message-retry",
     * using instance of generated typedef class.
     * @param warningMessageRetryValue The value to set.
     * @param warningMessageRetryValue used during instantiation.
     */
    public void setWarningMessageRetryValue(YangUInt8 warningMessageRetryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "warning-message-retry",
            warningMessageRetryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "warning-message-retry",
     * using Java primitive values.
     * @param warningMessageRetryValue used during instantiation.
     */
    public void setWarningMessageRetryValue(short warningMessageRetryValue)
            throws JNCException {
        setWarningMessageRetryValue(new YangUInt8(warningMessageRetryValue));
    }

    /**
     * Sets the value for child leaf "warning-message-retry",
     * using a String value.
     * @param warningMessageRetryValue used during instantiation.
     */
    public void setWarningMessageRetryValue(String warningMessageRetryValue)
            throws JNCException {
        setWarningMessageRetryValue(new YangUInt8(warningMessageRetryValue));
    }

    /**
     * Unsets the value for child leaf "warning-message-retry".
     */
    public void unsetWarningMessageRetryValue() throws JNCException {
        delete("warning-message-retry");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "warning-message-retry" leaf will not have a value.
     */
    public void addWarningMessageRetry() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "warning-message-retry",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "warning-message-retry" with operation "replace".
     */
    public void markWarningMessageRetryReplace() throws JNCException {
        markLeafReplace("warningMessageRetry");
    }

    /**
     * Marks the leaf "warning-message-retry" with operation "merge".
     */
    public void markWarningMessageRetryMerge() throws JNCException {
        markLeafMerge("warningMessageRetry");
    }

    /**
     * Marks the leaf "warning-message-retry" with operation "create".
     */
    public void markWarningMessageRetryCreate() throws JNCException {
        markLeafCreate("warningMessageRetry");
    }

    /**
     * Marks the leaf "warning-message-retry" with operation "delete".
     */
    public void markWarningMessageRetryDelete() throws JNCException {
        markLeafDelete("warningMessageRetry");
    }

    /* Access methods for optional leaf child: "sgw-gtpu-dual-tla-ip-filter". */

    /**
     * Gets the value for child leaf "sgw-gtpu-dual-tla-ip-filter".
     * @return The value of the leaf.
     */
    public YangEnumeration getSgwGtpuDualTlaIpFilterValue() throws JNCException {
        YangEnumeration sgwGtpuDualTlaIpFilter = (YangEnumeration)getValue("sgw-gtpu-dual-tla-ip-filter");
        if (sgwGtpuDualTlaIpFilter == null) {
            sgwGtpuDualTlaIpFilter = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return sgwGtpuDualTlaIpFilter;
    }

    /**
     * Sets the value for child leaf "sgw-gtpu-dual-tla-ip-filter",
     * using instance of generated typedef class.
     * @param sgwGtpuDualTlaIpFilterValue The value to set.
     * @param sgwGtpuDualTlaIpFilterValue used during instantiation.
     */
    public void setSgwGtpuDualTlaIpFilterValue(YangEnumeration sgwGtpuDualTlaIpFilterValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sgw-gtpu-dual-tla-ip-filter",
            sgwGtpuDualTlaIpFilterValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sgw-gtpu-dual-tla-ip-filter",
     * using a String value.
     * @param sgwGtpuDualTlaIpFilterValue used during instantiation.
     */
    public void setSgwGtpuDualTlaIpFilterValue(String sgwGtpuDualTlaIpFilterValue)
            throws JNCException {
        setSgwGtpuDualTlaIpFilterValue(new YangEnumeration(sgwGtpuDualTlaIpFilterValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "sgw-gtpu-dual-tla-ip-filter".
     */
    public void unsetSgwGtpuDualTlaIpFilterValue() throws JNCException {
        delete("sgw-gtpu-dual-tla-ip-filter");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sgw-gtpu-dual-tla-ip-filter" leaf will not have a value.
     */
    public void addSgwGtpuDualTlaIpFilter() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sgw-gtpu-dual-tla-ip-filter",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sgw-gtpu-dual-tla-ip-filter" with operation "replace".
     */
    public void markSgwGtpuDualTlaIpFilterReplace() throws JNCException {
        markLeafReplace("sgwGtpuDualTlaIpFilter");
    }

    /**
     * Marks the leaf "sgw-gtpu-dual-tla-ip-filter" with operation "merge".
     */
    public void markSgwGtpuDualTlaIpFilterMerge() throws JNCException {
        markLeafMerge("sgwGtpuDualTlaIpFilter");
    }

    /**
     * Marks the leaf "sgw-gtpu-dual-tla-ip-filter" with operation "create".
     */
    public void markSgwGtpuDualTlaIpFilterCreate() throws JNCException {
        markLeafCreate("sgwGtpuDualTlaIpFilter");
    }

    /**
     * Marks the leaf "sgw-gtpu-dual-tla-ip-filter" with operation "delete".
     */
    public void markSgwGtpuDualTlaIpFilterDelete() throws JNCException {
        markLeafDelete("sgwGtpuDualTlaIpFilter");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
