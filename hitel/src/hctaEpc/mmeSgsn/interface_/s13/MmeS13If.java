/* 
 * @(#)MmeS13If.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.s13;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/s13/mme-s13-if"
 * <p>
 * See line 476 in
 * dcConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeS13If extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeS13If object.
     */
    public MmeS13If() {
        super(Epc.NAMESPACE, "mme-s13-if");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeS13If clone() {
        return (MmeS13If)cloneContent(new MmeS13If());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeS13If cloneShallow() {
        return (MmeS13If)cloneShallowContent(new MmeS13If());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "realm-name",
            "request-timer",
            "request-retry",
            "include-imsi",
            "eir-host-id",
            "version",
        };
    }

    /* Access methods for optional leaf child: "realm-name". */

    /**
     * Gets the value for child leaf "realm-name".
     * @return The value of the leaf.
     */
    public YangString getRealmNameValue() throws JNCException {
        return (YangString)getValue("realm-name");
    }

    /**
     * Sets the value for child leaf "realm-name",
     * using instance of generated typedef class.
     * @param realmNameValue The value to set.
     * @param realmNameValue used during instantiation.
     */
    public void setRealmNameValue(YangString realmNameValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "realm-name",
            realmNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "realm-name",
     * using a String value.
     * @param realmNameValue used during instantiation.
     */
    public void setRealmNameValue(String realmNameValue) throws JNCException {
        setRealmNameValue(new YangString(realmNameValue));
    }

    /**
     * Unsets the value for child leaf "realm-name".
     */
    public void unsetRealmNameValue() throws JNCException {
        delete("realm-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "realm-name" leaf will not have a value.
     */
    public void addRealmName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "realm-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "realm-name" with operation "replace".
     */
    public void markRealmNameReplace() throws JNCException {
        markLeafReplace("realmName");
    }

    /**
     * Marks the leaf "realm-name" with operation "merge".
     */
    public void markRealmNameMerge() throws JNCException {
        markLeafMerge("realmName");
    }

    /**
     * Marks the leaf "realm-name" with operation "create".
     */
    public void markRealmNameCreate() throws JNCException {
        markLeafCreate("realmName");
    }

    /**
     * Marks the leaf "realm-name" with operation "delete".
     */
    public void markRealmNameDelete() throws JNCException {
        markLeafDelete("realmName");
    }

    /* Access methods for optional leaf child: "request-timer". */

    /**
     * Gets the value for child leaf "request-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getRequestTimerValue() throws JNCException {
        YangUInt8 requestTimer = (YangUInt8)getValue("request-timer");
        if (requestTimer == null) {
            requestTimer = new YangUInt8("5");  // default
        }
        return requestTimer;
    }

    /**
     * Sets the value for child leaf "request-timer",
     * using instance of generated typedef class.
     * @param requestTimerValue The value to set.
     * @param requestTimerValue used during instantiation.
     */
    public void setRequestTimerValue(YangUInt8 requestTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-timer",
            requestTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "request-timer",
     * using Java primitive values.
     * @param requestTimerValue used during instantiation.
     */
    public void setRequestTimerValue(short requestTimerValue)
            throws JNCException {
        setRequestTimerValue(new YangUInt8(requestTimerValue));
    }

    /**
     * Sets the value for child leaf "request-timer",
     * using a String value.
     * @param requestTimerValue used during instantiation.
     */
    public void setRequestTimerValue(String requestTimerValue)
            throws JNCException {
        setRequestTimerValue(new YangUInt8(requestTimerValue));
    }

    /**
     * Unsets the value for child leaf "request-timer".
     */
    public void unsetRequestTimerValue() throws JNCException {
        delete("request-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "request-timer" leaf will not have a value.
     */
    public void addRequestTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "request-timer" with operation "replace".
     */
    public void markRequestTimerReplace() throws JNCException {
        markLeafReplace("requestTimer");
    }

    /**
     * Marks the leaf "request-timer" with operation "merge".
     */
    public void markRequestTimerMerge() throws JNCException {
        markLeafMerge("requestTimer");
    }

    /**
     * Marks the leaf "request-timer" with operation "create".
     */
    public void markRequestTimerCreate() throws JNCException {
        markLeafCreate("requestTimer");
    }

    /**
     * Marks the leaf "request-timer" with operation "delete".
     */
    public void markRequestTimerDelete() throws JNCException {
        markLeafDelete("requestTimer");
    }

    /* Access methods for optional leaf child: "request-retry". */

    /**
     * Gets the value for child leaf "request-retry".
     * @return The value of the leaf.
     */
    public YangUInt8 getRequestRetryValue() throws JNCException {
        YangUInt8 requestRetry = (YangUInt8)getValue("request-retry");
        if (requestRetry == null) {
            requestRetry = new YangUInt8("0");  // default
        }
        return requestRetry;
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using instance of generated typedef class.
     * @param requestRetryValue The value to set.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(YangUInt8 requestRetryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-retry",
            requestRetryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using Java primitive values.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(short requestRetryValue)
            throws JNCException {
        setRequestRetryValue(new YangUInt8(requestRetryValue));
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using a String value.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(String requestRetryValue)
            throws JNCException {
        setRequestRetryValue(new YangUInt8(requestRetryValue));
    }

    /**
     * Unsets the value for child leaf "request-retry".
     */
    public void unsetRequestRetryValue() throws JNCException {
        delete("request-retry");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "request-retry" leaf will not have a value.
     */
    public void addRequestRetry() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-retry",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "request-retry" with operation "replace".
     */
    public void markRequestRetryReplace() throws JNCException {
        markLeafReplace("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "merge".
     */
    public void markRequestRetryMerge() throws JNCException {
        markLeafMerge("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "create".
     */
    public void markRequestRetryCreate() throws JNCException {
        markLeafCreate("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "delete".
     */
    public void markRequestRetryDelete() throws JNCException {
        markLeafDelete("requestRetry");
    }

    /* Access methods for optional leaf child: "include-imsi". */

    /**
     * Gets the value for child leaf "include-imsi".
     * @return The value of the leaf.
     */
    public YangEnumeration getIncludeImsiValue() throws JNCException {
        YangEnumeration includeImsi = (YangEnumeration)getValue("include-imsi");
        if (includeImsi == null) {
            includeImsi = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return includeImsi;
    }

    /**
     * Sets the value for child leaf "include-imsi",
     * using instance of generated typedef class.
     * @param includeImsiValue The value to set.
     * @param includeImsiValue used during instantiation.
     */
    public void setIncludeImsiValue(YangEnumeration includeImsiValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "include-imsi",
            includeImsiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "include-imsi",
     * using a String value.
     * @param includeImsiValue used during instantiation.
     */
    public void setIncludeImsiValue(String includeImsiValue)
            throws JNCException {
        setIncludeImsiValue(new YangEnumeration(includeImsiValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "include-imsi".
     */
    public void unsetIncludeImsiValue() throws JNCException {
        delete("include-imsi");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "include-imsi" leaf will not have a value.
     */
    public void addIncludeImsi() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "include-imsi",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "include-imsi" with operation "replace".
     */
    public void markIncludeImsiReplace() throws JNCException {
        markLeafReplace("includeImsi");
    }

    /**
     * Marks the leaf "include-imsi" with operation "merge".
     */
    public void markIncludeImsiMerge() throws JNCException {
        markLeafMerge("includeImsi");
    }

    /**
     * Marks the leaf "include-imsi" with operation "create".
     */
    public void markIncludeImsiCreate() throws JNCException {
        markLeafCreate("includeImsi");
    }

    /**
     * Marks the leaf "include-imsi" with operation "delete".
     */
    public void markIncludeImsiDelete() throws JNCException {
        markLeafDelete("includeImsi");
    }

    /* Access methods for optional leaf child: "eir-host-id". */

    /**
     * Gets the value for child leaf "eir-host-id".
     * @return The value of the leaf.
     */
    public YangString getEirHostIdValue() throws JNCException {
        YangString eirHostId = (YangString)getValue("eir-host-id");
        if (eirHostId == null) {
            eirHostId = new YangString("none");  // default
        }
        return eirHostId;
    }

    /**
     * Sets the value for child leaf "eir-host-id",
     * using instance of generated typedef class.
     * @param eirHostIdValue The value to set.
     * @param eirHostIdValue used during instantiation.
     */
    public void setEirHostIdValue(YangString eirHostIdValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "eir-host-id",
            eirHostIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "eir-host-id",
     * using a String value.
     * @param eirHostIdValue used during instantiation.
     */
    public void setEirHostIdValue(String eirHostIdValue) throws JNCException {
        setEirHostIdValue(new YangString(eirHostIdValue));
    }

    /**
     * Unsets the value for child leaf "eir-host-id".
     */
    public void unsetEirHostIdValue() throws JNCException {
        delete("eir-host-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "eir-host-id" leaf will not have a value.
     */
    public void addEirHostId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "eir-host-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "eir-host-id" with operation "replace".
     */
    public void markEirHostIdReplace() throws JNCException {
        markLeafReplace("eirHostId");
    }

    /**
     * Marks the leaf "eir-host-id" with operation "merge".
     */
    public void markEirHostIdMerge() throws JNCException {
        markLeafMerge("eirHostId");
    }

    /**
     * Marks the leaf "eir-host-id" with operation "create".
     */
    public void markEirHostIdCreate() throws JNCException {
        markLeafCreate("eirHostId");
    }

    /**
     * Marks the leaf "eir-host-id" with operation "delete".
     */
    public void markEirHostIdDelete() throws JNCException {
        markLeafDelete("eirHostId");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10.7.0", new String[] {  // default
                "9.5.0",
                "10.7.0",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "9.5.0",
             "10.7.0",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
