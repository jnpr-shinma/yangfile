/* 
 * @(#)MmeS102If.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.s102;
import .ietfInetTypes.Ipv4Address;
import .ietfInetTypes.Ipv6Address;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/s102/mme-s102-if"
 * <p>
 * See line 416 in
 * upmConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeS102If extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeS102If object.
     */
    public MmeS102If() {
        super(Epc.NAMESPACE, "mme-s102-if");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeS102If clone() {
        return (MmeS102If)cloneContent(new MmeS102If());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeS102If cloneShallow() {
        return (MmeS102If)cloneShallowContent(new MmeS102If());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "routing-instance",
            "hss-realm-for-min-query",
            "ip-address-v4",
            "ip-address-v6",
            "port",
            "version",
            "dscp-mark",
            "echo-interval",
            "t-ack-21-timer",
            "request-retry",
            "max-pending-transactions",
            "priority-paging",
            "enb-map-lifetime",
        };
    }

    /* Access methods for optional leaf child: "routing-instance". */

    /**
     * Gets the value for child leaf "routing-instance".
     * @return The value of the leaf.
     */
    public YangString getRoutingInstanceValue() throws JNCException {
        return (YangString)getValue("routing-instance");
    }

    /**
     * Sets the value for child leaf "routing-instance",
     * using instance of generated typedef class.
     * @param routingInstanceValue The value to set.
     * @param routingInstanceValue used during instantiation.
     */
    public void setRoutingInstanceValue(YangString routingInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance",
            routingInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "routing-instance",
     * using a String value.
     * @param routingInstanceValue used during instantiation.
     */
    public void setRoutingInstanceValue(String routingInstanceValue)
            throws JNCException {
        setRoutingInstanceValue(new YangString(routingInstanceValue));
    }

    /**
     * Unsets the value for child leaf "routing-instance".
     */
    public void unsetRoutingInstanceValue() throws JNCException {
        delete("routing-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "routing-instance" leaf will not have a value.
     */
    public void addRoutingInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "routing-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "routing-instance" with operation "replace".
     */
    public void markRoutingInstanceReplace() throws JNCException {
        markLeafReplace("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "merge".
     */
    public void markRoutingInstanceMerge() throws JNCException {
        markLeafMerge("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "create".
     */
    public void markRoutingInstanceCreate() throws JNCException {
        markLeafCreate("routingInstance");
    }

    /**
     * Marks the leaf "routing-instance" with operation "delete".
     */
    public void markRoutingInstanceDelete() throws JNCException {
        markLeafDelete("routingInstance");
    }

    /* Access methods for optional leaf child: "hss-realm-for-min-query". */

    /**
     * Gets the value for child leaf "hss-realm-for-min-query".
     * @return The value of the leaf.
     */
    public YangString getHssRealmForMinQueryValue() throws JNCException {
        return (YangString)getValue("hss-realm-for-min-query");
    }

    /**
     * Sets the value for child leaf "hss-realm-for-min-query",
     * using instance of generated typedef class.
     * @param hssRealmForMinQueryValue The value to set.
     * @param hssRealmForMinQueryValue used during instantiation.
     */
    public void setHssRealmForMinQueryValue(YangString hssRealmForMinQueryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hss-realm-for-min-query",
            hssRealmForMinQueryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "hss-realm-for-min-query",
     * using a String value.
     * @param hssRealmForMinQueryValue used during instantiation.
     */
    public void setHssRealmForMinQueryValue(String hssRealmForMinQueryValue)
            throws JNCException {
        setHssRealmForMinQueryValue(new YangString(hssRealmForMinQueryValue));
    }

    /**
     * Unsets the value for child leaf "hss-realm-for-min-query".
     */
    public void unsetHssRealmForMinQueryValue() throws JNCException {
        delete("hss-realm-for-min-query");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "hss-realm-for-min-query" leaf will not have a value.
     */
    public void addHssRealmForMinQuery() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "hss-realm-for-min-query",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "hss-realm-for-min-query" with operation "replace".
     */
    public void markHssRealmForMinQueryReplace() throws JNCException {
        markLeafReplace("hssRealmForMinQuery");
    }

    /**
     * Marks the leaf "hss-realm-for-min-query" with operation "merge".
     */
    public void markHssRealmForMinQueryMerge() throws JNCException {
        markLeafMerge("hssRealmForMinQuery");
    }

    /**
     * Marks the leaf "hss-realm-for-min-query" with operation "create".
     */
    public void markHssRealmForMinQueryCreate() throws JNCException {
        markLeafCreate("hssRealmForMinQuery");
    }

    /**
     * Marks the leaf "hss-realm-for-min-query" with operation "delete".
     */
    public void markHssRealmForMinQueryDelete() throws JNCException {
        markLeafDelete("hssRealmForMinQuery");
    }

    /* Access methods for optional leaf child: "ip-address-v4". */

    /**
     * Gets the value for child leaf "ip-address-v4".
     * @return The value of the leaf.
     */
    public Ipv4Address getIpAddressV4Value() throws JNCException {
        return (Ipv4Address)getValue("ip-address-v4");
    }

    /**
     * Sets the value for child leaf "ip-address-v4",
     * using a JNC type value.
     * @param ipAddressV4Value The value to set.
     * @param ipAddressV4Value used during instantiation.
     */
    public void setIpAddressV4Value(Ipv4Address ipAddressV4Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address-v4",
            ipAddressV4Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address-v4",
     * using a String value.
     * @param ipAddressV4Value used during instantiation.
     */
    public void setIpAddressV4Value(String ipAddressV4Value)
            throws JNCException {
        setIpAddressV4Value(new Ipv4Address(ipAddressV4Value));
    }

    /**
     * Unsets the value for child leaf "ip-address-v4".
     */
    public void unsetIpAddressV4Value() throws JNCException {
        delete("ip-address-v4");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address-v4" leaf will not have a value.
     */
    public void addIpAddressV4() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address-v4",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address-v4" with operation "replace".
     */
    public void markIpAddressV4Replace() throws JNCException {
        markLeafReplace("ipAddressV4");
    }

    /**
     * Marks the leaf "ip-address-v4" with operation "merge".
     */
    public void markIpAddressV4Merge() throws JNCException {
        markLeafMerge("ipAddressV4");
    }

    /**
     * Marks the leaf "ip-address-v4" with operation "create".
     */
    public void markIpAddressV4Create() throws JNCException {
        markLeafCreate("ipAddressV4");
    }

    /**
     * Marks the leaf "ip-address-v4" with operation "delete".
     */
    public void markIpAddressV4Delete() throws JNCException {
        markLeafDelete("ipAddressV4");
    }

    /* Access methods for optional leaf child: "ip-address-v6". */

    /**
     * Gets the value for child leaf "ip-address-v6".
     * @return The value of the leaf.
     */
    public Ipv6Address getIpAddressV6Value() throws JNCException {
        Ipv6Address ipAddressV6 = (Ipv6Address)getValue("ip-address-v6");
        if (ipAddressV6 == null) {
            ipAddressV6 = new Ipv6Address("0:0:0:0:0:0:0:0");  // default
        }
        return ipAddressV6;
    }

    /**
     * Sets the value for child leaf "ip-address-v6",
     * using a JNC type value.
     * @param ipAddressV6Value The value to set.
     * @param ipAddressV6Value used during instantiation.
     */
    public void setIpAddressV6Value(Ipv6Address ipAddressV6Value)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address-v6",
            ipAddressV6Value,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address-v6",
     * using a String value.
     * @param ipAddressV6Value used during instantiation.
     */
    public void setIpAddressV6Value(String ipAddressV6Value)
            throws JNCException {
        setIpAddressV6Value(new Ipv6Address(ipAddressV6Value));
    }

    /**
     * Unsets the value for child leaf "ip-address-v6".
     */
    public void unsetIpAddressV6Value() throws JNCException {
        delete("ip-address-v6");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address-v6" leaf will not have a value.
     */
    public void addIpAddressV6() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address-v6",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address-v6" with operation "replace".
     */
    public void markIpAddressV6Replace() throws JNCException {
        markLeafReplace("ipAddressV6");
    }

    /**
     * Marks the leaf "ip-address-v6" with operation "merge".
     */
    public void markIpAddressV6Merge() throws JNCException {
        markLeafMerge("ipAddressV6");
    }

    /**
     * Marks the leaf "ip-address-v6" with operation "create".
     */
    public void markIpAddressV6Create() throws JNCException {
        markLeafCreate("ipAddressV6");
    }

    /**
     * Marks the leaf "ip-address-v6" with operation "delete".
     */
    public void markIpAddressV6Delete() throws JNCException {
        markLeafDelete("ipAddressV6");
    }

    /* Access methods for optional leaf child: "port". */

    /**
     * Gets the value for child leaf "port".
     * @return The value of the leaf.
     */
    public YangUInt16 getPortValue() throws JNCException {
        YangUInt16 port = (YangUInt16)getValue("port");
        if (port == null) {
            port = new YangUInt16("23272");  // default
        }
        return port;
    }

    /**
     * Sets the value for child leaf "port",
     * using instance of generated typedef class.
     * @param portValue The value to set.
     * @param portValue used during instantiation.
     */
    public void setPortValue(YangUInt16 portValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            portValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "port",
     * using Java primitive values.
     * @param portValue used during instantiation.
     */
    public void setPortValue(int portValue) throws JNCException {
        setPortValue(new YangUInt16(portValue));
    }

    /**
     * Sets the value for child leaf "port",
     * using a String value.
     * @param portValue used during instantiation.
     */
    public void setPortValue(String portValue) throws JNCException {
        setPortValue(new YangUInt16(portValue));
    }

    /**
     * Unsets the value for child leaf "port".
     */
    public void unsetPortValue() throws JNCException {
        delete("port");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "port" leaf will not have a value.
     */
    public void addPort() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "port" with operation "replace".
     */
    public void markPortReplace() throws JNCException {
        markLeafReplace("port");
    }

    /**
     * Marks the leaf "port" with operation "merge".
     */
    public void markPortMerge() throws JNCException {
        markLeafMerge("port");
    }

    /**
     * Marks the leaf "port" with operation "create".
     */
    public void markPortCreate() throws JNCException {
        markLeafCreate("port");
    }

    /**
     * Marks the leaf "port" with operation "delete".
     */
    public void markPortDelete() throws JNCException {
        markLeafDelete("port");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10.0.0", new String[] {  // default
                "icd-v2",
                "10.0.0",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "icd-v2",
             "10.0.0",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /* Access methods for optional leaf child: "echo-interval". */

    /**
     * Gets the value for child leaf "echo-interval".
     * @return The value of the leaf.
     */
    public YangString getEchoIntervalValue() throws JNCException {
        YangString echoInterval = (YangString)getValue("echo-interval");
        if (echoInterval == null) {
            echoInterval = new YangString("4");  // default
        }
        return echoInterval;
    }

    /**
     * Sets the value for child leaf "echo-interval",
     * using instance of generated typedef class.
     * @param echoIntervalValue The value to set.
     * @param echoIntervalValue used during instantiation.
     */
    public void setEchoIntervalValue(YangString echoIntervalValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "echo-interval",
            echoIntervalValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "echo-interval",
     * using a String value.
     * @param echoIntervalValue used during instantiation.
     */
    public void setEchoIntervalValue(String echoIntervalValue)
            throws JNCException {
        setEchoIntervalValue(new YangString(echoIntervalValue));
    }

    /**
     * Unsets the value for child leaf "echo-interval".
     */
    public void unsetEchoIntervalValue() throws JNCException {
        delete("echo-interval");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "echo-interval" leaf will not have a value.
     */
    public void addEchoInterval() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "echo-interval",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "echo-interval" with operation "replace".
     */
    public void markEchoIntervalReplace() throws JNCException {
        markLeafReplace("echoInterval");
    }

    /**
     * Marks the leaf "echo-interval" with operation "merge".
     */
    public void markEchoIntervalMerge() throws JNCException {
        markLeafMerge("echoInterval");
    }

    /**
     * Marks the leaf "echo-interval" with operation "create".
     */
    public void markEchoIntervalCreate() throws JNCException {
        markLeafCreate("echoInterval");
    }

    /**
     * Marks the leaf "echo-interval" with operation "delete".
     */
    public void markEchoIntervalDelete() throws JNCException {
        markLeafDelete("echoInterval");
    }

    /* Access methods for optional leaf child: "t-ack-21-timer". */

    /**
     * Gets the value for child leaf "t-ack-21-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getTAck21TimerValue() throws JNCException {
        YangUInt8 tAck21Timer = (YangUInt8)getValue("t-ack-21-timer");
        if (tAck21Timer == null) {
            tAck21Timer = new YangUInt8("5");  // default
        }
        return tAck21Timer;
    }

    /**
     * Sets the value for child leaf "t-ack-21-timer",
     * using instance of generated typedef class.
     * @param tAck21TimerValue The value to set.
     * @param tAck21TimerValue used during instantiation.
     */
    public void setTAck21TimerValue(YangUInt8 tAck21TimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "t-ack-21-timer",
            tAck21TimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "t-ack-21-timer",
     * using Java primitive values.
     * @param tAck21TimerValue used during instantiation.
     */
    public void setTAck21TimerValue(short tAck21TimerValue) throws JNCException {
        setTAck21TimerValue(new YangUInt8(tAck21TimerValue));
    }

    /**
     * Sets the value for child leaf "t-ack-21-timer",
     * using a String value.
     * @param tAck21TimerValue used during instantiation.
     */
    public void setTAck21TimerValue(String tAck21TimerValue)
            throws JNCException {
        setTAck21TimerValue(new YangUInt8(tAck21TimerValue));
    }

    /**
     * Unsets the value for child leaf "t-ack-21-timer".
     */
    public void unsetTAck21TimerValue() throws JNCException {
        delete("t-ack-21-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "t-ack-21-timer" leaf will not have a value.
     */
    public void addTAck21Timer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "t-ack-21-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "t-ack-21-timer" with operation "replace".
     */
    public void markTAck21TimerReplace() throws JNCException {
        markLeafReplace("tAck21Timer");
    }

    /**
     * Marks the leaf "t-ack-21-timer" with operation "merge".
     */
    public void markTAck21TimerMerge() throws JNCException {
        markLeafMerge("tAck21Timer");
    }

    /**
     * Marks the leaf "t-ack-21-timer" with operation "create".
     */
    public void markTAck21TimerCreate() throws JNCException {
        markLeafCreate("tAck21Timer");
    }

    /**
     * Marks the leaf "t-ack-21-timer" with operation "delete".
     */
    public void markTAck21TimerDelete() throws JNCException {
        markLeafDelete("tAck21Timer");
    }

    /* Access methods for optional leaf child: "request-retry". */

    /**
     * Gets the value for child leaf "request-retry".
     * @return The value of the leaf.
     */
    public YangUInt8 getRequestRetryValue() throws JNCException {
        YangUInt8 requestRetry = (YangUInt8)getValue("request-retry");
        if (requestRetry == null) {
            requestRetry = new YangUInt8("1");  // default
        }
        return requestRetry;
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using instance of generated typedef class.
     * @param requestRetryValue The value to set.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(YangUInt8 requestRetryValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-retry",
            requestRetryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using Java primitive values.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(short requestRetryValue)
            throws JNCException {
        setRequestRetryValue(new YangUInt8(requestRetryValue));
    }

    /**
     * Sets the value for child leaf "request-retry",
     * using a String value.
     * @param requestRetryValue used during instantiation.
     */
    public void setRequestRetryValue(String requestRetryValue)
            throws JNCException {
        setRequestRetryValue(new YangUInt8(requestRetryValue));
    }

    /**
     * Unsets the value for child leaf "request-retry".
     */
    public void unsetRequestRetryValue() throws JNCException {
        delete("request-retry");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "request-retry" leaf will not have a value.
     */
    public void addRequestRetry() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "request-retry",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "request-retry" with operation "replace".
     */
    public void markRequestRetryReplace() throws JNCException {
        markLeafReplace("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "merge".
     */
    public void markRequestRetryMerge() throws JNCException {
        markLeafMerge("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "create".
     */
    public void markRequestRetryCreate() throws JNCException {
        markLeafCreate("requestRetry");
    }

    /**
     * Marks the leaf "request-retry" with operation "delete".
     */
    public void markRequestRetryDelete() throws JNCException {
        markLeafDelete("requestRetry");
    }

    /* Access methods for optional leaf child: "max-pending-transactions". */

    /**
     * Gets the value for child leaf "max-pending-transactions".
     * @return The value of the leaf.
     */
    public YangUInt16 getMaxPendingTransactionsValue() throws JNCException {
        YangUInt16 maxPendingTransactions = (YangUInt16)getValue("max-pending-transactions");
        if (maxPendingTransactions == null) {
            maxPendingTransactions = new YangUInt16("250");  // default
        }
        return maxPendingTransactions;
    }

    /**
     * Sets the value for child leaf "max-pending-transactions",
     * using instance of generated typedef class.
     * @param maxPendingTransactionsValue The value to set.
     * @param maxPendingTransactionsValue used during instantiation.
     */
    public void setMaxPendingTransactionsValue(YangUInt16 maxPendingTransactionsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-pending-transactions",
            maxPendingTransactionsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "max-pending-transactions",
     * using Java primitive values.
     * @param maxPendingTransactionsValue used during instantiation.
     */
    public void setMaxPendingTransactionsValue(int maxPendingTransactionsValue)
            throws JNCException {
        setMaxPendingTransactionsValue(new YangUInt16(maxPendingTransactionsValue));
    }

    /**
     * Sets the value for child leaf "max-pending-transactions",
     * using a String value.
     * @param maxPendingTransactionsValue used during instantiation.
     */
    public void setMaxPendingTransactionsValue(String maxPendingTransactionsValue)
            throws JNCException {
        setMaxPendingTransactionsValue(new YangUInt16(maxPendingTransactionsValue));
    }

    /**
     * Unsets the value for child leaf "max-pending-transactions".
     */
    public void unsetMaxPendingTransactionsValue() throws JNCException {
        delete("max-pending-transactions");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "max-pending-transactions" leaf will not have a value.
     */
    public void addMaxPendingTransactions() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "max-pending-transactions",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "max-pending-transactions" with operation "replace".
     */
    public void markMaxPendingTransactionsReplace() throws JNCException {
        markLeafReplace("maxPendingTransactions");
    }

    /**
     * Marks the leaf "max-pending-transactions" with operation "merge".
     */
    public void markMaxPendingTransactionsMerge() throws JNCException {
        markLeafMerge("maxPendingTransactions");
    }

    /**
     * Marks the leaf "max-pending-transactions" with operation "create".
     */
    public void markMaxPendingTransactionsCreate() throws JNCException {
        markLeafCreate("maxPendingTransactions");
    }

    /**
     * Marks the leaf "max-pending-transactions" with operation "delete".
     */
    public void markMaxPendingTransactionsDelete() throws JNCException {
        markLeafDelete("maxPendingTransactions");
    }

    /* Access methods for optional leaf child: "priority-paging". */

    /**
     * Gets the value for child leaf "priority-paging".
     * @return The value of the leaf.
     */
    public YangEnumeration getPriorityPagingValue() throws JNCException {
        YangEnumeration priorityPaging = (YangEnumeration)getValue("priority-paging");
        if (priorityPaging == null) {
            priorityPaging = new YangEnumeration("disable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return priorityPaging;
    }

    /**
     * Sets the value for child leaf "priority-paging",
     * using instance of generated typedef class.
     * @param priorityPagingValue The value to set.
     * @param priorityPagingValue used during instantiation.
     */
    public void setPriorityPagingValue(YangEnumeration priorityPagingValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "priority-paging",
            priorityPagingValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "priority-paging",
     * using a String value.
     * @param priorityPagingValue used during instantiation.
     */
    public void setPriorityPagingValue(String priorityPagingValue)
            throws JNCException {
        setPriorityPagingValue(new YangEnumeration(priorityPagingValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "priority-paging".
     */
    public void unsetPriorityPagingValue() throws JNCException {
        delete("priority-paging");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "priority-paging" leaf will not have a value.
     */
    public void addPriorityPaging() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "priority-paging",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "priority-paging" with operation "replace".
     */
    public void markPriorityPagingReplace() throws JNCException {
        markLeafReplace("priorityPaging");
    }

    /**
     * Marks the leaf "priority-paging" with operation "merge".
     */
    public void markPriorityPagingMerge() throws JNCException {
        markLeafMerge("priorityPaging");
    }

    /**
     * Marks the leaf "priority-paging" with operation "create".
     */
    public void markPriorityPagingCreate() throws JNCException {
        markLeafCreate("priorityPaging");
    }

    /**
     * Marks the leaf "priority-paging" with operation "delete".
     */
    public void markPriorityPagingDelete() throws JNCException {
        markLeafDelete("priorityPaging");
    }

    /* Access methods for optional leaf child: "enb-map-lifetime". */

    /**
     * Gets the value for child leaf "enb-map-lifetime".
     * @return The value of the leaf.
     */
    public YangUInt8 getEnbMapLifetimeValue() throws JNCException {
        YangUInt8 enbMapLifetime = (YangUInt8)getValue("enb-map-lifetime");
        if (enbMapLifetime == null) {
            enbMapLifetime = new YangUInt8("24");  // default
        }
        return enbMapLifetime;
    }

    /**
     * Sets the value for child leaf "enb-map-lifetime",
     * using instance of generated typedef class.
     * @param enbMapLifetimeValue The value to set.
     * @param enbMapLifetimeValue used during instantiation.
     */
    public void setEnbMapLifetimeValue(YangUInt8 enbMapLifetimeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enb-map-lifetime",
            enbMapLifetimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enb-map-lifetime",
     * using Java primitive values.
     * @param enbMapLifetimeValue used during instantiation.
     */
    public void setEnbMapLifetimeValue(short enbMapLifetimeValue)
            throws JNCException {
        setEnbMapLifetimeValue(new YangUInt8(enbMapLifetimeValue));
    }

    /**
     * Sets the value for child leaf "enb-map-lifetime",
     * using a String value.
     * @param enbMapLifetimeValue used during instantiation.
     */
    public void setEnbMapLifetimeValue(String enbMapLifetimeValue)
            throws JNCException {
        setEnbMapLifetimeValue(new YangUInt8(enbMapLifetimeValue));
    }

    /**
     * Unsets the value for child leaf "enb-map-lifetime".
     */
    public void unsetEnbMapLifetimeValue() throws JNCException {
        delete("enb-map-lifetime");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enb-map-lifetime" leaf will not have a value.
     */
    public void addEnbMapLifetime() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "enb-map-lifetime",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enb-map-lifetime" with operation "replace".
     */
    public void markEnbMapLifetimeReplace() throws JNCException {
        markLeafReplace("enbMapLifetime");
    }

    /**
     * Marks the leaf "enb-map-lifetime" with operation "merge".
     */
    public void markEnbMapLifetimeMerge() throws JNCException {
        markLeafMerge("enbMapLifetime");
    }

    /**
     * Marks the leaf "enb-map-lifetime" with operation "create".
     */
    public void markEnbMapLifetimeCreate() throws JNCException {
        markLeafCreate("enbMapLifetime");
    }

    /**
     * Marks the leaf "enb-map-lifetime" with operation "delete".
     */
    public void markEnbMapLifetimeDelete() throws JNCException {
        markLeafDelete("enbMapLifetime");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
