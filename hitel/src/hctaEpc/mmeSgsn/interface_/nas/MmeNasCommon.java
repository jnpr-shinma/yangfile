/* 
 * @(#)MmeNasCommon.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.nas;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/nas/mme-nas-common"
 * <p>
 * See line 1913 in
 * scConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeNasCommon extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeNasCommon object.
     */
    public MmeNasCommon() {
        super(Epc.NAMESPACE, "mme-nas-common");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeNasCommon clone() {
        return (MmeNasCommon)cloneContent(new MmeNasCommon());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeNasCommon cloneShallow() {
        return (MmeNasCommon)cloneShallowContent(new MmeNasCommon());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "ppf-reset-timer",
            "reset-timer",
            "topological-search",
            "security-context-lifetime",
            "dual-addr-bearer",
            "pdn-type-preference",
            "full-network-name",
            "short-network-name",
            "mm-info-triggers",
            "mm-info-lifetime",
            "version",
            "use-pgwid-from-hss",
            "gw-reselection-retries",
            "native-mme-groups",
            "non-broadcast-tai",
        };
    }

    /* Access methods for optional leaf child: "ppf-reset-timer". */

    /**
     * Gets the value for child leaf "ppf-reset-timer".
     * @return The value of the leaf.
     */
    public YangString getPpfResetTimerValue() throws JNCException {
        YangString ppfResetTimer = (YangString)getValue("ppf-reset-timer");
        if (ppfResetTimer == null) {
            ppfResetTimer = new YangString("disable");  // default
        }
        return ppfResetTimer;
    }

    /**
     * Sets the value for child leaf "ppf-reset-timer",
     * using instance of generated typedef class.
     * @param ppfResetTimerValue The value to set.
     * @param ppfResetTimerValue used during instantiation.
     */
    public void setPpfResetTimerValue(YangString ppfResetTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ppf-reset-timer",
            ppfResetTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ppf-reset-timer",
     * using a String value.
     * @param ppfResetTimerValue used during instantiation.
     */
    public void setPpfResetTimerValue(String ppfResetTimerValue)
            throws JNCException {
        setPpfResetTimerValue(new YangString(ppfResetTimerValue));
    }

    /**
     * Unsets the value for child leaf "ppf-reset-timer".
     */
    public void unsetPpfResetTimerValue() throws JNCException {
        delete("ppf-reset-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ppf-reset-timer" leaf will not have a value.
     */
    public void addPpfResetTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ppf-reset-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ppf-reset-timer" with operation "replace".
     */
    public void markPpfResetTimerReplace() throws JNCException {
        markLeafReplace("ppfResetTimer");
    }

    /**
     * Marks the leaf "ppf-reset-timer" with operation "merge".
     */
    public void markPpfResetTimerMerge() throws JNCException {
        markLeafMerge("ppfResetTimer");
    }

    /**
     * Marks the leaf "ppf-reset-timer" with operation "create".
     */
    public void markPpfResetTimerCreate() throws JNCException {
        markLeafCreate("ppfResetTimer");
    }

    /**
     * Marks the leaf "ppf-reset-timer" with operation "delete".
     */
    public void markPpfResetTimerDelete() throws JNCException {
        markLeafDelete("ppfResetTimer");
    }

    /* Access methods for optional leaf child: "reset-timer". */

    /**
     * Gets the value for child leaf "reset-timer".
     * @return The value of the leaf.
     */
    public YangUInt8 getResetTimerValue() throws JNCException {
        YangUInt8 resetTimer = (YangUInt8)getValue("reset-timer");
        if (resetTimer == null) {
            resetTimer = new YangUInt8("60");  // default
        }
        return resetTimer;
    }

    /**
     * Sets the value for child leaf "reset-timer",
     * using instance of generated typedef class.
     * @param resetTimerValue The value to set.
     * @param resetTimerValue used during instantiation.
     */
    public void setResetTimerValue(YangUInt8 resetTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-timer",
            resetTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "reset-timer",
     * using Java primitive values.
     * @param resetTimerValue used during instantiation.
     */
    public void setResetTimerValue(short resetTimerValue) throws JNCException {
        setResetTimerValue(new YangUInt8(resetTimerValue));
    }

    /**
     * Sets the value for child leaf "reset-timer",
     * using a String value.
     * @param resetTimerValue used during instantiation.
     */
    public void setResetTimerValue(String resetTimerValue) throws JNCException {
        setResetTimerValue(new YangUInt8(resetTimerValue));
    }

    /**
     * Unsets the value for child leaf "reset-timer".
     */
    public void unsetResetTimerValue() throws JNCException {
        delete("reset-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "reset-timer" leaf will not have a value.
     */
    public void addResetTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "reset-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "reset-timer" with operation "replace".
     */
    public void markResetTimerReplace() throws JNCException {
        markLeafReplace("resetTimer");
    }

    /**
     * Marks the leaf "reset-timer" with operation "merge".
     */
    public void markResetTimerMerge() throws JNCException {
        markLeafMerge("resetTimer");
    }

    /**
     * Marks the leaf "reset-timer" with operation "create".
     */
    public void markResetTimerCreate() throws JNCException {
        markLeafCreate("resetTimer");
    }

    /**
     * Marks the leaf "reset-timer" with operation "delete".
     */
    public void markResetTimerDelete() throws JNCException {
        markLeafDelete("resetTimer");
    }

    /* Access methods for optional leaf child: "topological-search". */

    /**
     * Gets the value for child leaf "topological-search".
     * @return The value of the leaf.
     */
    public YangEnumeration getTopologicalSearchValue() throws JNCException {
        YangEnumeration topologicalSearch = (YangEnumeration)getValue("topological-search");
        if (topologicalSearch == null) {
            topologicalSearch = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return topologicalSearch;
    }

    /**
     * Sets the value for child leaf "topological-search",
     * using instance of generated typedef class.
     * @param topologicalSearchValue The value to set.
     * @param topologicalSearchValue used during instantiation.
     */
    public void setTopologicalSearchValue(YangEnumeration topologicalSearchValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "topological-search",
            topologicalSearchValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "topological-search",
     * using a String value.
     * @param topologicalSearchValue used during instantiation.
     */
    public void setTopologicalSearchValue(String topologicalSearchValue)
            throws JNCException {
        setTopologicalSearchValue(new YangEnumeration(topologicalSearchValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "topological-search".
     */
    public void unsetTopologicalSearchValue() throws JNCException {
        delete("topological-search");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "topological-search" leaf will not have a value.
     */
    public void addTopologicalSearch() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "topological-search",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "topological-search" with operation "replace".
     */
    public void markTopologicalSearchReplace() throws JNCException {
        markLeafReplace("topologicalSearch");
    }

    /**
     * Marks the leaf "topological-search" with operation "merge".
     */
    public void markTopologicalSearchMerge() throws JNCException {
        markLeafMerge("topologicalSearch");
    }

    /**
     * Marks the leaf "topological-search" with operation "create".
     */
    public void markTopologicalSearchCreate() throws JNCException {
        markLeafCreate("topologicalSearch");
    }

    /**
     * Marks the leaf "topological-search" with operation "delete".
     */
    public void markTopologicalSearchDelete() throws JNCException {
        markLeafDelete("topologicalSearch");
    }

    /* Access methods for optional leaf child: "security-context-lifetime". */

    /**
     * Gets the value for child leaf "security-context-lifetime".
     * @return The value of the leaf.
     */
    public YangString getSecurityContextLifetimeValue() throws JNCException {
        YangString securityContextLifetime = (YangString)getValue("security-context-lifetime");
        if (securityContextLifetime == null) {
            securityContextLifetime = new YangString("disable");  // default
        }
        return securityContextLifetime;
    }

    /**
     * Sets the value for child leaf "security-context-lifetime",
     * using instance of generated typedef class.
     * @param securityContextLifetimeValue The value to set.
     * @param securityContextLifetimeValue used during instantiation.
     */
    public void setSecurityContextLifetimeValue(YangString securityContextLifetimeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-context-lifetime",
            securityContextLifetimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "security-context-lifetime",
     * using a String value.
     * @param securityContextLifetimeValue used during instantiation.
     */
    public void setSecurityContextLifetimeValue(String securityContextLifetimeValue)
            throws JNCException {
        setSecurityContextLifetimeValue(new YangString(securityContextLifetimeValue));
    }

    /**
     * Unsets the value for child leaf "security-context-lifetime".
     */
    public void unsetSecurityContextLifetimeValue() throws JNCException {
        delete("security-context-lifetime");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "security-context-lifetime" leaf will not have a value.
     */
    public void addSecurityContextLifetime() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "security-context-lifetime",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "security-context-lifetime" with operation "replace".
     */
    public void markSecurityContextLifetimeReplace() throws JNCException {
        markLeafReplace("securityContextLifetime");
    }

    /**
     * Marks the leaf "security-context-lifetime" with operation "merge".
     */
    public void markSecurityContextLifetimeMerge() throws JNCException {
        markLeafMerge("securityContextLifetime");
    }

    /**
     * Marks the leaf "security-context-lifetime" with operation "create".
     */
    public void markSecurityContextLifetimeCreate() throws JNCException {
        markLeafCreate("securityContextLifetime");
    }

    /**
     * Marks the leaf "security-context-lifetime" with operation "delete".
     */
    public void markSecurityContextLifetimeDelete() throws JNCException {
        markLeafDelete("securityContextLifetime");
    }

    /* Access methods for optional leaf child: "dual-addr-bearer". */

    /**
     * Gets the value for child leaf "dual-addr-bearer".
     * @return The value of the leaf.
     */
    public YangEnumeration getDualAddrBearerValue() throws JNCException {
        YangEnumeration dualAddrBearer = (YangEnumeration)getValue("dual-addr-bearer");
        if (dualAddrBearer == null) {
            dualAddrBearer = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return dualAddrBearer;
    }

    /**
     * Sets the value for child leaf "dual-addr-bearer",
     * using instance of generated typedef class.
     * @param dualAddrBearerValue The value to set.
     * @param dualAddrBearerValue used during instantiation.
     */
    public void setDualAddrBearerValue(YangEnumeration dualAddrBearerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dual-addr-bearer",
            dualAddrBearerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dual-addr-bearer",
     * using a String value.
     * @param dualAddrBearerValue used during instantiation.
     */
    public void setDualAddrBearerValue(String dualAddrBearerValue)
            throws JNCException {
        setDualAddrBearerValue(new YangEnumeration(dualAddrBearerValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "dual-addr-bearer".
     */
    public void unsetDualAddrBearerValue() throws JNCException {
        delete("dual-addr-bearer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dual-addr-bearer" leaf will not have a value.
     */
    public void addDualAddrBearer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dual-addr-bearer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dual-addr-bearer" with operation "replace".
     */
    public void markDualAddrBearerReplace() throws JNCException {
        markLeafReplace("dualAddrBearer");
    }

    /**
     * Marks the leaf "dual-addr-bearer" with operation "merge".
     */
    public void markDualAddrBearerMerge() throws JNCException {
        markLeafMerge("dualAddrBearer");
    }

    /**
     * Marks the leaf "dual-addr-bearer" with operation "create".
     */
    public void markDualAddrBearerCreate() throws JNCException {
        markLeafCreate("dualAddrBearer");
    }

    /**
     * Marks the leaf "dual-addr-bearer" with operation "delete".
     */
    public void markDualAddrBearerDelete() throws JNCException {
        markLeafDelete("dualAddrBearer");
    }

    /* Access methods for optional leaf child: "pdn-type-preference". */

    /**
     * Gets the value for child leaf "pdn-type-preference".
     * @return The value of the leaf.
     */
    public YangEnumeration getPdnTypePreferenceValue() throws JNCException {
        YangEnumeration pdnTypePreference = (YangEnumeration)getValue("pdn-type-preference");
        if (pdnTypePreference == null) {
            pdnTypePreference = new YangEnumeration("ipv4", new String[] {  // default
                "ipv4",
                "ipv6",
            });
        }
        return pdnTypePreference;
    }

    /**
     * Sets the value for child leaf "pdn-type-preference",
     * using instance of generated typedef class.
     * @param pdnTypePreferenceValue The value to set.
     * @param pdnTypePreferenceValue used during instantiation.
     */
    public void setPdnTypePreferenceValue(YangEnumeration pdnTypePreferenceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pdn-type-preference",
            pdnTypePreferenceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "pdn-type-preference",
     * using a String value.
     * @param pdnTypePreferenceValue used during instantiation.
     */
    public void setPdnTypePreferenceValue(String pdnTypePreferenceValue)
            throws JNCException {
        setPdnTypePreferenceValue(new YangEnumeration(pdnTypePreferenceValue, new String[] {
             "ipv4",
             "ipv6",
        }));
    }

    /**
     * Unsets the value for child leaf "pdn-type-preference".
     */
    public void unsetPdnTypePreferenceValue() throws JNCException {
        delete("pdn-type-preference");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "pdn-type-preference" leaf will not have a value.
     */
    public void addPdnTypePreference() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pdn-type-preference",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "pdn-type-preference" with operation "replace".
     */
    public void markPdnTypePreferenceReplace() throws JNCException {
        markLeafReplace("pdnTypePreference");
    }

    /**
     * Marks the leaf "pdn-type-preference" with operation "merge".
     */
    public void markPdnTypePreferenceMerge() throws JNCException {
        markLeafMerge("pdnTypePreference");
    }

    /**
     * Marks the leaf "pdn-type-preference" with operation "create".
     */
    public void markPdnTypePreferenceCreate() throws JNCException {
        markLeafCreate("pdnTypePreference");
    }

    /**
     * Marks the leaf "pdn-type-preference" with operation "delete".
     */
    public void markPdnTypePreferenceDelete() throws JNCException {
        markLeafDelete("pdnTypePreference");
    }

    /* Access methods for optional leaf child: "full-network-name". */

    /**
     * Gets the value for child leaf "full-network-name".
     * @return The value of the leaf.
     */
    public YangString getFullNetworkNameValue() throws JNCException {
        YangString fullNetworkName = (YangString)getValue("full-network-name");
        if (fullNetworkName == null) {
            fullNetworkName = new YangString("3gppnetwork");  // default
        }
        return fullNetworkName;
    }

    /**
     * Sets the value for child leaf "full-network-name",
     * using instance of generated typedef class.
     * @param fullNetworkNameValue The value to set.
     * @param fullNetworkNameValue used during instantiation.
     */
    public void setFullNetworkNameValue(YangString fullNetworkNameValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "full-network-name",
            fullNetworkNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "full-network-name",
     * using a String value.
     * @param fullNetworkNameValue used during instantiation.
     */
    public void setFullNetworkNameValue(String fullNetworkNameValue)
            throws JNCException {
        setFullNetworkNameValue(new YangString(fullNetworkNameValue));
    }

    /**
     * Unsets the value for child leaf "full-network-name".
     */
    public void unsetFullNetworkNameValue() throws JNCException {
        delete("full-network-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "full-network-name" leaf will not have a value.
     */
    public void addFullNetworkName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "full-network-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "full-network-name" with operation "replace".
     */
    public void markFullNetworkNameReplace() throws JNCException {
        markLeafReplace("fullNetworkName");
    }

    /**
     * Marks the leaf "full-network-name" with operation "merge".
     */
    public void markFullNetworkNameMerge() throws JNCException {
        markLeafMerge("fullNetworkName");
    }

    /**
     * Marks the leaf "full-network-name" with operation "create".
     */
    public void markFullNetworkNameCreate() throws JNCException {
        markLeafCreate("fullNetworkName");
    }

    /**
     * Marks the leaf "full-network-name" with operation "delete".
     */
    public void markFullNetworkNameDelete() throws JNCException {
        markLeafDelete("fullNetworkName");
    }

    /* Access methods for optional leaf child: "short-network-name". */

    /**
     * Gets the value for child leaf "short-network-name".
     * @return The value of the leaf.
     */
    public YangString getShortNetworkNameValue() throws JNCException {
        YangString shortNetworkName = (YangString)getValue("short-network-name");
        if (shortNetworkName == null) {
            shortNetworkName = new YangString("3gppnetwork");  // default
        }
        return shortNetworkName;
    }

    /**
     * Sets the value for child leaf "short-network-name",
     * using instance of generated typedef class.
     * @param shortNetworkNameValue The value to set.
     * @param shortNetworkNameValue used during instantiation.
     */
    public void setShortNetworkNameValue(YangString shortNetworkNameValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "short-network-name",
            shortNetworkNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "short-network-name",
     * using a String value.
     * @param shortNetworkNameValue used during instantiation.
     */
    public void setShortNetworkNameValue(String shortNetworkNameValue)
            throws JNCException {
        setShortNetworkNameValue(new YangString(shortNetworkNameValue));
    }

    /**
     * Unsets the value for child leaf "short-network-name".
     */
    public void unsetShortNetworkNameValue() throws JNCException {
        delete("short-network-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "short-network-name" leaf will not have a value.
     */
    public void addShortNetworkName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "short-network-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "short-network-name" with operation "replace".
     */
    public void markShortNetworkNameReplace() throws JNCException {
        markLeafReplace("shortNetworkName");
    }

    /**
     * Marks the leaf "short-network-name" with operation "merge".
     */
    public void markShortNetworkNameMerge() throws JNCException {
        markLeafMerge("shortNetworkName");
    }

    /**
     * Marks the leaf "short-network-name" with operation "create".
     */
    public void markShortNetworkNameCreate() throws JNCException {
        markLeafCreate("shortNetworkName");
    }

    /**
     * Marks the leaf "short-network-name" with operation "delete".
     */
    public void markShortNetworkNameDelete() throws JNCException {
        markLeafDelete("shortNetworkName");
    }

    /* Access methods for optional leaf child: "mm-info-triggers". */

    /**
     * Gets the value for child leaf "mm-info-triggers".
     * @return The value of the leaf.
     */
    public YangString getMmInfoTriggersValue() throws JNCException {
        YangString mmInfoTriggers = (YangString)getValue("mm-info-triggers");
        if (mmInfoTriggers == null) {
            mmInfoTriggers = new YangString("none");  // default
        }
        return mmInfoTriggers;
    }

    /**
     * Sets the value for child leaf "mm-info-triggers",
     * using instance of generated typedef class.
     * @param mmInfoTriggersValue The value to set.
     * @param mmInfoTriggersValue used during instantiation.
     */
    public void setMmInfoTriggersValue(YangString mmInfoTriggersValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-info-triggers",
            mmInfoTriggersValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mm-info-triggers",
     * using a String value.
     * @param mmInfoTriggersValue used during instantiation.
     */
    public void setMmInfoTriggersValue(String mmInfoTriggersValue)
            throws JNCException {
        setMmInfoTriggersValue(new YangString(mmInfoTriggersValue));
    }

    /**
     * Unsets the value for child leaf "mm-info-triggers".
     */
    public void unsetMmInfoTriggersValue() throws JNCException {
        delete("mm-info-triggers");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mm-info-triggers" leaf will not have a value.
     */
    public void addMmInfoTriggers() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-info-triggers",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mm-info-triggers" with operation "replace".
     */
    public void markMmInfoTriggersReplace() throws JNCException {
        markLeafReplace("mmInfoTriggers");
    }

    /**
     * Marks the leaf "mm-info-triggers" with operation "merge".
     */
    public void markMmInfoTriggersMerge() throws JNCException {
        markLeafMerge("mmInfoTriggers");
    }

    /**
     * Marks the leaf "mm-info-triggers" with operation "create".
     */
    public void markMmInfoTriggersCreate() throws JNCException {
        markLeafCreate("mmInfoTriggers");
    }

    /**
     * Marks the leaf "mm-info-triggers" with operation "delete".
     */
    public void markMmInfoTriggersDelete() throws JNCException {
        markLeafDelete("mmInfoTriggers");
    }

    /* Access methods for optional leaf child: "mm-info-lifetime". */

    /**
     * Gets the value for child leaf "mm-info-lifetime".
     * @return The value of the leaf.
     */
    public YangString getMmInfoLifetimeValue() throws JNCException {
        YangString mmInfoLifetime = (YangString)getValue("mm-info-lifetime");
        if (mmInfoLifetime == null) {
            mmInfoLifetime = new YangString("disable");  // default
        }
        return mmInfoLifetime;
    }

    /**
     * Sets the value for child leaf "mm-info-lifetime",
     * using instance of generated typedef class.
     * @param mmInfoLifetimeValue The value to set.
     * @param mmInfoLifetimeValue used during instantiation.
     */
    public void setMmInfoLifetimeValue(YangString mmInfoLifetimeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-info-lifetime",
            mmInfoLifetimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "mm-info-lifetime",
     * using a String value.
     * @param mmInfoLifetimeValue used during instantiation.
     */
    public void setMmInfoLifetimeValue(String mmInfoLifetimeValue)
            throws JNCException {
        setMmInfoLifetimeValue(new YangString(mmInfoLifetimeValue));
    }

    /**
     * Unsets the value for child leaf "mm-info-lifetime".
     */
    public void unsetMmInfoLifetimeValue() throws JNCException {
        delete("mm-info-lifetime");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "mm-info-lifetime" leaf will not have a value.
     */
    public void addMmInfoLifetime() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "mm-info-lifetime",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "mm-info-lifetime" with operation "replace".
     */
    public void markMmInfoLifetimeReplace() throws JNCException {
        markLeafReplace("mmInfoLifetime");
    }

    /**
     * Marks the leaf "mm-info-lifetime" with operation "merge".
     */
    public void markMmInfoLifetimeMerge() throws JNCException {
        markLeafMerge("mmInfoLifetime");
    }

    /**
     * Marks the leaf "mm-info-lifetime" with operation "create".
     */
    public void markMmInfoLifetimeCreate() throws JNCException {
        markLeafCreate("mmInfoLifetime");
    }

    /**
     * Marks the leaf "mm-info-lifetime" with operation "delete".
     */
    public void markMmInfoLifetimeDelete() throws JNCException {
        markLeafDelete("mmInfoLifetime");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10.10.0", new String[] {  // default
                "9.5.0",
                "10.10.0",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "9.5.0",
             "10.10.0",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /* Access methods for optional leaf child: "use-pgwid-from-hss". */

    /**
     * Gets the value for child leaf "use-pgwid-from-hss".
     * @return The value of the leaf.
     */
    public YangEnumeration getUsePgwidFromHssValue() throws JNCException {
        YangEnumeration usePgwidFromHss = (YangEnumeration)getValue("use-pgwid-from-hss");
        if (usePgwidFromHss == null) {
            usePgwidFromHss = new YangEnumeration("enable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return usePgwidFromHss;
    }

    /**
     * Sets the value for child leaf "use-pgwid-from-hss",
     * using instance of generated typedef class.
     * @param usePgwidFromHssValue The value to set.
     * @param usePgwidFromHssValue used during instantiation.
     */
    public void setUsePgwidFromHssValue(YangEnumeration usePgwidFromHssValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "use-pgwid-from-hss",
            usePgwidFromHssValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "use-pgwid-from-hss",
     * using a String value.
     * @param usePgwidFromHssValue used during instantiation.
     */
    public void setUsePgwidFromHssValue(String usePgwidFromHssValue)
            throws JNCException {
        setUsePgwidFromHssValue(new YangEnumeration(usePgwidFromHssValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "use-pgwid-from-hss".
     */
    public void unsetUsePgwidFromHssValue() throws JNCException {
        delete("use-pgwid-from-hss");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "use-pgwid-from-hss" leaf will not have a value.
     */
    public void addUsePgwidFromHss() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "use-pgwid-from-hss",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "use-pgwid-from-hss" with operation "replace".
     */
    public void markUsePgwidFromHssReplace() throws JNCException {
        markLeafReplace("usePgwidFromHss");
    }

    /**
     * Marks the leaf "use-pgwid-from-hss" with operation "merge".
     */
    public void markUsePgwidFromHssMerge() throws JNCException {
        markLeafMerge("usePgwidFromHss");
    }

    /**
     * Marks the leaf "use-pgwid-from-hss" with operation "create".
     */
    public void markUsePgwidFromHssCreate() throws JNCException {
        markLeafCreate("usePgwidFromHss");
    }

    /**
     * Marks the leaf "use-pgwid-from-hss" with operation "delete".
     */
    public void markUsePgwidFromHssDelete() throws JNCException {
        markLeafDelete("usePgwidFromHss");
    }

    /* Access methods for optional leaf child: "gw-reselection-retries". */

    /**
     * Gets the value for child leaf "gw-reselection-retries".
     * @return The value of the leaf.
     */
    public YangUInt8 getGwReselectionRetriesValue() throws JNCException {
        YangUInt8 gwReselectionRetries = (YangUInt8)getValue("gw-reselection-retries");
        if (gwReselectionRetries == null) {
            gwReselectionRetries = new YangUInt8("2");  // default
        }
        return gwReselectionRetries;
    }

    /**
     * Sets the value for child leaf "gw-reselection-retries",
     * using instance of generated typedef class.
     * @param gwReselectionRetriesValue The value to set.
     * @param gwReselectionRetriesValue used during instantiation.
     */
    public void setGwReselectionRetriesValue(YangUInt8 gwReselectionRetriesValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "gw-reselection-retries",
            gwReselectionRetriesValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "gw-reselection-retries",
     * using Java primitive values.
     * @param gwReselectionRetriesValue used during instantiation.
     */
    public void setGwReselectionRetriesValue(short gwReselectionRetriesValue)
            throws JNCException {
        setGwReselectionRetriesValue(new YangUInt8(gwReselectionRetriesValue));
    }

    /**
     * Sets the value for child leaf "gw-reselection-retries",
     * using a String value.
     * @param gwReselectionRetriesValue used during instantiation.
     */
    public void setGwReselectionRetriesValue(String gwReselectionRetriesValue)
            throws JNCException {
        setGwReselectionRetriesValue(new YangUInt8(gwReselectionRetriesValue));
    }

    /**
     * Unsets the value for child leaf "gw-reselection-retries".
     */
    public void unsetGwReselectionRetriesValue() throws JNCException {
        delete("gw-reselection-retries");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "gw-reselection-retries" leaf will not have a value.
     */
    public void addGwReselectionRetries() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "gw-reselection-retries",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "gw-reselection-retries" with operation "replace".
     */
    public void markGwReselectionRetriesReplace() throws JNCException {
        markLeafReplace("gwReselectionRetries");
    }

    /**
     * Marks the leaf "gw-reselection-retries" with operation "merge".
     */
    public void markGwReselectionRetriesMerge() throws JNCException {
        markLeafMerge("gwReselectionRetries");
    }

    /**
     * Marks the leaf "gw-reselection-retries" with operation "create".
     */
    public void markGwReselectionRetriesCreate() throws JNCException {
        markLeafCreate("gwReselectionRetries");
    }

    /**
     * Marks the leaf "gw-reselection-retries" with operation "delete".
     */
    public void markGwReselectionRetriesDelete() throws JNCException {
        markLeafDelete("gwReselectionRetries");
    }

    /* Access methods for optional leaf child: "native-mme-groups". */

    /**
     * Gets the value for child leaf "native-mme-groups".
     * @return The value of the leaf.
     */
    public YangEnumeration getNativeMmeGroupsValue() throws JNCException {
        YangEnumeration nativeMmeGroups = (YangEnumeration)getValue("native-mme-groups");
        if (nativeMmeGroups == null) {
            nativeMmeGroups = new YangEnumeration("disable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return nativeMmeGroups;
    }

    /**
     * Sets the value for child leaf "native-mme-groups",
     * using instance of generated typedef class.
     * @param nativeMmeGroupsValue The value to set.
     * @param nativeMmeGroupsValue used during instantiation.
     */
    public void setNativeMmeGroupsValue(YangEnumeration nativeMmeGroupsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "native-mme-groups",
            nativeMmeGroupsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "native-mme-groups",
     * using a String value.
     * @param nativeMmeGroupsValue used during instantiation.
     */
    public void setNativeMmeGroupsValue(String nativeMmeGroupsValue)
            throws JNCException {
        setNativeMmeGroupsValue(new YangEnumeration(nativeMmeGroupsValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "native-mme-groups".
     */
    public void unsetNativeMmeGroupsValue() throws JNCException {
        delete("native-mme-groups");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "native-mme-groups" leaf will not have a value.
     */
    public void addNativeMmeGroups() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "native-mme-groups",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "native-mme-groups" with operation "replace".
     */
    public void markNativeMmeGroupsReplace() throws JNCException {
        markLeafReplace("nativeMmeGroups");
    }

    /**
     * Marks the leaf "native-mme-groups" with operation "merge".
     */
    public void markNativeMmeGroupsMerge() throws JNCException {
        markLeafMerge("nativeMmeGroups");
    }

    /**
     * Marks the leaf "native-mme-groups" with operation "create".
     */
    public void markNativeMmeGroupsCreate() throws JNCException {
        markLeafCreate("nativeMmeGroups");
    }

    /**
     * Marks the leaf "native-mme-groups" with operation "delete".
     */
    public void markNativeMmeGroupsDelete() throws JNCException {
        markLeafDelete("nativeMmeGroups");
    }

    /* Access methods for optional leaf child: "non-broadcast-tai". */

    /**
     * Gets the value for child leaf "non-broadcast-tai".
     * @return The value of the leaf.
     */
    public YangString getNonBroadcastTaiValue() throws JNCException {
        YangString nonBroadcastTai = (YangString)getValue("non-broadcast-tai");
        if (nonBroadcastTai == null) {
            nonBroadcastTai = new YangString("none");  // default
        }
        return nonBroadcastTai;
    }

    /**
     * Sets the value for child leaf "non-broadcast-tai",
     * using instance of generated typedef class.
     * @param nonBroadcastTaiValue The value to set.
     * @param nonBroadcastTaiValue used during instantiation.
     */
    public void setNonBroadcastTaiValue(YangString nonBroadcastTaiValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "non-broadcast-tai",
            nonBroadcastTaiValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "non-broadcast-tai",
     * using a String value.
     * @param nonBroadcastTaiValue used during instantiation.
     */
    public void setNonBroadcastTaiValue(String nonBroadcastTaiValue)
            throws JNCException {
        setNonBroadcastTaiValue(new YangString(nonBroadcastTaiValue));
    }

    /**
     * Unsets the value for child leaf "non-broadcast-tai".
     */
    public void unsetNonBroadcastTaiValue() throws JNCException {
        delete("non-broadcast-tai");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "non-broadcast-tai" leaf will not have a value.
     */
    public void addNonBroadcastTai() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "non-broadcast-tai",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "non-broadcast-tai" with operation "replace".
     */
    public void markNonBroadcastTaiReplace() throws JNCException {
        markLeafReplace("nonBroadcastTai");
    }

    /**
     * Marks the leaf "non-broadcast-tai" with operation "merge".
     */
    public void markNonBroadcastTaiMerge() throws JNCException {
        markLeafMerge("nonBroadcastTai");
    }

    /**
     * Marks the leaf "non-broadcast-tai" with operation "create".
     */
    public void markNonBroadcastTaiCreate() throws JNCException {
        markLeafCreate("nonBroadcastTai");
    }

    /**
     * Marks the leaf "non-broadcast-tai" with operation "delete".
     */
    public void markNonBroadcastTaiDelete() throws JNCException {
        markLeafDelete("nonBroadcastTai");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
