/* 
 * @(#)MmeGgsn.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.gn;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import Leaf;

import com.tailf.jnc.YangBoolean;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/gn/mme-ggsn"
 * <p>
 * See line 1065 in
 * sgsnScConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeGgsn extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeGgsn object.
     */
    public MmeGgsn() {
        super(Epc.NAMESPACE, "mme-ggsn");
    }

    /**
     * Constructor for an initialized MmeGgsn object,
     * 
     * @param ipAddressValue Key argument of child.
     */
    public MmeGgsn(IpAddress ipAddressValue) throws JNCException {
        super(Epc.NAMESPACE, "mme-ggsn");
        Leaf ipAddress = new Leaf(Epc.NAMESPACE, "ip-address");
        ipAddress.setValue(ipAddressValue);
        insertChild(ipAddress, childrenNames());
    }

    /**
     * Constructor for an initialized MmeGgsn object,
     * with String keys.
     * @param ipAddressValue Key argument of child.
     */
    public MmeGgsn(String ipAddressValue) throws JNCException {
        super(Epc.NAMESPACE, "mme-ggsn");
        Leaf ipAddress = new Leaf(Epc.NAMESPACE, "ip-address");
        ipAddress.setValue(new IpAddress(ipAddressValue));
        insertChild(ipAddress, childrenNames());
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeGgsn clone() {
        MmeGgsn copy;
        try {
            copy = new MmeGgsn(getIpAddressValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (MmeGgsn)cloneContent(copy);
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeGgsn cloneShallow() {
        MmeGgsn copy;
        try {
            copy = new MmeGgsn(getIpAddressValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (MmeGgsn)cloneShallowContent(copy);
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return new String[] {
            "ip-address",
        };
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "ip-address",
            "ggsn-name",
            "direct-tunnel",
            "blacklisted",
        };
    }

    /* Access methods for leaf child: "ip-address". */

    /**
     * Gets the value for child leaf "ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getIpAddressValue() throws JNCException {
        return (IpAddress)getValue("ip-address");
    }

    /**
     * Sets the value for child leaf "ip-address",
     * using a JNC type value.
     * @param ipAddressValue The value to set.
     * @param ipAddressValue used during instantiation.
     */
    public void setIpAddressValue(IpAddress ipAddressValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address",
            ipAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address",
     * using a String value.
     * @param ipAddressValue used during instantiation.
     */
    public void setIpAddressValue(String ipAddressValue) throws JNCException {
        setIpAddressValue(new IpAddress(ipAddressValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address" leaf will not have a value.
     */
    public void addIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "ggsn-name". */

    /**
     * Gets the value for child leaf "ggsn-name".
     * @return The value of the leaf.
     */
    public YangString getGgsnNameValue() throws JNCException {
        return (YangString)getValue("ggsn-name");
    }

    /**
     * Sets the value for child leaf "ggsn-name",
     * using instance of generated typedef class.
     * @param ggsnNameValue The value to set.
     * @param ggsnNameValue used during instantiation.
     */
    public void setGgsnNameValue(YangString ggsnNameValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ggsn-name",
            ggsnNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ggsn-name",
     * using a String value.
     * @param ggsnNameValue used during instantiation.
     */
    public void setGgsnNameValue(String ggsnNameValue) throws JNCException {
        setGgsnNameValue(new YangString(ggsnNameValue));
    }

    /**
     * Unsets the value for child leaf "ggsn-name".
     */
    public void unsetGgsnNameValue() throws JNCException {
        delete("ggsn-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ggsn-name" leaf will not have a value.
     */
    public void addGgsnName() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ggsn-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ggsn-name" with operation "replace".
     */
    public void markGgsnNameReplace() throws JNCException {
        markLeafReplace("ggsnName");
    }

    /**
     * Marks the leaf "ggsn-name" with operation "merge".
     */
    public void markGgsnNameMerge() throws JNCException {
        markLeafMerge("ggsnName");
    }

    /**
     * Marks the leaf "ggsn-name" with operation "create".
     */
    public void markGgsnNameCreate() throws JNCException {
        markLeafCreate("ggsnName");
    }

    /**
     * Marks the leaf "ggsn-name" with operation "delete".
     */
    public void markGgsnNameDelete() throws JNCException {
        markLeafDelete("ggsnName");
    }

    /* Access methods for optional leaf child: "direct-tunnel". */

    /**
     * Gets the value for child leaf "direct-tunnel".
     * @return The value of the leaf.
     */
    public YangEnumeration getDirectTunnelValue() throws JNCException {
        YangEnumeration directTunnel = (YangEnumeration)getValue("direct-tunnel");
        if (directTunnel == null) {
            directTunnel = new YangEnumeration("disable", new String[] {  // default
                "enable",
                "disable",
            });
        }
        return directTunnel;
    }

    /**
     * Sets the value for child leaf "direct-tunnel",
     * using instance of generated typedef class.
     * @param directTunnelValue The value to set.
     * @param directTunnelValue used during instantiation.
     */
    public void setDirectTunnelValue(YangEnumeration directTunnelValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "direct-tunnel",
            directTunnelValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "direct-tunnel",
     * using a String value.
     * @param directTunnelValue used during instantiation.
     */
    public void setDirectTunnelValue(String directTunnelValue)
            throws JNCException {
        setDirectTunnelValue(new YangEnumeration(directTunnelValue, new String[] {
             "enable",
             "disable",
        }));
    }

    /**
     * Unsets the value for child leaf "direct-tunnel".
     */
    public void unsetDirectTunnelValue() throws JNCException {
        delete("direct-tunnel");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "direct-tunnel" leaf will not have a value.
     */
    public void addDirectTunnel() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "direct-tunnel",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "direct-tunnel" with operation "replace".
     */
    public void markDirectTunnelReplace() throws JNCException {
        markLeafReplace("directTunnel");
    }

    /**
     * Marks the leaf "direct-tunnel" with operation "merge".
     */
    public void markDirectTunnelMerge() throws JNCException {
        markLeafMerge("directTunnel");
    }

    /**
     * Marks the leaf "direct-tunnel" with operation "create".
     */
    public void markDirectTunnelCreate() throws JNCException {
        markLeafCreate("directTunnel");
    }

    /**
     * Marks the leaf "direct-tunnel" with operation "delete".
     */
    public void markDirectTunnelDelete() throws JNCException {
        markLeafDelete("directTunnel");
    }

    /* Access methods for optional leaf child: "blacklisted". */

    /**
     * Gets the value for child leaf "blacklisted".
     * @return The value of the leaf.
     */
    public YangBoolean getBlacklistedValue() throws JNCException {
        YangBoolean blacklisted = (YangBoolean)getValue("blacklisted");
        if (blacklisted == null) {
            blacklisted = new YangBoolean("false");  // default
        }
        return blacklisted;
    }

    /**
     * Sets the value for child leaf "blacklisted",
     * using instance of generated typedef class.
     * @param blacklistedValue The value to set.
     * @param blacklistedValue used during instantiation.
     */
    public void setBlacklistedValue(YangBoolean blacklistedValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "blacklisted",
            blacklistedValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "blacklisted",
     * using Java primitive values.
     * @param blacklistedValue used during instantiation.
     */
    public void setBlacklistedValue(Boolean blacklistedValue)
            throws JNCException {
        setBlacklistedValue(new YangBoolean(blacklistedValue));
    }

    /**
     * Sets the value for child leaf "blacklisted",
     * using a String value.
     * @param blacklistedValue used during instantiation.
     */
    public void setBlacklistedValue(String blacklistedValue)
            throws JNCException {
        setBlacklistedValue(new YangBoolean(blacklistedValue));
    }

    /**
     * Unsets the value for child leaf "blacklisted".
     */
    public void unsetBlacklistedValue() throws JNCException {
        delete("blacklisted");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "blacklisted" leaf will not have a value.
     */
    public void addBlacklisted() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "blacklisted",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "blacklisted" with operation "replace".
     */
    public void markBlacklistedReplace() throws JNCException {
        markLeafReplace("blacklisted");
    }

    /**
     * Marks the leaf "blacklisted" with operation "merge".
     */
    public void markBlacklistedMerge() throws JNCException {
        markLeafMerge("blacklisted");
    }

    /**
     * Marks the leaf "blacklisted" with operation "create".
     */
    public void markBlacklistedCreate() throws JNCException {
        markLeafCreate("blacklisted");
    }

    /**
     * Marks the leaf "blacklisted" with operation "delete".
     */
    public void markBlacklistedDelete() throws JNCException {
        markLeafDelete("blacklisted");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
