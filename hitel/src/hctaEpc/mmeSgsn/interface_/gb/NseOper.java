/* 
 * @(#)NseOper.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.gb;
import .ietfInetTypes.IpAddress;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;
import com.tailf.jnc.YangUInt32;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/gb/nse-oper"
 * <p>
 * See line 786 in
 * gtlCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class NseOper extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty NseOper object.
     */
    public NseOper() {
        super(Epc.NAMESPACE, "nse-oper");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public NseOper clone() {
        return (NseOper)cloneContent(new NseOper());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public NseOper cloneShallow() {
        return (NseOper)cloneShallowContent(new NseOper());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "nse-id",
            "transport-type",
            "service",
            "ip-address",
            "port",
            "location",
            "oper-state",
            "sns-state",
            "current-total-sig-nsvcs",
            "current-avail-sig-nsvcs",
            "current-total-data-nsvcs",
            "current-avail-data-nsvcs",
            "current-ptp-bvcs",
            "nsvl-group",
            "nsvl",
            "pid",
        };
    }

    /* Access methods for optional leaf child: "nse-id". */

    /**
     * Gets the value for child leaf "nse-id".
     * @return The value of the leaf.
     */
    public YangUInt16 getNseIdValue() throws JNCException {
        return (YangUInt16)getValue("nse-id");
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using instance of generated typedef class.
     * @param nseIdValue The value to set.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(YangUInt16 nseIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nse-id",
            nseIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using Java primitive values.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(int nseIdValue) throws JNCException {
        setNseIdValue(new YangUInt16(nseIdValue));
    }

    /**
     * Sets the value for child leaf "nse-id",
     * using a String value.
     * @param nseIdValue used during instantiation.
     */
    public void setNseIdValue(String nseIdValue) throws JNCException {
        setNseIdValue(new YangUInt16(nseIdValue));
    }

    /**
     * Unsets the value for child leaf "nse-id".
     */
    public void unsetNseIdValue() throws JNCException {
        delete("nse-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nse-id" leaf will not have a value.
     */
    public void addNseId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nse-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nse-id" with operation "replace".
     */
    public void markNseIdReplace() throws JNCException {
        markLeafReplace("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "merge".
     */
    public void markNseIdMerge() throws JNCException {
        markLeafMerge("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "create".
     */
    public void markNseIdCreate() throws JNCException {
        markLeafCreate("nseId");
    }

    /**
     * Marks the leaf "nse-id" with operation "delete".
     */
    public void markNseIdDelete() throws JNCException {
        markLeafDelete("nseId");
    }

    /* Access methods for optional leaf child: "transport-type". */

    /**
     * Gets the value for child leaf "transport-type".
     * @return The value of the leaf.
     */
    public YangString getTransportTypeValue() throws JNCException {
        return (YangString)getValue("transport-type");
    }

    /**
     * Sets the value for child leaf "transport-type",
     * using instance of generated typedef class.
     * @param transportTypeValue The value to set.
     * @param transportTypeValue used during instantiation.
     */
    public void setTransportTypeValue(YangString transportTypeValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "transport-type",
            transportTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "transport-type",
     * using a String value.
     * @param transportTypeValue used during instantiation.
     */
    public void setTransportTypeValue(String transportTypeValue)
            throws JNCException {
        setTransportTypeValue(new YangString(transportTypeValue));
    }

    /**
     * Unsets the value for child leaf "transport-type".
     */
    public void unsetTransportTypeValue() throws JNCException {
        delete("transport-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "transport-type" leaf will not have a value.
     */
    public void addTransportType() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "transport-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "transport-type" with operation "replace".
     */
    public void markTransportTypeReplace() throws JNCException {
        markLeafReplace("transportType");
    }

    /**
     * Marks the leaf "transport-type" with operation "merge".
     */
    public void markTransportTypeMerge() throws JNCException {
        markLeafMerge("transportType");
    }

    /**
     * Marks the leaf "transport-type" with operation "create".
     */
    public void markTransportTypeCreate() throws JNCException {
        markLeafCreate("transportType");
    }

    /**
     * Marks the leaf "transport-type" with operation "delete".
     */
    public void markTransportTypeDelete() throws JNCException {
        markLeafDelete("transportType");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "ip-address". */

    /**
     * Gets the value for child leaf "ip-address".
     * @return The value of the leaf.
     */
    public IpAddress getIpAddressValue() throws JNCException {
        return (IpAddress)getValue("ip-address");
    }

    /**
     * Sets the value for child leaf "ip-address",
     * using a JNC type value.
     * @param ipAddressValue The value to set.
     * @param ipAddressValue used during instantiation.
     */
    public void setIpAddressValue(IpAddress ipAddressValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address",
            ipAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip-address",
     * using a String value.
     * @param ipAddressValue used during instantiation.
     */
    public void setIpAddressValue(String ipAddressValue) throws JNCException {
        setIpAddressValue(new IpAddress(ipAddressValue));
    }

    /**
     * Unsets the value for child leaf "ip-address".
     */
    public void unsetIpAddressValue() throws JNCException {
        delete("ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip-address" leaf will not have a value.
     */
    public void addIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip-address" with operation "replace".
     */
    public void markIpAddressReplace() throws JNCException {
        markLeafReplace("ipAddress");
    }

    /**
     * Marks the leaf "ip-address" with operation "merge".
     */
    public void markIpAddressMerge() throws JNCException {
        markLeafMerge("ipAddress");
    }

    /**
     * Marks the leaf "ip-address" with operation "create".
     */
    public void markIpAddressCreate() throws JNCException {
        markLeafCreate("ipAddress");
    }

    /**
     * Marks the leaf "ip-address" with operation "delete".
     */
    public void markIpAddressDelete() throws JNCException {
        markLeafDelete("ipAddress");
    }

    /* Access methods for optional leaf child: "port". */

    /**
     * Gets the value for child leaf "port".
     * @return The value of the leaf.
     */
    public YangUInt16 getPortValue() throws JNCException {
        return (YangUInt16)getValue("port");
    }

    /**
     * Sets the value for child leaf "port",
     * using instance of generated typedef class.
     * @param portValue The value to set.
     * @param portValue used during instantiation.
     */
    public void setPortValue(YangUInt16 portValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            portValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "port",
     * using Java primitive values.
     * @param portValue used during instantiation.
     */
    public void setPortValue(int portValue) throws JNCException {
        setPortValue(new YangUInt16(portValue));
    }

    /**
     * Sets the value for child leaf "port",
     * using a String value.
     * @param portValue used during instantiation.
     */
    public void setPortValue(String portValue) throws JNCException {
        setPortValue(new YangUInt16(portValue));
    }

    /**
     * Unsets the value for child leaf "port".
     */
    public void unsetPortValue() throws JNCException {
        delete("port");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "port" leaf will not have a value.
     */
    public void addPort() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "port",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "port" with operation "replace".
     */
    public void markPortReplace() throws JNCException {
        markLeafReplace("port");
    }

    /**
     * Marks the leaf "port" with operation "merge".
     */
    public void markPortMerge() throws JNCException {
        markLeafMerge("port");
    }

    /**
     * Marks the leaf "port" with operation "create".
     */
    public void markPortCreate() throws JNCException {
        markLeafCreate("port");
    }

    /**
     * Marks the leaf "port" with operation "delete".
     */
    public void markPortDelete() throws JNCException {
        markLeafDelete("port");
    }

    /* Access methods for optional leaf child: "location". */

    /**
     * Gets the value for child leaf "location".
     * @return The value of the leaf.
     */
    public YangString getLocationValue() throws JNCException {
        return (YangString)getValue("location");
    }

    /**
     * Sets the value for child leaf "location",
     * using instance of generated typedef class.
     * @param locationValue The value to set.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(YangString locationValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            locationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location",
     * using a String value.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(String locationValue) throws JNCException {
        setLocationValue(new YangString(locationValue));
    }

    /**
     * Unsets the value for child leaf "location".
     */
    public void unsetLocationValue() throws JNCException {
        delete("location");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location" leaf will not have a value.
     */
    public void addLocation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location" with operation "replace".
     */
    public void markLocationReplace() throws JNCException {
        markLeafReplace("location");
    }

    /**
     * Marks the leaf "location" with operation "merge".
     */
    public void markLocationMerge() throws JNCException {
        markLeafMerge("location");
    }

    /**
     * Marks the leaf "location" with operation "create".
     */
    public void markLocationCreate() throws JNCException {
        markLeafCreate("location");
    }

    /**
     * Marks the leaf "location" with operation "delete".
     */
    public void markLocationDelete() throws JNCException {
        markLeafDelete("location");
    }

    /* Access methods for optional leaf child: "oper-state". */

    /**
     * Gets the value for child leaf "oper-state".
     * @return The value of the leaf.
     */
    public YangString getOperStateValue() throws JNCException {
        return (YangString)getValue("oper-state");
    }

    /**
     * Sets the value for child leaf "oper-state",
     * using instance of generated typedef class.
     * @param operStateValue The value to set.
     * @param operStateValue used during instantiation.
     */
    public void setOperStateValue(YangString operStateValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "oper-state",
            operStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "oper-state",
     * using a String value.
     * @param operStateValue used during instantiation.
     */
    public void setOperStateValue(String operStateValue) throws JNCException {
        setOperStateValue(new YangString(operStateValue));
    }

    /**
     * Unsets the value for child leaf "oper-state".
     */
    public void unsetOperStateValue() throws JNCException {
        delete("oper-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "oper-state" leaf will not have a value.
     */
    public void addOperState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "oper-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "oper-state" with operation "replace".
     */
    public void markOperStateReplace() throws JNCException {
        markLeafReplace("operState");
    }

    /**
     * Marks the leaf "oper-state" with operation "merge".
     */
    public void markOperStateMerge() throws JNCException {
        markLeafMerge("operState");
    }

    /**
     * Marks the leaf "oper-state" with operation "create".
     */
    public void markOperStateCreate() throws JNCException {
        markLeafCreate("operState");
    }

    /**
     * Marks the leaf "oper-state" with operation "delete".
     */
    public void markOperStateDelete() throws JNCException {
        markLeafDelete("operState");
    }

    /* Access methods for optional leaf child: "sns-state". */

    /**
     * Gets the value for child leaf "sns-state".
     * @return The value of the leaf.
     */
    public YangString getSnsStateValue() throws JNCException {
        return (YangString)getValue("sns-state");
    }

    /**
     * Sets the value for child leaf "sns-state",
     * using instance of generated typedef class.
     * @param snsStateValue The value to set.
     * @param snsStateValue used during instantiation.
     */
    public void setSnsStateValue(YangString snsStateValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sns-state",
            snsStateValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sns-state",
     * using a String value.
     * @param snsStateValue used during instantiation.
     */
    public void setSnsStateValue(String snsStateValue) throws JNCException {
        setSnsStateValue(new YangString(snsStateValue));
    }

    /**
     * Unsets the value for child leaf "sns-state".
     */
    public void unsetSnsStateValue() throws JNCException {
        delete("sns-state");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sns-state" leaf will not have a value.
     */
    public void addSnsState() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sns-state",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sns-state" with operation "replace".
     */
    public void markSnsStateReplace() throws JNCException {
        markLeafReplace("snsState");
    }

    /**
     * Marks the leaf "sns-state" with operation "merge".
     */
    public void markSnsStateMerge() throws JNCException {
        markLeafMerge("snsState");
    }

    /**
     * Marks the leaf "sns-state" with operation "create".
     */
    public void markSnsStateCreate() throws JNCException {
        markLeafCreate("snsState");
    }

    /**
     * Marks the leaf "sns-state" with operation "delete".
     */
    public void markSnsStateDelete() throws JNCException {
        markLeafDelete("snsState");
    }

    /* Access methods for optional leaf child: "current-total-sig-nsvcs". */

    /**
     * Gets the value for child leaf "current-total-sig-nsvcs".
     * @return The value of the leaf.
     */
    public YangUInt8 getCurrentTotalSigNsvcsValue() throws JNCException {
        return (YangUInt8)getValue("current-total-sig-nsvcs");
    }

    /**
     * Sets the value for child leaf "current-total-sig-nsvcs",
     * using instance of generated typedef class.
     * @param currentTotalSigNsvcsValue The value to set.
     * @param currentTotalSigNsvcsValue used during instantiation.
     */
    public void setCurrentTotalSigNsvcsValue(YangUInt8 currentTotalSigNsvcsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-total-sig-nsvcs",
            currentTotalSigNsvcsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-total-sig-nsvcs",
     * using Java primitive values.
     * @param currentTotalSigNsvcsValue used during instantiation.
     */
    public void setCurrentTotalSigNsvcsValue(short currentTotalSigNsvcsValue)
            throws JNCException {
        setCurrentTotalSigNsvcsValue(new YangUInt8(currentTotalSigNsvcsValue));
    }

    /**
     * Sets the value for child leaf "current-total-sig-nsvcs",
     * using a String value.
     * @param currentTotalSigNsvcsValue used during instantiation.
     */
    public void setCurrentTotalSigNsvcsValue(String currentTotalSigNsvcsValue)
            throws JNCException {
        setCurrentTotalSigNsvcsValue(new YangUInt8(currentTotalSigNsvcsValue));
    }

    /**
     * Unsets the value for child leaf "current-total-sig-nsvcs".
     */
    public void unsetCurrentTotalSigNsvcsValue() throws JNCException {
        delete("current-total-sig-nsvcs");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-total-sig-nsvcs" leaf will not have a value.
     */
    public void addCurrentTotalSigNsvcs() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-total-sig-nsvcs",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-total-sig-nsvcs" with operation "replace".
     */
    public void markCurrentTotalSigNsvcsReplace() throws JNCException {
        markLeafReplace("currentTotalSigNsvcs");
    }

    /**
     * Marks the leaf "current-total-sig-nsvcs" with operation "merge".
     */
    public void markCurrentTotalSigNsvcsMerge() throws JNCException {
        markLeafMerge("currentTotalSigNsvcs");
    }

    /**
     * Marks the leaf "current-total-sig-nsvcs" with operation "create".
     */
    public void markCurrentTotalSigNsvcsCreate() throws JNCException {
        markLeafCreate("currentTotalSigNsvcs");
    }

    /**
     * Marks the leaf "current-total-sig-nsvcs" with operation "delete".
     */
    public void markCurrentTotalSigNsvcsDelete() throws JNCException {
        markLeafDelete("currentTotalSigNsvcs");
    }

    /* Access methods for optional leaf child: "current-avail-sig-nsvcs". */

    /**
     * Gets the value for child leaf "current-avail-sig-nsvcs".
     * @return The value of the leaf.
     */
    public YangUInt8 getCurrentAvailSigNsvcsValue() throws JNCException {
        return (YangUInt8)getValue("current-avail-sig-nsvcs");
    }

    /**
     * Sets the value for child leaf "current-avail-sig-nsvcs",
     * using instance of generated typedef class.
     * @param currentAvailSigNsvcsValue The value to set.
     * @param currentAvailSigNsvcsValue used during instantiation.
     */
    public void setCurrentAvailSigNsvcsValue(YangUInt8 currentAvailSigNsvcsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-avail-sig-nsvcs",
            currentAvailSigNsvcsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-avail-sig-nsvcs",
     * using Java primitive values.
     * @param currentAvailSigNsvcsValue used during instantiation.
     */
    public void setCurrentAvailSigNsvcsValue(short currentAvailSigNsvcsValue)
            throws JNCException {
        setCurrentAvailSigNsvcsValue(new YangUInt8(currentAvailSigNsvcsValue));
    }

    /**
     * Sets the value for child leaf "current-avail-sig-nsvcs",
     * using a String value.
     * @param currentAvailSigNsvcsValue used during instantiation.
     */
    public void setCurrentAvailSigNsvcsValue(String currentAvailSigNsvcsValue)
            throws JNCException {
        setCurrentAvailSigNsvcsValue(new YangUInt8(currentAvailSigNsvcsValue));
    }

    /**
     * Unsets the value for child leaf "current-avail-sig-nsvcs".
     */
    public void unsetCurrentAvailSigNsvcsValue() throws JNCException {
        delete("current-avail-sig-nsvcs");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-avail-sig-nsvcs" leaf will not have a value.
     */
    public void addCurrentAvailSigNsvcs() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-avail-sig-nsvcs",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-avail-sig-nsvcs" with operation "replace".
     */
    public void markCurrentAvailSigNsvcsReplace() throws JNCException {
        markLeafReplace("currentAvailSigNsvcs");
    }

    /**
     * Marks the leaf "current-avail-sig-nsvcs" with operation "merge".
     */
    public void markCurrentAvailSigNsvcsMerge() throws JNCException {
        markLeafMerge("currentAvailSigNsvcs");
    }

    /**
     * Marks the leaf "current-avail-sig-nsvcs" with operation "create".
     */
    public void markCurrentAvailSigNsvcsCreate() throws JNCException {
        markLeafCreate("currentAvailSigNsvcs");
    }

    /**
     * Marks the leaf "current-avail-sig-nsvcs" with operation "delete".
     */
    public void markCurrentAvailSigNsvcsDelete() throws JNCException {
        markLeafDelete("currentAvailSigNsvcs");
    }

    /* Access methods for optional leaf child: "current-total-data-nsvcs". */

    /**
     * Gets the value for child leaf "current-total-data-nsvcs".
     * @return The value of the leaf.
     */
    public YangUInt8 getCurrentTotalDataNsvcsValue() throws JNCException {
        return (YangUInt8)getValue("current-total-data-nsvcs");
    }

    /**
     * Sets the value for child leaf "current-total-data-nsvcs",
     * using instance of generated typedef class.
     * @param currentTotalDataNsvcsValue The value to set.
     * @param currentTotalDataNsvcsValue used during instantiation.
     */
    public void setCurrentTotalDataNsvcsValue(YangUInt8 currentTotalDataNsvcsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-total-data-nsvcs",
            currentTotalDataNsvcsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-total-data-nsvcs",
     * using Java primitive values.
     * @param currentTotalDataNsvcsValue used during instantiation.
     */
    public void setCurrentTotalDataNsvcsValue(short currentTotalDataNsvcsValue)
            throws JNCException {
        setCurrentTotalDataNsvcsValue(new YangUInt8(currentTotalDataNsvcsValue));
    }

    /**
     * Sets the value for child leaf "current-total-data-nsvcs",
     * using a String value.
     * @param currentTotalDataNsvcsValue used during instantiation.
     */
    public void setCurrentTotalDataNsvcsValue(String currentTotalDataNsvcsValue)
            throws JNCException {
        setCurrentTotalDataNsvcsValue(new YangUInt8(currentTotalDataNsvcsValue));
    }

    /**
     * Unsets the value for child leaf "current-total-data-nsvcs".
     */
    public void unsetCurrentTotalDataNsvcsValue() throws JNCException {
        delete("current-total-data-nsvcs");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-total-data-nsvcs" leaf will not have a value.
     */
    public void addCurrentTotalDataNsvcs() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-total-data-nsvcs",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-total-data-nsvcs" with operation "replace".
     */
    public void markCurrentTotalDataNsvcsReplace() throws JNCException {
        markLeafReplace("currentTotalDataNsvcs");
    }

    /**
     * Marks the leaf "current-total-data-nsvcs" with operation "merge".
     */
    public void markCurrentTotalDataNsvcsMerge() throws JNCException {
        markLeafMerge("currentTotalDataNsvcs");
    }

    /**
     * Marks the leaf "current-total-data-nsvcs" with operation "create".
     */
    public void markCurrentTotalDataNsvcsCreate() throws JNCException {
        markLeafCreate("currentTotalDataNsvcs");
    }

    /**
     * Marks the leaf "current-total-data-nsvcs" with operation "delete".
     */
    public void markCurrentTotalDataNsvcsDelete() throws JNCException {
        markLeafDelete("currentTotalDataNsvcs");
    }

    /* Access methods for optional leaf child: "current-avail-data-nsvcs". */

    /**
     * Gets the value for child leaf "current-avail-data-nsvcs".
     * @return The value of the leaf.
     */
    public YangUInt8 getCurrentAvailDataNsvcsValue() throws JNCException {
        return (YangUInt8)getValue("current-avail-data-nsvcs");
    }

    /**
     * Sets the value for child leaf "current-avail-data-nsvcs",
     * using instance of generated typedef class.
     * @param currentAvailDataNsvcsValue The value to set.
     * @param currentAvailDataNsvcsValue used during instantiation.
     */
    public void setCurrentAvailDataNsvcsValue(YangUInt8 currentAvailDataNsvcsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-avail-data-nsvcs",
            currentAvailDataNsvcsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-avail-data-nsvcs",
     * using Java primitive values.
     * @param currentAvailDataNsvcsValue used during instantiation.
     */
    public void setCurrentAvailDataNsvcsValue(short currentAvailDataNsvcsValue)
            throws JNCException {
        setCurrentAvailDataNsvcsValue(new YangUInt8(currentAvailDataNsvcsValue));
    }

    /**
     * Sets the value for child leaf "current-avail-data-nsvcs",
     * using a String value.
     * @param currentAvailDataNsvcsValue used during instantiation.
     */
    public void setCurrentAvailDataNsvcsValue(String currentAvailDataNsvcsValue)
            throws JNCException {
        setCurrentAvailDataNsvcsValue(new YangUInt8(currentAvailDataNsvcsValue));
    }

    /**
     * Unsets the value for child leaf "current-avail-data-nsvcs".
     */
    public void unsetCurrentAvailDataNsvcsValue() throws JNCException {
        delete("current-avail-data-nsvcs");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-avail-data-nsvcs" leaf will not have a value.
     */
    public void addCurrentAvailDataNsvcs() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-avail-data-nsvcs",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-avail-data-nsvcs" with operation "replace".
     */
    public void markCurrentAvailDataNsvcsReplace() throws JNCException {
        markLeafReplace("currentAvailDataNsvcs");
    }

    /**
     * Marks the leaf "current-avail-data-nsvcs" with operation "merge".
     */
    public void markCurrentAvailDataNsvcsMerge() throws JNCException {
        markLeafMerge("currentAvailDataNsvcs");
    }

    /**
     * Marks the leaf "current-avail-data-nsvcs" with operation "create".
     */
    public void markCurrentAvailDataNsvcsCreate() throws JNCException {
        markLeafCreate("currentAvailDataNsvcs");
    }

    /**
     * Marks the leaf "current-avail-data-nsvcs" with operation "delete".
     */
    public void markCurrentAvailDataNsvcsDelete() throws JNCException {
        markLeafDelete("currentAvailDataNsvcs");
    }

    /* Access methods for optional leaf child: "current-ptp-bvcs". */

    /**
     * Gets the value for child leaf "current-ptp-bvcs".
     * @return The value of the leaf.
     */
    public YangUInt32 getCurrentPtpBvcsValue() throws JNCException {
        return (YangUInt32)getValue("current-ptp-bvcs");
    }

    /**
     * Sets the value for child leaf "current-ptp-bvcs",
     * using instance of generated typedef class.
     * @param currentPtpBvcsValue The value to set.
     * @param currentPtpBvcsValue used during instantiation.
     */
    public void setCurrentPtpBvcsValue(YangUInt32 currentPtpBvcsValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-ptp-bvcs",
            currentPtpBvcsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "current-ptp-bvcs",
     * using Java primitive values.
     * @param currentPtpBvcsValue used during instantiation.
     */
    public void setCurrentPtpBvcsValue(long currentPtpBvcsValue)
            throws JNCException {
        setCurrentPtpBvcsValue(new YangUInt32(currentPtpBvcsValue));
    }

    /**
     * Sets the value for child leaf "current-ptp-bvcs",
     * using a String value.
     * @param currentPtpBvcsValue used during instantiation.
     */
    public void setCurrentPtpBvcsValue(String currentPtpBvcsValue)
            throws JNCException {
        setCurrentPtpBvcsValue(new YangUInt32(currentPtpBvcsValue));
    }

    /**
     * Unsets the value for child leaf "current-ptp-bvcs".
     */
    public void unsetCurrentPtpBvcsValue() throws JNCException {
        delete("current-ptp-bvcs");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "current-ptp-bvcs" leaf will not have a value.
     */
    public void addCurrentPtpBvcs() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "current-ptp-bvcs",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "current-ptp-bvcs" with operation "replace".
     */
    public void markCurrentPtpBvcsReplace() throws JNCException {
        markLeafReplace("currentPtpBvcs");
    }

    /**
     * Marks the leaf "current-ptp-bvcs" with operation "merge".
     */
    public void markCurrentPtpBvcsMerge() throws JNCException {
        markLeafMerge("currentPtpBvcs");
    }

    /**
     * Marks the leaf "current-ptp-bvcs" with operation "create".
     */
    public void markCurrentPtpBvcsCreate() throws JNCException {
        markLeafCreate("currentPtpBvcs");
    }

    /**
     * Marks the leaf "current-ptp-bvcs" with operation "delete".
     */
    public void markCurrentPtpBvcsDelete() throws JNCException {
        markLeafDelete("currentPtpBvcs");
    }

    /* Access methods for optional leaf child: "nsvl-group". */

    /**
     * Gets the value for child leaf "nsvl-group".
     * @return The value of the leaf.
     */
    public YangUInt8 getNsvlGroupValue() throws JNCException {
        return (YangUInt8)getValue("nsvl-group");
    }

    /**
     * Sets the value for child leaf "nsvl-group",
     * using instance of generated typedef class.
     * @param nsvlGroupValue The value to set.
     * @param nsvlGroupValue used during instantiation.
     */
    public void setNsvlGroupValue(YangUInt8 nsvlGroupValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nsvl-group",
            nsvlGroupValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nsvl-group",
     * using Java primitive values.
     * @param nsvlGroupValue used during instantiation.
     */
    public void setNsvlGroupValue(short nsvlGroupValue) throws JNCException {
        setNsvlGroupValue(new YangUInt8(nsvlGroupValue));
    }

    /**
     * Sets the value for child leaf "nsvl-group",
     * using a String value.
     * @param nsvlGroupValue used during instantiation.
     */
    public void setNsvlGroupValue(String nsvlGroupValue) throws JNCException {
        setNsvlGroupValue(new YangUInt8(nsvlGroupValue));
    }

    /**
     * Unsets the value for child leaf "nsvl-group".
     */
    public void unsetNsvlGroupValue() throws JNCException {
        delete("nsvl-group");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nsvl-group" leaf will not have a value.
     */
    public void addNsvlGroup() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nsvl-group",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nsvl-group" with operation "replace".
     */
    public void markNsvlGroupReplace() throws JNCException {
        markLeafReplace("nsvlGroup");
    }

    /**
     * Marks the leaf "nsvl-group" with operation "merge".
     */
    public void markNsvlGroupMerge() throws JNCException {
        markLeafMerge("nsvlGroup");
    }

    /**
     * Marks the leaf "nsvl-group" with operation "create".
     */
    public void markNsvlGroupCreate() throws JNCException {
        markLeafCreate("nsvlGroup");
    }

    /**
     * Marks the leaf "nsvl-group" with operation "delete".
     */
    public void markNsvlGroupDelete() throws JNCException {
        markLeafDelete("nsvlGroup");
    }

    /* Access methods for optional leaf child: "nsvl". */

    /**
     * Gets the value for child leaf "nsvl".
     * @return The value of the leaf.
     */
    public YangUInt8 getNsvlValue() throws JNCException {
        return (YangUInt8)getValue("nsvl");
    }

    /**
     * Sets the value for child leaf "nsvl",
     * using instance of generated typedef class.
     * @param nsvlValue The value to set.
     * @param nsvlValue used during instantiation.
     */
    public void setNsvlValue(YangUInt8 nsvlValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nsvl",
            nsvlValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "nsvl",
     * using Java primitive values.
     * @param nsvlValue used during instantiation.
     */
    public void setNsvlValue(short nsvlValue) throws JNCException {
        setNsvlValue(new YangUInt8(nsvlValue));
    }

    /**
     * Sets the value for child leaf "nsvl",
     * using a String value.
     * @param nsvlValue used during instantiation.
     */
    public void setNsvlValue(String nsvlValue) throws JNCException {
        setNsvlValue(new YangUInt8(nsvlValue));
    }

    /**
     * Unsets the value for child leaf "nsvl".
     */
    public void unsetNsvlValue() throws JNCException {
        delete("nsvl");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "nsvl" leaf will not have a value.
     */
    public void addNsvl() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "nsvl",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "nsvl" with operation "replace".
     */
    public void markNsvlReplace() throws JNCException {
        markLeafReplace("nsvl");
    }

    /**
     * Marks the leaf "nsvl" with operation "merge".
     */
    public void markNsvlMerge() throws JNCException {
        markLeafMerge("nsvl");
    }

    /**
     * Marks the leaf "nsvl" with operation "create".
     */
    public void markNsvlCreate() throws JNCException {
        markLeafCreate("nsvl");
    }

    /**
     * Marks the leaf "nsvl" with operation "delete".
     */
    public void markNsvlDelete() throws JNCException {
        markLeafDelete("nsvl");
    }

    /* Access methods for optional leaf child: "pid". */

    /**
     * Gets the value for child leaf "pid".
     * @return The value of the leaf.
     */
    public YangUInt16 getPidValue() throws JNCException {
        return (YangUInt16)getValue("pid");
    }

    /**
     * Sets the value for child leaf "pid",
     * using instance of generated typedef class.
     * @param pidValue The value to set.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(YangUInt16 pidValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pid",
            pidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "pid",
     * using Java primitive values.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(int pidValue) throws JNCException {
        setPidValue(new YangUInt16(pidValue));
    }

    /**
     * Sets the value for child leaf "pid",
     * using a String value.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(String pidValue) throws JNCException {
        setPidValue(new YangUInt16(pidValue));
    }

    /**
     * Unsets the value for child leaf "pid".
     */
    public void unsetPidValue() throws JNCException {
        delete("pid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "pid" leaf will not have a value.
     */
    public void addPid() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "pid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "pid" with operation "replace".
     */
    public void markPidReplace() throws JNCException {
        markLeafReplace("pid");
    }

    /**
     * Marks the leaf "pid" with operation "merge".
     */
    public void markPidMerge() throws JNCException {
        markLeafMerge("pid");
    }

    /**
     * Marks the leaf "pid" with operation "create".
     */
    public void markPidCreate() throws JNCException {
        markLeafCreate("pid");
    }

    /**
     * Marks the leaf "pid" with operation "delete".
     */
    public void markPidDelete() throws JNCException {
        markLeafDelete("pid");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
