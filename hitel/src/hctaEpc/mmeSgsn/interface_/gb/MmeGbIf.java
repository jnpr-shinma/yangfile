/* 
 * @(#)MmeGbIf.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.mmeSgsn.interface_.gb;
import .ietfInetTypes.Ipv4Address;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt16;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/mmeSgsn/interface_/gb/mme-gb-if"
 * <p>
 * See line 106 in
 * gtlConfig.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class MmeGbIf extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty MmeGbIf object.
     */
    public MmeGbIf() {
        super(Epc.NAMESPACE, "mme-gb-if");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public MmeGbIf clone() {
        return (MmeGbIf)cloneContent(new MmeGbIf());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public MmeGbIf cloneShallow() {
        return (MmeGbIf)cloneShallowContent(new MmeGbIf());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "fr-local-routing-instance",
            "fr-local-ip-address",
            "payload-compression-override",
            "rim-addr-err-pdu-status-cause",
            "ms-flow-control-th-timer",
            "cancel-th-on-ms-move-to-standby",
            "alternative-bmax",
            "version",
            "dscp-mark",
        };
    }

    /* Access methods for optional leaf child: "fr-local-routing-instance". */

    /**
     * Gets the value for child leaf "fr-local-routing-instance".
     * @return The value of the leaf.
     */
    public YangString getFrLocalRoutingInstanceValue() throws JNCException {
        return (YangString)getValue("fr-local-routing-instance");
    }

    /**
     * Sets the value for child leaf "fr-local-routing-instance",
     * using instance of generated typedef class.
     * @param frLocalRoutingInstanceValue The value to set.
     * @param frLocalRoutingInstanceValue used during instantiation.
     */
    public void setFrLocalRoutingInstanceValue(YangString frLocalRoutingInstanceValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fr-local-routing-instance",
            frLocalRoutingInstanceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "fr-local-routing-instance",
     * using a String value.
     * @param frLocalRoutingInstanceValue used during instantiation.
     */
    public void setFrLocalRoutingInstanceValue(String frLocalRoutingInstanceValue)
            throws JNCException {
        setFrLocalRoutingInstanceValue(new YangString(frLocalRoutingInstanceValue));
    }

    /**
     * Unsets the value for child leaf "fr-local-routing-instance".
     */
    public void unsetFrLocalRoutingInstanceValue() throws JNCException {
        delete("fr-local-routing-instance");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "fr-local-routing-instance" leaf will not have a value.
     */
    public void addFrLocalRoutingInstance() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fr-local-routing-instance",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "fr-local-routing-instance" with operation "replace".
     */
    public void markFrLocalRoutingInstanceReplace() throws JNCException {
        markLeafReplace("frLocalRoutingInstance");
    }

    /**
     * Marks the leaf "fr-local-routing-instance" with operation "merge".
     */
    public void markFrLocalRoutingInstanceMerge() throws JNCException {
        markLeafMerge("frLocalRoutingInstance");
    }

    /**
     * Marks the leaf "fr-local-routing-instance" with operation "create".
     */
    public void markFrLocalRoutingInstanceCreate() throws JNCException {
        markLeafCreate("frLocalRoutingInstance");
    }

    /**
     * Marks the leaf "fr-local-routing-instance" with operation "delete".
     */
    public void markFrLocalRoutingInstanceDelete() throws JNCException {
        markLeafDelete("frLocalRoutingInstance");
    }

    /* Access methods for optional leaf child: "fr-local-ip-address". */

    /**
     * Gets the value for child leaf "fr-local-ip-address".
     * @return The value of the leaf.
     */
    public Ipv4Address getFrLocalIpAddressValue() throws JNCException {
        Ipv4Address frLocalIpAddress = (Ipv4Address)getValue("fr-local-ip-address");
        if (frLocalIpAddress == null) {
            frLocalIpAddress = new Ipv4Address("0.0.0.0");  // default
        }
        return frLocalIpAddress;
    }

    /**
     * Sets the value for child leaf "fr-local-ip-address",
     * using a JNC type value.
     * @param frLocalIpAddressValue The value to set.
     * @param frLocalIpAddressValue used during instantiation.
     */
    public void setFrLocalIpAddressValue(Ipv4Address frLocalIpAddressValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fr-local-ip-address",
            frLocalIpAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "fr-local-ip-address",
     * using a String value.
     * @param frLocalIpAddressValue used during instantiation.
     */
    public void setFrLocalIpAddressValue(String frLocalIpAddressValue)
            throws JNCException {
        setFrLocalIpAddressValue(new Ipv4Address(frLocalIpAddressValue));
    }

    /**
     * Unsets the value for child leaf "fr-local-ip-address".
     */
    public void unsetFrLocalIpAddressValue() throws JNCException {
        delete("fr-local-ip-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "fr-local-ip-address" leaf will not have a value.
     */
    public void addFrLocalIpAddress() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "fr-local-ip-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "fr-local-ip-address" with operation "replace".
     */
    public void markFrLocalIpAddressReplace() throws JNCException {
        markLeafReplace("frLocalIpAddress");
    }

    /**
     * Marks the leaf "fr-local-ip-address" with operation "merge".
     */
    public void markFrLocalIpAddressMerge() throws JNCException {
        markLeafMerge("frLocalIpAddress");
    }

    /**
     * Marks the leaf "fr-local-ip-address" with operation "create".
     */
    public void markFrLocalIpAddressCreate() throws JNCException {
        markLeafCreate("frLocalIpAddress");
    }

    /**
     * Marks the leaf "fr-local-ip-address" with operation "delete".
     */
    public void markFrLocalIpAddressDelete() throws JNCException {
        markLeafDelete("frLocalIpAddress");
    }

    /* Access methods for optional leaf child: "payload-compression-override". */

    /**
     * Gets the value for child leaf "payload-compression-override".
     * @return The value of the leaf.
     */
    public YangEnumeration getPayloadCompressionOverrideValue()
            throws JNCException {
        YangEnumeration payloadCompressionOverride = (YangEnumeration)getValue("payload-compression-override");
        if (payloadCompressionOverride == null) {
            payloadCompressionOverride = new YangEnumeration("disable", new String[] {  // default
                "disable",
                "enable",
            });
        }
        return payloadCompressionOverride;
    }

    /**
     * Sets the value for child leaf "payload-compression-override",
     * using instance of generated typedef class.
     * @param payloadCompressionOverrideValue The value to set.
     * @param payloadCompressionOverrideValue used during instantiation.
     */
    public void setPayloadCompressionOverrideValue(YangEnumeration payloadCompressionOverrideValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "payload-compression-override",
            payloadCompressionOverrideValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "payload-compression-override",
     * using a String value.
     * @param payloadCompressionOverrideValue used during instantiation.
     */
    public void setPayloadCompressionOverrideValue(String payloadCompressionOverrideValue)
            throws JNCException {
        setPayloadCompressionOverrideValue(new YangEnumeration(payloadCompressionOverrideValue, new String[] {
             "disable",
             "enable",
        }));
    }

    /**
     * Unsets the value for child leaf "payload-compression-override".
     */
    public void unsetPayloadCompressionOverrideValue() throws JNCException {
        delete("payload-compression-override");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "payload-compression-override" leaf will not have a value.
     */
    public void addPayloadCompressionOverride() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "payload-compression-override",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "payload-compression-override" with operation "replace".
     */
    public void markPayloadCompressionOverrideReplace() throws JNCException {
        markLeafReplace("payloadCompressionOverride");
    }

    /**
     * Marks the leaf "payload-compression-override" with operation "merge".
     */
    public void markPayloadCompressionOverrideMerge() throws JNCException {
        markLeafMerge("payloadCompressionOverride");
    }

    /**
     * Marks the leaf "payload-compression-override" with operation "create".
     */
    public void markPayloadCompressionOverrideCreate() throws JNCException {
        markLeafCreate("payloadCompressionOverride");
    }

    /**
     * Marks the leaf "payload-compression-override" with operation "delete".
     */
    public void markPayloadCompressionOverrideDelete() throws JNCException {
        markLeafDelete("payloadCompressionOverride");
    }

    /* Access methods for optional leaf child: "rim-addr-err-pdu-status-cause". */

    /**
     * Gets the value for child leaf "rim-addr-err-pdu-status-cause".
     * @return The value of the leaf.
     */
    public YangEnumeration getRimAddrErrPduStatusCauseValue()
            throws JNCException {
        YangEnumeration rimAddrErrPduStatusCause = (YangEnumeration)getValue("rim-addr-err-pdu-status-cause");
        if (rimAddrErrPduStatusCause == null) {
            rimAddrErrPduStatusCause = new YangEnumeration("invalid-mandatory-information", new String[] {  // default
                "invalid-mandatory-information",
                "unknown-destination-address",
            });
        }
        return rimAddrErrPduStatusCause;
    }

    /**
     * Sets the value for child leaf "rim-addr-err-pdu-status-cause",
     * using instance of generated typedef class.
     * @param rimAddrErrPduStatusCauseValue The value to set.
     * @param rimAddrErrPduStatusCauseValue used during instantiation.
     */
    public void setRimAddrErrPduStatusCauseValue(YangEnumeration rimAddrErrPduStatusCauseValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rim-addr-err-pdu-status-cause",
            rimAddrErrPduStatusCauseValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "rim-addr-err-pdu-status-cause",
     * using a String value.
     * @param rimAddrErrPduStatusCauseValue used during instantiation.
     */
    public void setRimAddrErrPduStatusCauseValue(String rimAddrErrPduStatusCauseValue)
            throws JNCException {
        setRimAddrErrPduStatusCauseValue(new YangEnumeration(rimAddrErrPduStatusCauseValue, new String[] {
             "invalid-mandatory-information",
             "unknown-destination-address",
        }));
    }

    /**
     * Unsets the value for child leaf "rim-addr-err-pdu-status-cause".
     */
    public void unsetRimAddrErrPduStatusCauseValue() throws JNCException {
        delete("rim-addr-err-pdu-status-cause");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "rim-addr-err-pdu-status-cause" leaf will not have a value.
     */
    public void addRimAddrErrPduStatusCause() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "rim-addr-err-pdu-status-cause",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "rim-addr-err-pdu-status-cause" with operation "replace".
     */
    public void markRimAddrErrPduStatusCauseReplace() throws JNCException {
        markLeafReplace("rimAddrErrPduStatusCause");
    }

    /**
     * Marks the leaf "rim-addr-err-pdu-status-cause" with operation "merge".
     */
    public void markRimAddrErrPduStatusCauseMerge() throws JNCException {
        markLeafMerge("rimAddrErrPduStatusCause");
    }

    /**
     * Marks the leaf "rim-addr-err-pdu-status-cause" with operation "create".
     */
    public void markRimAddrErrPduStatusCauseCreate() throws JNCException {
        markLeafCreate("rimAddrErrPduStatusCause");
    }

    /**
     * Marks the leaf "rim-addr-err-pdu-status-cause" with operation "delete".
     */
    public void markRimAddrErrPduStatusCauseDelete() throws JNCException {
        markLeafDelete("rimAddrErrPduStatusCause");
    }

    /* Access methods for optional leaf child: "ms-flow-control-th-timer". */

    /**
     * Gets the value for child leaf "ms-flow-control-th-timer".
     * @return The value of the leaf.
     */
    public YangString getMsFlowControlThTimerValue() throws JNCException {
        YangString msFlowControlThTimer = (YangString)getValue("ms-flow-control-th-timer");
        if (msFlowControlThTimer == null) {
            msFlowControlThTimer = new YangString("disable");  // default
        }
        return msFlowControlThTimer;
    }

    /**
     * Sets the value for child leaf "ms-flow-control-th-timer",
     * using instance of generated typedef class.
     * @param msFlowControlThTimerValue The value to set.
     * @param msFlowControlThTimerValue used during instantiation.
     */
    public void setMsFlowControlThTimerValue(YangString msFlowControlThTimerValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-flow-control-th-timer",
            msFlowControlThTimerValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ms-flow-control-th-timer",
     * using a String value.
     * @param msFlowControlThTimerValue used during instantiation.
     */
    public void setMsFlowControlThTimerValue(String msFlowControlThTimerValue)
            throws JNCException {
        setMsFlowControlThTimerValue(new YangString(msFlowControlThTimerValue));
    }

    /**
     * Unsets the value for child leaf "ms-flow-control-th-timer".
     */
    public void unsetMsFlowControlThTimerValue() throws JNCException {
        delete("ms-flow-control-th-timer");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ms-flow-control-th-timer" leaf will not have a value.
     */
    public void addMsFlowControlThTimer() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "ms-flow-control-th-timer",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ms-flow-control-th-timer" with operation "replace".
     */
    public void markMsFlowControlThTimerReplace() throws JNCException {
        markLeafReplace("msFlowControlThTimer");
    }

    /**
     * Marks the leaf "ms-flow-control-th-timer" with operation "merge".
     */
    public void markMsFlowControlThTimerMerge() throws JNCException {
        markLeafMerge("msFlowControlThTimer");
    }

    /**
     * Marks the leaf "ms-flow-control-th-timer" with operation "create".
     */
    public void markMsFlowControlThTimerCreate() throws JNCException {
        markLeafCreate("msFlowControlThTimer");
    }

    /**
     * Marks the leaf "ms-flow-control-th-timer" with operation "delete".
     */
    public void markMsFlowControlThTimerDelete() throws JNCException {
        markLeafDelete("msFlowControlThTimer");
    }

    /* Access methods for optional leaf child: "cancel-th-on-ms-move-to-standby". */

    /**
     * Gets the value for child leaf "cancel-th-on-ms-move-to-standby".
     * @return The value of the leaf.
     */
    public YangEnumeration getCancelThOnMsMoveToStandbyValue()
            throws JNCException {
        YangEnumeration cancelThOnMsMoveToStandby = (YangEnumeration)getValue("cancel-th-on-ms-move-to-standby");
        if (cancelThOnMsMoveToStandby == null) {
            cancelThOnMsMoveToStandby = new YangEnumeration("disable", new String[] {  // default
                "disable",
                "enable",
            });
        }
        return cancelThOnMsMoveToStandby;
    }

    /**
     * Sets the value for child leaf "cancel-th-on-ms-move-to-standby",
     * using instance of generated typedef class.
     * @param cancelThOnMsMoveToStandbyValue The value to set.
     * @param cancelThOnMsMoveToStandbyValue used during instantiation.
     */
    public void setCancelThOnMsMoveToStandbyValue(YangEnumeration cancelThOnMsMoveToStandbyValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cancel-th-on-ms-move-to-standby",
            cancelThOnMsMoveToStandbyValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cancel-th-on-ms-move-to-standby",
     * using a String value.
     * @param cancelThOnMsMoveToStandbyValue used during instantiation.
     */
    public void setCancelThOnMsMoveToStandbyValue(String cancelThOnMsMoveToStandbyValue)
            throws JNCException {
        setCancelThOnMsMoveToStandbyValue(new YangEnumeration(cancelThOnMsMoveToStandbyValue, new String[] {
             "disable",
             "enable",
        }));
    }

    /**
     * Unsets the value for child leaf "cancel-th-on-ms-move-to-standby".
     */
    public void unsetCancelThOnMsMoveToStandbyValue() throws JNCException {
        delete("cancel-th-on-ms-move-to-standby");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cancel-th-on-ms-move-to-standby" leaf will not have a value.
     */
    public void addCancelThOnMsMoveToStandby() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cancel-th-on-ms-move-to-standby",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cancel-th-on-ms-move-to-standby" with operation "replace".
     */
    public void markCancelThOnMsMoveToStandbyReplace() throws JNCException {
        markLeafReplace("cancelThOnMsMoveToStandby");
    }

    /**
     * Marks the leaf "cancel-th-on-ms-move-to-standby" with operation "merge".
     */
    public void markCancelThOnMsMoveToStandbyMerge() throws JNCException {
        markLeafMerge("cancelThOnMsMoveToStandby");
    }

    /**
     * Marks the leaf "cancel-th-on-ms-move-to-standby" with operation "create".
     */
    public void markCancelThOnMsMoveToStandbyCreate() throws JNCException {
        markLeafCreate("cancelThOnMsMoveToStandby");
    }

    /**
     * Marks the leaf "cancel-th-on-ms-move-to-standby" with operation "delete".
     */
    public void markCancelThOnMsMoveToStandbyDelete() throws JNCException {
        markLeafDelete("cancelThOnMsMoveToStandby");
    }

    /* Access methods for optional leaf child: "alternative-bmax". */

    /**
     * Gets the value for child leaf "alternative-bmax".
     * @return The value of the leaf.
     */
    public YangUInt16 getAlternativeBmaxValue() throws JNCException {
        YangUInt16 alternativeBmax = (YangUInt16)getValue("alternative-bmax");
        if (alternativeBmax == null) {
            alternativeBmax = new YangUInt16("0");  // default
        }
        return alternativeBmax;
    }

    /**
     * Sets the value for child leaf "alternative-bmax",
     * using instance of generated typedef class.
     * @param alternativeBmaxValue The value to set.
     * @param alternativeBmaxValue used during instantiation.
     */
    public void setAlternativeBmaxValue(YangUInt16 alternativeBmaxValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "alternative-bmax",
            alternativeBmaxValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "alternative-bmax",
     * using Java primitive values.
     * @param alternativeBmaxValue used during instantiation.
     */
    public void setAlternativeBmaxValue(int alternativeBmaxValue)
            throws JNCException {
        setAlternativeBmaxValue(new YangUInt16(alternativeBmaxValue));
    }

    /**
     * Sets the value for child leaf "alternative-bmax",
     * using a String value.
     * @param alternativeBmaxValue used during instantiation.
     */
    public void setAlternativeBmaxValue(String alternativeBmaxValue)
            throws JNCException {
        setAlternativeBmaxValue(new YangUInt16(alternativeBmaxValue));
    }

    /**
     * Unsets the value for child leaf "alternative-bmax".
     */
    public void unsetAlternativeBmaxValue() throws JNCException {
        delete("alternative-bmax");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "alternative-bmax" leaf will not have a value.
     */
    public void addAlternativeBmax() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "alternative-bmax",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "alternative-bmax" with operation "replace".
     */
    public void markAlternativeBmaxReplace() throws JNCException {
        markLeafReplace("alternativeBmax");
    }

    /**
     * Marks the leaf "alternative-bmax" with operation "merge".
     */
    public void markAlternativeBmaxMerge() throws JNCException {
        markLeafMerge("alternativeBmax");
    }

    /**
     * Marks the leaf "alternative-bmax" with operation "create".
     */
    public void markAlternativeBmaxCreate() throws JNCException {
        markLeafCreate("alternativeBmax");
    }

    /**
     * Marks the leaf "alternative-bmax" with operation "delete".
     */
    public void markAlternativeBmaxDelete() throws JNCException {
        markLeafDelete("alternativeBmax");
    }

    /* Access methods for optional leaf child: "version". */

    /**
     * Gets the value for child leaf "version".
     * @return The value of the leaf.
     */
    public YangEnumeration getVersionValue() throws JNCException {
        YangEnumeration version = (YangEnumeration)getValue("version");
        if (version == null) {
            version = new YangEnumeration("10", new String[] {  // default
                "9",
                "10",
            });
        }
        return version;
    }

    /**
     * Sets the value for child leaf "version",
     * using instance of generated typedef class.
     * @param versionValue The value to set.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(YangEnumeration versionValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            versionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "version",
     * using a String value.
     * @param versionValue used during instantiation.
     */
    public void setVersionValue(String versionValue) throws JNCException {
        setVersionValue(new YangEnumeration(versionValue, new String[] {
             "9",
             "10",
        }));
    }

    /**
     * Unsets the value for child leaf "version".
     */
    public void unsetVersionValue() throws JNCException {
        delete("version");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "version" leaf will not have a value.
     */
    public void addVersion() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "version",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "version" with operation "replace".
     */
    public void markVersionReplace() throws JNCException {
        markLeafReplace("version");
    }

    /**
     * Marks the leaf "version" with operation "merge".
     */
    public void markVersionMerge() throws JNCException {
        markLeafMerge("version");
    }

    /**
     * Marks the leaf "version" with operation "create".
     */
    public void markVersionCreate() throws JNCException {
        markLeafCreate("version");
    }

    /**
     * Marks the leaf "version" with operation "delete".
     */
    public void markVersionDelete() throws JNCException {
        markLeafDelete("version");
    }

    /* Access methods for optional leaf child: "dscp-mark". */

    /**
     * Gets the value for child leaf "dscp-mark".
     * @return The value of the leaf.
     */
    public YangString getDscpMarkValue() throws JNCException {
        YangString dscpMark = (YangString)getValue("dscp-mark");
        if (dscpMark == null) {
            dscpMark = new YangString("de");  // default
        }
        return dscpMark;
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using instance of generated typedef class.
     * @param dscpMarkValue The value to set.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(YangString dscpMarkValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            dscpMarkValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "dscp-mark",
     * using a String value.
     * @param dscpMarkValue used during instantiation.
     */
    public void setDscpMarkValue(String dscpMarkValue) throws JNCException {
        setDscpMarkValue(new YangString(dscpMarkValue));
    }

    /**
     * Unsets the value for child leaf "dscp-mark".
     */
    public void unsetDscpMarkValue() throws JNCException {
        delete("dscp-mark");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "dscp-mark" leaf will not have a value.
     */
    public void addDscpMark() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "dscp-mark",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "dscp-mark" with operation "replace".
     */
    public void markDscpMarkReplace() throws JNCException {
        markLeafReplace("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "merge".
     */
    public void markDscpMarkMerge() throws JNCException {
        markLeafMerge("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "create".
     */
    public void markDscpMarkCreate() throws JNCException {
        markLeafCreate("dscpMark");
    }

    /**
     * Marks the leaf "dscp-mark" with operation "delete".
     */
    public void markDscpMarkDelete() throws JNCException {
        markLeafDelete("dscpMark");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
