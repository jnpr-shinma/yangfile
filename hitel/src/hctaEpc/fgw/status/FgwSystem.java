/* 
 * @(#)FgwSystem.java        1.0 09/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "hcta-epc", revision: "2014-09-18".
 */

package hctaEpc.fgw.status;

import Element;

import Epc;

import JNCException;

import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt8;

/**
 * This class represents an element from 
 * the namespace http://hitachi-cta.com/ns/epc
 * generated to "src/hctaEpc/fgw/status/fgw-system"
 * <p>
 * See line 614 in
 * epcCmnNmCli.yang
 *
 * @version 1.0 2014-12-09
 * @author Auto Generated
 */
public class FgwSystem extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty FgwSystem object.
     */
    public FgwSystem() {
        super(Epc.NAMESPACE, "fgw-system");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public FgwSystem clone() {
        return (FgwSystem)cloneContent(new FgwSystem());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public FgwSystem cloneShallow() {
        return (FgwSystem)cloneShallowContent(new FgwSystem());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "location",
            "service",
            "unit-id",
            "admin",
            "oper",
            "standby",
            "usage",
            "availability",
            "procedural",
            "cpu",
            "memory",
            "sync",
        };
    }

    /* Access methods for optional leaf child: "location". */

    /**
     * Gets the value for child leaf "location".
     * @return The value of the leaf.
     */
    public YangString getLocationValue() throws JNCException {
        return (YangString)getValue("location");
    }

    /**
     * Sets the value for child leaf "location",
     * using instance of generated typedef class.
     * @param locationValue The value to set.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(YangString locationValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            locationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "location",
     * using a String value.
     * @param locationValue used during instantiation.
     */
    public void setLocationValue(String locationValue) throws JNCException {
        setLocationValue(new YangString(locationValue));
    }

    /**
     * Unsets the value for child leaf "location".
     */
    public void unsetLocationValue() throws JNCException {
        delete("location");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "location" leaf will not have a value.
     */
    public void addLocation() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "location",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "location" with operation "replace".
     */
    public void markLocationReplace() throws JNCException {
        markLeafReplace("location");
    }

    /**
     * Marks the leaf "location" with operation "merge".
     */
    public void markLocationMerge() throws JNCException {
        markLeafMerge("location");
    }

    /**
     * Marks the leaf "location" with operation "create".
     */
    public void markLocationCreate() throws JNCException {
        markLeafCreate("location");
    }

    /**
     * Marks the leaf "location" with operation "delete".
     */
    public void markLocationDelete() throws JNCException {
        markLeafDelete("location");
    }

    /* Access methods for optional leaf child: "service". */

    /**
     * Gets the value for child leaf "service".
     * @return The value of the leaf.
     */
    public YangString getServiceValue() throws JNCException {
        return (YangString)getValue("service");
    }

    /**
     * Sets the value for child leaf "service",
     * using instance of generated typedef class.
     * @param serviceValue The value to set.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(YangString serviceValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            serviceValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "service",
     * using a String value.
     * @param serviceValue used during instantiation.
     */
    public void setServiceValue(String serviceValue) throws JNCException {
        setServiceValue(new YangString(serviceValue));
    }

    /**
     * Unsets the value for child leaf "service".
     */
    public void unsetServiceValue() throws JNCException {
        delete("service");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "service" leaf will not have a value.
     */
    public void addService() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "service",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "service" with operation "replace".
     */
    public void markServiceReplace() throws JNCException {
        markLeafReplace("service");
    }

    /**
     * Marks the leaf "service" with operation "merge".
     */
    public void markServiceMerge() throws JNCException {
        markLeafMerge("service");
    }

    /**
     * Marks the leaf "service" with operation "create".
     */
    public void markServiceCreate() throws JNCException {
        markLeafCreate("service");
    }

    /**
     * Marks the leaf "service" with operation "delete".
     */
    public void markServiceDelete() throws JNCException {
        markLeafDelete("service");
    }

    /* Access methods for optional leaf child: "unit-id". */

    /**
     * Gets the value for child leaf "unit-id".
     * @return The value of the leaf.
     */
    public YangUInt8 getUnitIdValue() throws JNCException {
        return (YangUInt8)getValue("unit-id");
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using instance of generated typedef class.
     * @param unitIdValue The value to set.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(YangUInt8 unitIdValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unit-id",
            unitIdValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using Java primitive values.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(short unitIdValue) throws JNCException {
        setUnitIdValue(new YangUInt8(unitIdValue));
    }

    /**
     * Sets the value for child leaf "unit-id",
     * using a String value.
     * @param unitIdValue used during instantiation.
     */
    public void setUnitIdValue(String unitIdValue) throws JNCException {
        setUnitIdValue(new YangUInt8(unitIdValue));
    }

    /**
     * Unsets the value for child leaf "unit-id".
     */
    public void unsetUnitIdValue() throws JNCException {
        delete("unit-id");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "unit-id" leaf will not have a value.
     */
    public void addUnitId() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "unit-id",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "unit-id" with operation "replace".
     */
    public void markUnitIdReplace() throws JNCException {
        markLeafReplace("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "merge".
     */
    public void markUnitIdMerge() throws JNCException {
        markLeafMerge("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "create".
     */
    public void markUnitIdCreate() throws JNCException {
        markLeafCreate("unitId");
    }

    /**
     * Marks the leaf "unit-id" with operation "delete".
     */
    public void markUnitIdDelete() throws JNCException {
        markLeafDelete("unitId");
    }

    /* Access methods for optional leaf child: "admin". */

    /**
     * Gets the value for child leaf "admin".
     * @return The value of the leaf.
     */
    public YangString getAdminValue() throws JNCException {
        return (YangString)getValue("admin");
    }

    /**
     * Sets the value for child leaf "admin",
     * using instance of generated typedef class.
     * @param adminValue The value to set.
     * @param adminValue used during instantiation.
     */
    public void setAdminValue(YangString adminValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "admin",
            adminValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "admin",
     * using a String value.
     * @param adminValue used during instantiation.
     */
    public void setAdminValue(String adminValue) throws JNCException {
        setAdminValue(new YangString(adminValue));
    }

    /**
     * Unsets the value for child leaf "admin".
     */
    public void unsetAdminValue() throws JNCException {
        delete("admin");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "admin" leaf will not have a value.
     */
    public void addAdmin() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "admin",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "admin" with operation "replace".
     */
    public void markAdminReplace() throws JNCException {
        markLeafReplace("admin");
    }

    /**
     * Marks the leaf "admin" with operation "merge".
     */
    public void markAdminMerge() throws JNCException {
        markLeafMerge("admin");
    }

    /**
     * Marks the leaf "admin" with operation "create".
     */
    public void markAdminCreate() throws JNCException {
        markLeafCreate("admin");
    }

    /**
     * Marks the leaf "admin" with operation "delete".
     */
    public void markAdminDelete() throws JNCException {
        markLeafDelete("admin");
    }

    /* Access methods for optional leaf child: "oper". */

    /**
     * Gets the value for child leaf "oper".
     * @return The value of the leaf.
     */
    public YangString getOperValue() throws JNCException {
        return (YangString)getValue("oper");
    }

    /**
     * Sets the value for child leaf "oper",
     * using instance of generated typedef class.
     * @param operValue The value to set.
     * @param operValue used during instantiation.
     */
    public void setOperValue(YangString operValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "oper",
            operValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "oper",
     * using a String value.
     * @param operValue used during instantiation.
     */
    public void setOperValue(String operValue) throws JNCException {
        setOperValue(new YangString(operValue));
    }

    /**
     * Unsets the value for child leaf "oper".
     */
    public void unsetOperValue() throws JNCException {
        delete("oper");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "oper" leaf will not have a value.
     */
    public void addOper() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "oper",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "oper" with operation "replace".
     */
    public void markOperReplace() throws JNCException {
        markLeafReplace("oper");
    }

    /**
     * Marks the leaf "oper" with operation "merge".
     */
    public void markOperMerge() throws JNCException {
        markLeafMerge("oper");
    }

    /**
     * Marks the leaf "oper" with operation "create".
     */
    public void markOperCreate() throws JNCException {
        markLeafCreate("oper");
    }

    /**
     * Marks the leaf "oper" with operation "delete".
     */
    public void markOperDelete() throws JNCException {
        markLeafDelete("oper");
    }

    /* Access methods for optional leaf child: "standby". */

    /**
     * Gets the value for child leaf "standby".
     * @return The value of the leaf.
     */
    public YangString getStandbyValue() throws JNCException {
        return (YangString)getValue("standby");
    }

    /**
     * Sets the value for child leaf "standby",
     * using instance of generated typedef class.
     * @param standbyValue The value to set.
     * @param standbyValue used during instantiation.
     */
    public void setStandbyValue(YangString standbyValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "standby",
            standbyValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "standby",
     * using a String value.
     * @param standbyValue used during instantiation.
     */
    public void setStandbyValue(String standbyValue) throws JNCException {
        setStandbyValue(new YangString(standbyValue));
    }

    /**
     * Unsets the value for child leaf "standby".
     */
    public void unsetStandbyValue() throws JNCException {
        delete("standby");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "standby" leaf will not have a value.
     */
    public void addStandby() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "standby",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "standby" with operation "replace".
     */
    public void markStandbyReplace() throws JNCException {
        markLeafReplace("standby");
    }

    /**
     * Marks the leaf "standby" with operation "merge".
     */
    public void markStandbyMerge() throws JNCException {
        markLeafMerge("standby");
    }

    /**
     * Marks the leaf "standby" with operation "create".
     */
    public void markStandbyCreate() throws JNCException {
        markLeafCreate("standby");
    }

    /**
     * Marks the leaf "standby" with operation "delete".
     */
    public void markStandbyDelete() throws JNCException {
        markLeafDelete("standby");
    }

    /* Access methods for optional leaf child: "usage". */

    /**
     * Gets the value for child leaf "usage".
     * @return The value of the leaf.
     */
    public YangString getUsageValue() throws JNCException {
        return (YangString)getValue("usage");
    }

    /**
     * Sets the value for child leaf "usage",
     * using instance of generated typedef class.
     * @param usageValue The value to set.
     * @param usageValue used during instantiation.
     */
    public void setUsageValue(YangString usageValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "usage",
            usageValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "usage",
     * using a String value.
     * @param usageValue used during instantiation.
     */
    public void setUsageValue(String usageValue) throws JNCException {
        setUsageValue(new YangString(usageValue));
    }

    /**
     * Unsets the value for child leaf "usage".
     */
    public void unsetUsageValue() throws JNCException {
        delete("usage");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "usage" leaf will not have a value.
     */
    public void addUsage() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "usage",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "usage" with operation "replace".
     */
    public void markUsageReplace() throws JNCException {
        markLeafReplace("usage");
    }

    /**
     * Marks the leaf "usage" with operation "merge".
     */
    public void markUsageMerge() throws JNCException {
        markLeafMerge("usage");
    }

    /**
     * Marks the leaf "usage" with operation "create".
     */
    public void markUsageCreate() throws JNCException {
        markLeafCreate("usage");
    }

    /**
     * Marks the leaf "usage" with operation "delete".
     */
    public void markUsageDelete() throws JNCException {
        markLeafDelete("usage");
    }

    /* Access methods for optional leaf child: "availability". */

    /**
     * Gets the value for child leaf "availability".
     * @return The value of the leaf.
     */
    public YangString getAvailabilityValue() throws JNCException {
        return (YangString)getValue("availability");
    }

    /**
     * Sets the value for child leaf "availability",
     * using instance of generated typedef class.
     * @param availabilityValue The value to set.
     * @param availabilityValue used during instantiation.
     */
    public void setAvailabilityValue(YangString availabilityValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "availability",
            availabilityValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "availability",
     * using a String value.
     * @param availabilityValue used during instantiation.
     */
    public void setAvailabilityValue(String availabilityValue)
            throws JNCException {
        setAvailabilityValue(new YangString(availabilityValue));
    }

    /**
     * Unsets the value for child leaf "availability".
     */
    public void unsetAvailabilityValue() throws JNCException {
        delete("availability");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "availability" leaf will not have a value.
     */
    public void addAvailability() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "availability",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "availability" with operation "replace".
     */
    public void markAvailabilityReplace() throws JNCException {
        markLeafReplace("availability");
    }

    /**
     * Marks the leaf "availability" with operation "merge".
     */
    public void markAvailabilityMerge() throws JNCException {
        markLeafMerge("availability");
    }

    /**
     * Marks the leaf "availability" with operation "create".
     */
    public void markAvailabilityCreate() throws JNCException {
        markLeafCreate("availability");
    }

    /**
     * Marks the leaf "availability" with operation "delete".
     */
    public void markAvailabilityDelete() throws JNCException {
        markLeafDelete("availability");
    }

    /* Access methods for optional leaf child: "procedural". */

    /**
     * Gets the value for child leaf "procedural".
     * @return The value of the leaf.
     */
    public YangString getProceduralValue() throws JNCException {
        return (YangString)getValue("procedural");
    }

    /**
     * Sets the value for child leaf "procedural",
     * using instance of generated typedef class.
     * @param proceduralValue The value to set.
     * @param proceduralValue used during instantiation.
     */
    public void setProceduralValue(YangString proceduralValue)
            throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "procedural",
            proceduralValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "procedural",
     * using a String value.
     * @param proceduralValue used during instantiation.
     */
    public void setProceduralValue(String proceduralValue) throws JNCException {
        setProceduralValue(new YangString(proceduralValue));
    }

    /**
     * Unsets the value for child leaf "procedural".
     */
    public void unsetProceduralValue() throws JNCException {
        delete("procedural");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "procedural" leaf will not have a value.
     */
    public void addProcedural() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "procedural",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "procedural" with operation "replace".
     */
    public void markProceduralReplace() throws JNCException {
        markLeafReplace("procedural");
    }

    /**
     * Marks the leaf "procedural" with operation "merge".
     */
    public void markProceduralMerge() throws JNCException {
        markLeafMerge("procedural");
    }

    /**
     * Marks the leaf "procedural" with operation "create".
     */
    public void markProceduralCreate() throws JNCException {
        markLeafCreate("procedural");
    }

    /**
     * Marks the leaf "procedural" with operation "delete".
     */
    public void markProceduralDelete() throws JNCException {
        markLeafDelete("procedural");
    }

    /* Access methods for optional leaf child: "cpu". */

    /**
     * Gets the value for child leaf "cpu".
     * @return The value of the leaf.
     */
    public YangString getCpuValue() throws JNCException {
        return (YangString)getValue("cpu");
    }

    /**
     * Sets the value for child leaf "cpu",
     * using instance of generated typedef class.
     * @param cpuValue The value to set.
     * @param cpuValue used during instantiation.
     */
    public void setCpuValue(YangString cpuValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cpu",
            cpuValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cpu",
     * using a String value.
     * @param cpuValue used during instantiation.
     */
    public void setCpuValue(String cpuValue) throws JNCException {
        setCpuValue(new YangString(cpuValue));
    }

    /**
     * Unsets the value for child leaf "cpu".
     */
    public void unsetCpuValue() throws JNCException {
        delete("cpu");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cpu" leaf will not have a value.
     */
    public void addCpu() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "cpu",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cpu" with operation "replace".
     */
    public void markCpuReplace() throws JNCException {
        markLeafReplace("cpu");
    }

    /**
     * Marks the leaf "cpu" with operation "merge".
     */
    public void markCpuMerge() throws JNCException {
        markLeafMerge("cpu");
    }

    /**
     * Marks the leaf "cpu" with operation "create".
     */
    public void markCpuCreate() throws JNCException {
        markLeafCreate("cpu");
    }

    /**
     * Marks the leaf "cpu" with operation "delete".
     */
    public void markCpuDelete() throws JNCException {
        markLeafDelete("cpu");
    }

    /* Access methods for optional leaf child: "memory". */

    /**
     * Gets the value for child leaf "memory".
     * @return The value of the leaf.
     */
    public YangString getMemoryValue() throws JNCException {
        return (YangString)getValue("memory");
    }

    /**
     * Sets the value for child leaf "memory",
     * using instance of generated typedef class.
     * @param memoryValue The value to set.
     * @param memoryValue used during instantiation.
     */
    public void setMemoryValue(YangString memoryValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "memory",
            memoryValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "memory",
     * using a String value.
     * @param memoryValue used during instantiation.
     */
    public void setMemoryValue(String memoryValue) throws JNCException {
        setMemoryValue(new YangString(memoryValue));
    }

    /**
     * Unsets the value for child leaf "memory".
     */
    public void unsetMemoryValue() throws JNCException {
        delete("memory");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "memory" leaf will not have a value.
     */
    public void addMemory() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "memory",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "memory" with operation "replace".
     */
    public void markMemoryReplace() throws JNCException {
        markLeafReplace("memory");
    }

    /**
     * Marks the leaf "memory" with operation "merge".
     */
    public void markMemoryMerge() throws JNCException {
        markLeafMerge("memory");
    }

    /**
     * Marks the leaf "memory" with operation "create".
     */
    public void markMemoryCreate() throws JNCException {
        markLeafCreate("memory");
    }

    /**
     * Marks the leaf "memory" with operation "delete".
     */
    public void markMemoryDelete() throws JNCException {
        markLeafDelete("memory");
    }

    /* Access methods for optional leaf child: "sync". */

    /**
     * Gets the value for child leaf "sync".
     * @return The value of the leaf.
     */
    public YangString getSyncValue() throws JNCException {
        return (YangString)getValue("sync");
    }

    /**
     * Sets the value for child leaf "sync",
     * using instance of generated typedef class.
     * @param syncValue The value to set.
     * @param syncValue used during instantiation.
     */
    public void setSyncValue(YangString syncValue) throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sync",
            syncValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "sync",
     * using a String value.
     * @param syncValue used during instantiation.
     */
    public void setSyncValue(String syncValue) throws JNCException {
        setSyncValue(new YangString(syncValue));
    }

    /**
     * Unsets the value for child leaf "sync".
     */
    public void unsetSyncValue() throws JNCException {
        delete("sync");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "sync" leaf will not have a value.
     */
    public void addSync() throws JNCException {
        setLeafValue(Epc.NAMESPACE,
            "sync",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "sync" with operation "replace".
     */
    public void markSyncReplace() throws JNCException {
        markLeafReplace("sync");
    }

    /**
     * Marks the leaf "sync" with operation "merge".
     */
    public void markSyncMerge() throws JNCException {
        markLeafMerge("sync");
    }

    /**
     * Marks the leaf "sync" with operation "create".
     */
    public void markSyncCreate() throws JNCException {
        markLeafCreate("sync");
    }

    /**
     * Marks the leaf "sync" with operation "delete".
     */
    public void markSyncDelete() throws JNCException {
        markLeafDelete("sync");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
